<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>PostSharp</name>
  </assembly>
  <members>
    <member name="T:PostSharp.Aspects.Advices.Advice">
      <summary>
            Base class for all custom attributes annotating aspect extensions.
            </summary>
      <remarks>
        <para>Advices are behaviors added to aspects by the way of custom
            attributes. Other ways to add behaviors is to implement interface methods.
            </para>
        <para>
            Advice custom attributes are typically used on aspect classes,
            or on members of aspect classes.
            </para>
      </remarks>
    </member>
    <member name="T:PostSharp.Aspects.Advices.MethodInterceptionAdvice">
      <summary>
            Custom attribute that, when applied on a method of an aspect class, specifies
            that this method is an advice having the same semantics as <see cref="M:PostSharp.Aspects.IMethodInterceptionAspect.OnInvoke(PostSharp.Aspects.MethodInterceptionArgs)" />.
            </summary>
      <remarks>
        <para>
            The method to which this custom attribute is applied must be public and must have the same signature as
            <see cref="M:PostSharp.Aspects.IMethodInterceptionAspect.OnInvoke(PostSharp.Aspects.MethodInterceptionArgs)" />. However, it can be static.
            </para>
      </remarks>
      <seealso cref="T:PostSharp.Aspects.IMethodInterceptionAspect" />
      <seealso cref="T:PostSharp.Aspects.MethodInterceptionAspect" />
    </member>
    <member name="T:PostSharp.Aspects.Advices.OnEventAddHandlerAdvice">
      <summary>
            Custom attribute that, when applied on a method of an aspect class, specifies
            that this method is an advice having the same semantics as <see cref="M:PostSharp.Aspects.IEventInterceptionAspect.OnAddHandler(PostSharp.Aspects.EventInterceptionArgs)" />.
            </summary>
      <remarks>
        <para>
            The method to which this custom attribute is applied must be public and must have the same signature as
            <see cref="M:PostSharp.Aspects.IEventInterceptionAspect.OnAddHandler(PostSharp.Aspects.EventInterceptionArgs)" />. However, it can be static.
            </para>
        <br />
        <para>
      If an aspect defines many advices (among <see cref="T:PostSharp.Aspects.Advices.OnEventAddHandlerAdvice" />, <see cref="T:PostSharp.Aspects.Advices.OnEventRemoveHandlerAdvice" /> and
      <see cref="T:PostSharp.Aspects.Advices.OnEventInvokeHandlerAdvice" />) that are meant to be applied to the same events with consistent ordering, these advices should be
      grouped together (see <see cref="P:PostSharp.Aspects.Advices.GroupingAdvice.Master" /> property).
    </para>
        <note>
      Standalone advices or group masters should also be annotated by a custom attribute derived from <see cref="T:PostSharp.Aspects.Advices.Pointcut" />.
    </note>
        <seealso cref="T:PostSharp.Aspects.IEventInterceptionAspect" />
        <seealso cref="T:PostSharp.Aspects.Advices.OnEventAddHandlerAdvice" />
        <seealso cref="T:PostSharp.Aspects.Advices.OnEventInvokeHandlerAdvice" />
        <br />
        <note>
      Because of the way how the C# compiler implements
      <b>automatic events</b>
      (i.e. events where you
      don't implement the
      <c>Add</c>
      and
      <c>Remove</c>
      semantics manually), the
      <b>Invoke Event Handler</b>
      semantic (
      <see cref="M:PostSharp.Aspects.IEventInterceptionAspect.OnInvokeHandler(PostSharp.Aspects.EventInterceptionArgs)" />
      or equivalent) shall
      <b>not</b>
      be invoked for delegates that have been added from inside the class that declares this event.
    </note>
      </remarks>
    </member>
    <member name="T:PostSharp.Aspects.Advices.GroupingAdvice">
      <summary>
            Base class for all advices that are possibly composed of
            multiple advices that can be grouped together using the <see cref="P:PostSharp.Aspects.Advices.GroupingAdvice.Master" />
            property.
            </summary>
    </member>
    <member name="P:PostSharp.Aspects.Advices.GroupingAdvice.Master">
      <summary>
            Name of the master advice method. If this property is not set,
            the current method is itself the master of the group. Only
            master methods can define selectors (<see cref="T:PostSharp.Aspects.Advices.Pointcut" />)
            and dependencies (<see cref="T:PostSharp.Aspects.Dependencies.AspectDependencyAttribute" />).
            </summary>
    </member>
    <member name="T:PostSharp.Aspects.Advices.OnEventInvokeHandlerAdvice">
      <summary>
            Custom attribute that, when applied on a method of an aspect class, specifies
            that this method is an advice having the same semantics as <see cref="M:PostSharp.Aspects.IEventInterceptionAspect.OnInvokeHandler(PostSharp.Aspects.EventInterceptionArgs)" />.
            </summary>
      <remarks>
        <para>
            The method to which this custom attribute is applied must be public and must have the same signature as
            <see cref="M:PostSharp.Aspects.IEventInterceptionAspect.OnInvokeHandler(PostSharp.Aspects.EventInterceptionArgs)" />. However, it can be static.
            </para>
        <para>
      If an aspect defines many advices (among <see cref="T:PostSharp.Aspects.Advices.OnEventAddHandlerAdvice" />, <see cref="T:PostSharp.Aspects.Advices.OnEventRemoveHandlerAdvice" /> and
      <see cref="T:PostSharp.Aspects.Advices.OnEventInvokeHandlerAdvice" />) that are meant to be applied to the same events with consistent ordering, these advices should be
      grouped together (see <see cref="P:PostSharp.Aspects.Advices.GroupingAdvice.Master" /> property).
    </para>
        <note>
      Standalone advices or group masters should also be annotated by a custom attribute derived from <see cref="T:PostSharp.Aspects.Advices.Pointcut" />.
    </note>
        <seealso cref="T:PostSharp.Aspects.IEventInterceptionAspect" />
        <seealso cref="T:PostSharp.Aspects.Advices.OnEventAddHandlerAdvice" />
        <seealso cref="T:PostSharp.Aspects.Advices.OnEventInvokeHandlerAdvice" />
        <br />
        <note>
      Because of the way how the C# compiler implements
      <b>automatic events</b>
      (i.e. events where you
      don't implement the
      <c>Add</c>
      and
      <c>Remove</c>
      semantics manually), the
      <b>Invoke Event Handler</b>
      semantic (
      <see cref="M:PostSharp.Aspects.IEventInterceptionAspect.OnInvokeHandler(PostSharp.Aspects.EventInterceptionArgs)" />
      or equivalent) shall
      <b>not</b>
      be invoked for delegates that have been added from inside the class that declares this event.
    </note>
      </remarks>
    </member>
    <member name="T:PostSharp.Aspects.Advices.OnEventRemoveHandlerAdvice">
      <summary>
            Custom attribute that, when applied on a method of an aspect class, specifies that this method is an advice
            having the same semantics as <see cref="M:PostSharp.Aspects.IEventInterceptionAspect.OnRemoveHandler(PostSharp.Aspects.EventInterceptionArgs)" />.
            </summary>
      <remarks>
        <para>
            The method to which this custom attribute is applied must be public and must have the same signature as
            <see cref="M:PostSharp.Aspects.IEventInterceptionAspect.OnRemoveHandler(PostSharp.Aspects.EventInterceptionArgs)" />. However, it can be static.
            </para>
        <br />
        <para>
      If an aspect defines many advices (among <see cref="T:PostSharp.Aspects.Advices.OnEventAddHandlerAdvice" />, <see cref="T:PostSharp.Aspects.Advices.OnEventRemoveHandlerAdvice" /> and
      <see cref="T:PostSharp.Aspects.Advices.OnEventInvokeHandlerAdvice" />) that are meant to be applied to the same events with consistent ordering, these advices should be
      grouped together (see <see cref="P:PostSharp.Aspects.Advices.GroupingAdvice.Master" /> property).
    </para>
        <note>
      Standalone advices or group masters should also be annotated by a custom attribute derived from <see cref="T:PostSharp.Aspects.Advices.Pointcut" />.
    </note>
        <seealso cref="T:PostSharp.Aspects.IEventInterceptionAspect" />
        <seealso cref="T:PostSharp.Aspects.Advices.OnEventAddHandlerAdvice" />
        <seealso cref="T:PostSharp.Aspects.Advices.OnEventInvokeHandlerAdvice" />
        <br />
        <note>
      Because of the way how the C# compiler implements
      <b>automatic events</b>
      (i.e. events where you
      don't implement the
      <c>Add</c>
      and
      <c>Remove</c>
      semantics manually), the
      <b>Invoke Event Handler</b>
      semantic (
      <see cref="M:PostSharp.Aspects.IEventInterceptionAspect.OnInvokeHandler(PostSharp.Aspects.EventInterceptionArgs)" />
      or equivalent) shall
      <b>not</b>
      be invoked for delegates that have been added from inside the class that declares this event.
    </note>
      </remarks>
    </member>
    <member name="T:PostSharp.Aspects.Advices.CopyCustomAttributesAttribute">
      <summary>
            Custom attribute that, when applied on an aspect class, requires custom
            attributes present on the aspect class to be copied to the target of this class.
            When applied on an introduced member (see <see cref="T:PostSharp.Aspects.Advices.IntroduceMemberAttribute" />),
            this custom attribute requires custom attributes present on the aspect member
            to be copied to the introduced member.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.Advices.CopyCustomAttributesAttribute.#ctor(System.Type)">
      <summary>
            Requires custom attributes present on the aspect class or aspect class member
            to be copied to the aspect target or to the introduced member, respectively.
            </summary>
      <param name="type">Base type of custom attributes to be copied.</param>
    </member>
    <member name="M:PostSharp.Aspects.Advices.CopyCustomAttributesAttribute.#ctor(System.Type[])">
      <summary>
            Requires custom attributes present on the aspect class or aspect class member
            to be copied to the aspect target or to the introduced member, respectively.
            </summary>
      <param name="types">Base types of custom attributes to be copied.</param>
    </member>
    <member name="P:PostSharp.Aspects.Advices.CopyCustomAttributesAttribute.OverrideAction">
      <summary>
            Determines what should happen when a custom attribute of the same
            type is already present on the target declaration.
            </summary>
    </member>
    <member name="P:PostSharp.Aspects.Advices.CopyCustomAttributesAttribute.Types">
      <summary>
            Gets the list of custom attribute types to be copied.
            </summary>
    </member>
    <member name="T:PostSharp.Aspects.Advices.CustomAttributeOverrideAction">
      <summary>
            Behavior of <see cref="T:PostSharp.Aspects.Advices.CopyCustomAttributesAttribute" /> when a custom
            attribute of the same type already exists on the target declaration.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Advices.CustomAttributeOverrideAction.Default">
      <summary>
            Default (<see cref="F:PostSharp.Aspects.Advices.CustomAttributeOverrideAction.Fail" />).
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Advices.CustomAttributeOverrideAction.Fail">
      <summary>
            Emits an error message.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Advices.CustomAttributeOverrideAction.Ignore">
      <summary>
            Silently ignore this custom attribute (does not copy it, without
            error message).
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Advices.CustomAttributeOverrideAction.Add">
      <summary>
            Adds a new copy (possibly duplicate) of the custom attribute.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Advices.CustomAttributeOverrideAction.MergeAddProperty">
      <summary>
            Merges the existing custom attribute with the template custom attribute
            by adding properties and fields. If the existing custom attribute defines
            the same properties and fields as the template custom attribute, 
            they are not overridden.
            </summary>
      <remarks>
            Constructors arguments of the template custom attribute are 
            ignored during merging.
            </remarks>
    </member>
    <member name="F:PostSharp.Aspects.Advices.CustomAttributeOverrideAction.MergeReplaceProperty">
      <summary>
            Merges the exising custom attribute with the template custom attribute
            by adding and replacing properties and fields. If the existing custom
            attribute defines the same properties and fields as the template custom
            attribute, they are replaced by the values defined in the template
            custom attribute.
            </summary>
      <remarks>
            Constructors arguments of the template custom attribute are 
            ignored during merging.
            </remarks>
    </member>
    <member name="T:PostSharp.Aspects.Advices.Event`1">
      <summary>
            Mimics the semantics of an event for use
            with the <see cref="T:PostSharp.Aspects.Advices.ImportMemberAttribute" /> aspect extension.
            </summary>
      <typeparam name="TDelegate">Handler type (derived from <see cref="T:System.Delegate" />).</typeparam>
    </member>
    <member name="M:PostSharp.Aspects.Advices.Event`1.#ctor(PostSharp.Aspects.Advices.EventAccessor{`0},PostSharp.Aspects.Advices.EventAccessor{`0})">
      <internal />
    </member>
    <member name="P:PostSharp.Aspects.Advices.Event`1.Add">
      <summary>
            Gets a delegate enabling to invoke the <b>add</b> accessor
            of the imported event.
            </summary>
    </member>
    <member name="P:PostSharp.Aspects.Advices.Event`1.Remove">
      <summary>
            Gets a delegate enabling to invoke the <b>remove</b> accessor
            of the imported event.
            </summary>
    </member>
    <member name="T:PostSharp.Aspects.Advices.EventAccessor`1">
      <summary>
            Defines the signature of methods implementing the <see cref="P:PostSharp.Aspects.Advices.Event`1.Add" />
            and <see cref="P:PostSharp.Aspects.Advices.Event`1.Remove" /> semantics of an event.
            </summary>
      <typeparam name="TDelegate">Handler type (derived from <see cref="T:System.Delegate" />).</typeparam>
      <param name="delegate">Handler.</param>
      <seealso cref="T:PostSharp.Aspects.Advices.Event`1" />
    </member>
    <member name="T:PostSharp.Aspects.Advices.ImportMemberAttribute">
      <summary>
            Custom attribute that, when applied to an instance field of an aspect class, determines
            that this field should be bound to a method, event or property, of the
            target class of this aspect. Valid types for fields are
            a concrete <see cref="T:System.Delegate" /> (to bind to a method),
            <see cref="T:PostSharp.Aspects.Advices.Property`1" /> or <see cref="T:PostSharp.Aspects.Advices.Property`2" />
            (to bind to a property), or <see cref="T:PostSharp.Aspects.Advices.Event`1" /> (to bind to an event).
            </summary>
      <remarks>
        <para>Fields annotated with the <see cref="T:PostSharp.Aspects.Advices.ImportMemberAttribute" />
            custom attribute must be public and must not be read only.</para>
        <para>At runtime, these fields are assigned to a delegate (in case
            of method binding) or a pair of delegates (in case of event or property
            binding) allowing to invoke the imported member.</para>
        <para>When the target type does not contain a member of the required
            name and signature</para>
      </remarks>
    </member>
    <member name="M:PostSharp.Aspects.Advices.ImportMemberAttribute.#ctor(System.String)">
      <summary />
      <param name="memberName" />
    </member>
    <member name="P:PostSharp.Aspects.Advices.ImportMemberAttribute.IsRequired">
      <summary>
            Determines whether a build time error must be issued if the member to be
            imported is absent. If <c>false</c>, the binding field will be <c>null</c>
            in case the imported member is absent.
            </summary>
    </member>
    <member name="P:PostSharp.Aspects.Advices.ImportMemberAttribute.MemberName">
      <summary>
            Name of the imported member.
            </summary>
    </member>
    <member name="P:PostSharp.Aspects.Advices.ImportMemberAttribute.Order">
      <summary>
            Determines when the member should be imported: either before (<see cref="F:PostSharp.Aspects.Advices.ImportMemberOrder.BeforeIntroductions" />)
            or after (<see cref="F:PostSharp.Aspects.Advices.ImportMemberOrder.AfterIntroductions" />) members have been introduced by the current aspect.
            Default is <see cref="F:PostSharp.Aspects.Advices.ImportMemberOrder.BeforeIntroductions" />.
            </summary>
      <remarks>
            Sometimes it makes sense for an aspect to import a member <i>after</i> the same aspect has introduced member.
            This allows the aspect to invoke a member that could be overridden by later aspects.
            </remarks>
    </member>
    <member name="T:PostSharp.Aspects.Advices.ImportMemberOrder">
      <summary>
            Enumeration of moments when members should be imported into an aspect.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Advices.ImportMemberOrder.Default">
      <summary>
        <see cref="F:PostSharp.Aspects.Advices.ImportMemberOrder.BeforeIntroductions" />
      </summary>
    </member>
    <member name="F:PostSharp.Aspects.Advices.ImportMemberOrder.BeforeIntroductions">
      <summary>
            Before the aspect introduces its own members.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Advices.ImportMemberOrder.AfterIntroductions">
      <summary>
            After the aspect introduces its own members.
            </summary>
    </member>
    <member name="T:PostSharp.Aspects.Advices.IntroduceInterfaceAttribute">
      <summary>
            Custom attribute that, when applied to an aspect class, specifies that the aspect should
            introduce a given interface into the type to which the aspect is applied.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.Advices.IntroduceInterfaceAttribute.#ctor(System.Type)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Aspects.Advices.IntroduceInterfaceAttribute" />.
            </summary>
      <param name="interfaceType">Interface that should be introduced into the types
            to which the aspect is applied.</param>
    </member>
    <member name="P:PostSharp.Aspects.Advices.IntroduceInterfaceAttribute.IsProtected">
      <summary>
            Determines whether the interface should be exposed indirectly through the 
            <see cref="T:PostSharp.Aspects.IProtectedInterface`1" /> interface. If <c>false</c>, the interface
            will be implemented directly by the type.
            </summary>
    </member>
    <member name="P:PostSharp.Aspects.Advices.IntroduceInterfaceAttribute.OverrideAction">
      <summary>
            Specifies the action (<see cref="F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Fail" /> or <see cref="F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Ignore" />)
            to be overtaken when the interface specified in the constructor of this custom attribute
            is already implemented by the type to which the current aspect is applied.
            </summary>
      <seealso cref="P:PostSharp.Aspects.Advices.IntroduceInterfaceAttribute.AncestorOverrideAction" />
    </member>
    <member name="P:PostSharp.Aspects.Advices.IntroduceInterfaceAttribute.AncestorOverrideAction">
      <summary>
            Specifies the action (<see cref="F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Fail" /> or <see cref="F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Ignore" />)
            to be overtaken when an <i>ancestor</i> of the interface specified in the constructor of this custom attribute
            is already implemented by the type to which the current aspect is applied.
            </summary>
      <seealso cref="P:PostSharp.Aspects.Advices.IntroduceInterfaceAttribute.OverrideAction" />
    </member>
    <member name="T:PostSharp.Aspects.Advices.IntroduceMemberAttribute">
      <summary>
            Custom attribute that, when applied on a method, event or property of an aspect class, specifies
            that this method, event or property should be introduced into the types to which the aspect is applied.
            </summary>
      <remarks>
            Methods, properties and events annotated with <see cref="T:PostSharp.Aspects.Advices.IntroduceMemberAttribute" /> must be public.
            </remarks>
    </member>
    <member name="P:PostSharp.Aspects.Advices.IntroduceMemberAttribute.Visibility">
      <summary>
            Determines the visibility (<see cref="F:PostSharp.CodeModel.Visibility.Public" />, (<see cref="F:PostSharp.CodeModel.Visibility.Family" />, ...)
            of the introduced member.
            </summary>
    </member>
    <member name="P:PostSharp.Aspects.Advices.IntroduceMemberAttribute.IsVirtual">
      <summary>
            Determines whether the introduced member should be virtual.
            </summary>
      <remarks>
        <para>
            When this property is <c>false</c> and the member already exists in a base type
            and is virtual, the member is overridden and marked as <c>sealed</c>.
            </para>
        <para>
            When this property is not set, the introduced member is <c>virtual</c> if it exists in a base
            type as a virtual member, otherwise non-virtual.
            </para>
      </remarks>
    </member>
    <member name="P:PostSharp.Aspects.Advices.IntroduceMemberAttribute.IsIsVirtualSpecified">
      <summary>
            Determines whether the <see cref="P:PostSharp.Aspects.Advices.IntroduceMemberAttribute.IsVirtual" /> property has been specified.
            </summary>
    </member>
    <member name="P:PostSharp.Aspects.Advices.IntroduceMemberAttribute.OverrideAction">
      <summary>
            Determines the action to be overtaken when the member to be introduced already exists
            in the type to which the aspect is applied, or to a base type.
            </summary>
    </member>
    <member name="T:PostSharp.Aspects.Advices.MemberOverrideAction">
      <summary>
            Enumeration of actions to be overtaken by the <see cref="T:PostSharp.Aspects.Advices.IntroduceMemberAttribute" /> aspect extension
            when the member to be introduced already exists in the aspect target type or its base type.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Advices.MemberOverrideAction.Default">
      <summary>
        <see cref="F:PostSharp.Aspects.Advices.MemberOverrideAction.Fail" />
      </summary>
    </member>
    <member name="F:PostSharp.Aspects.Advices.MemberOverrideAction.Fail">
      <summary>
            Emits a build time error.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Advices.MemberOverrideAction.Ignore">
      <summary>
            Silently ignore the member introduction.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Advices.MemberOverrideAction.OverrideOrFail">
      <summary>
            Tries to override the member, and fails if it is impossible (i.e. if the existing member is defined
            in a base type and is sealed or non-virtual).
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Advices.MemberOverrideAction.OverrideOrIgnore">
      <summary>
            Tries to override the member, and silently ignore if it is impossible (i.e. if the existing member is defined
            in a base type and is sealed or non-virtual).
            </summary>
    </member>
    <member name="T:PostSharp.Aspects.Advices.MethodPointcut">
      <summary>
            Custom attribute that, when applied on an advice method, specifies the name of
            the method that will be invoked at build-time to return the set of elements of code
            to which the advice applies. 
            </summary>
      <remarks>
        <para>
            This method should have the signature
            <c>IEnumerable&lt;AdviceTargetType&gt; SelectCodeElements(AspectTargetType target)</c> ,
            where <c>AspectTargetType</c> is either <c>object</c> either a reflection type
            corresponding to the kind of targets of the <i>aspect</i> (for instance <c>System.Type</c>
            for a type-level aspect), and <c>AdviceTargetType</c> is either <c>object</c> either
            a reflection type of the kind of targets of the <i>advice</i> (for instance <c>System.MethodInfo</c> for a method-level advice).
            </para>
      </remarks>
    </member>
    <member name="T:PostSharp.Aspects.Advices.Pointcut">
      <summary>
            Custom attribute, typically accompanying an advice, specifying
            to which code elements the advice applies. 
            </summary>
      <seealso cref="T:PostSharp.Aspects.Advices.MulticastPointcut" />
    </member>
    <member name="M:PostSharp.Aspects.Advices.MethodPointcut.#ctor(System.String)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Aspects.Advices.MethodPointcut" />.
            </summary>
      <param name="methodName">Name of the method returning the set of targets. This method should have
            a specific signature as discussed in the <see cref="T:PostSharp.Aspects.Advices.MethodPointcut">class documentation</see>.</param>
    </member>
    <member name="P:PostSharp.Aspects.Advices.MethodPointcut.MethodName">
      <summary>
            Gets the name of the method returning the set of code elements.
            </summary>
    </member>
    <member name="T:PostSharp.Aspects.Advices.MulticastPointcut">
      <summary>
            Custom attribute that, when applied on an advice method, specifies to which elements of
            code this advice applies, based on the kind, name and attributes of code elements.
            Works similarly as <see cref="T:PostSharp.Extensibility.MulticastAttribute" />.
            </summary>
    </member>
    <member name="P:PostSharp.Aspects.Advices.MulticastPointcut.MemberName">
      <summary>
            Gets or sets the expression specifying to which members 
            the aspect extension applies.
            </summary>
      <value>
            A wildcard or regular expression specifying to which members
            this instance applies, or <c>null</c> this instance
            applies either to all members whose kind is given in <see cref="P:PostSharp.Aspects.Advices.MulticastPointcut.Targets" />.
            Regular expressions should start with the <code>regex:</code> prefix.
            </value>
    </member>
    <member name="P:PostSharp.Aspects.Advices.MulticastPointcut.Targets">
      <summary>
            Gets or sets the kind of elements to which this aspect extension applies.
            </summary>
    </member>
    <member name="P:PostSharp.Aspects.Advices.MulticastPointcut.Attributes">
      <summary>
            Gets or sets the visibilities, scopes, virtualities, and implementation
             of members to which this attribute applies.
            </summary>
      <remarks>
        <para>
            The <see cref="T:PostSharp.Extensibility.MulticastAttributes" /> enumeration is a multi-part flag: there is one
            part for visibility, one for scope, one for virtuality, and one for implementation.
            If you specify one part, it will override the values defined on the custom attribute definition.
            </para>
      </remarks>
    </member>
    <member name="T:PostSharp.Aspects.Advices.OnLocationGetValueAdvice">
      <summary>
            Custom attribute that, when applied on a method of an aspect class, specifies
            that this method is an advice having the same semantics as <see cref="M:PostSharp.Aspects.ILocationInterceptionAspect.OnGetValue(PostSharp.Aspects.LocationInterceptionArgs)" />.
            </summary>
      <remarks>
        <para>
            The method to which this custom attribute is applied must be public and must have the same signature as
            <see cref="M:PostSharp.Aspects.ILocationInterceptionAspect.OnGetValue(PostSharp.Aspects.LocationInterceptionArgs)" />. However, it can be static.
            </para>
        <para>
            If an aspect defines many advices (among <see cref="T:PostSharp.Aspects.Advices.OnLocationSetValueAdvice" />, 
            <see cref="T:PostSharp.Aspects.Advices.OnLocationGetValueAdvice" />) and if these advices
            are meant to be applied to the same properties with consistent ordering, they should be
            grouped together (see <see cref="P:PostSharp.Aspects.Advices.GroupingAdvice.Master" /> property).
            </para>
        <para>
            Standalone advices or group masters should also be annotated by a custom attribute derived from
            <see cref="T:PostSharp.Aspects.Advices.Pointcut" />.
            </para>
      </remarks>
      <seealso cref="T:PostSharp.Aspects.ILocationLevelAspect" />
      <seealso cref="T:PostSharp.Aspects.Advices.OnLocationSetValueAdvice" />
    </member>
    <member name="T:PostSharp.Aspects.Advices.OnLocationSetValueAdvice">
      <summary>
            Custom attribute that, when applied on a method of an aspect class, specifies
            that this method is an advice having the same semantics as <see cref="M:PostSharp.Aspects.ILocationInterceptionAspect.OnSetValue(PostSharp.Aspects.LocationInterceptionArgs)" />.
            </summary>
      <remarks>
        <para>
            The method to which this custom attribute is applied must be public and must have the same signature as
            <see cref="M:PostSharp.Aspects.ILocationInterceptionAspect.OnSetValue(PostSharp.Aspects.LocationInterceptionArgs)" />. However, it can be static.
            </para>
        <para>
            If an aspect defines many advices (amoung <see cref="T:PostSharp.Aspects.Advices.OnLocationSetValueAdvice" />, 
            <see cref="T:PostSharp.Aspects.Advices.OnLocationGetValueAdvice" />) and if these advices
            are meant to be applied to the same properties with consistent ordering, they should be
            grouped together (see <see cref="P:PostSharp.Aspects.Advices.GroupingAdvice.Master" /> property).
            </para>
        <para>
            Standalone advices or group masters should also be annotated by a custom attribute derived from
            <see cref="T:PostSharp.Aspects.Advices.Pointcut" />.
            </para>
      </remarks>
      <seealso cref="T:PostSharp.Aspects.ILocationLevelAspect" />
      <seealso cref="T:PostSharp.Aspects.Advices.OnLocationGetValueAdvice" />
    </member>
    <member name="T:PostSharp.Aspects.Advices.OnMethodEntryAdvice">
      <summary>
            Custom attribute that, when applied on a method of an aspect class, specifies
            that this method is an advice having the same semantics as <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnEntry(PostSharp.Aspects.MethodExecutionArgs)" />.
            </summary>
      <remarks>
        <para>
            The method to which this custom attribute is applied must be public and must have the same signature as
            <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnEntry(PostSharp.Aspects.MethodExecutionArgs)" />. However, it can be static.
            </para>
        <br />
        <para>
       If an aspect defines many advices (among <see cref="T:PostSharp.Aspects.Advices.OnMethodEntryAdvice" />, <see cref="T:PostSharp.Aspects.Advices.OnMethodExitAdvice" />, <see cref="T:PostSharp.Aspects.Advices.OnMethodSuccessAdvice" />
       and <see cref="T:PostSharp.Aspects.Advices.OnMethodExceptionAdvice" />) that are meant to be applied to the same methods with consistent ordering, these advices should be
       grouped together (see <see cref="P:PostSharp.Aspects.Advices.GroupingAdvice.Master" /> property).
    </para>
        <note>
       Standalone advices or group masters should also be annotated by a custom attribute derived from <see cref="T:PostSharp.Aspects.Advices.Pointcut" />.
    </note>
      </remarks>
      <seealso cref="T:PostSharp.Aspects.OnMethodBoundaryAspect" />
      <seealso cref="T:PostSharp.Aspects.Advices.OnMethodExitAdvice" />
      <seealso cref="T:PostSharp.Aspects.Advices.OnMethodSuccessAdvice" />
      <seealso cref="T:PostSharp.Aspects.Advices.OnMethodExceptionAdvice" />
    </member>
    <member name="T:PostSharp.Aspects.Advices.OnMethodExceptionAdvice">
      <summary>
            Custom attribute that, when applied on a method of an aspect class, specifies
            that this method is an advice having the same semantics as <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnException(PostSharp.Aspects.MethodExecutionArgs)" />.
            </summary>
      <remarks>
        <para>
            The method to which this custom attribute is applied must be public and must have the same signature as
            <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnException(PostSharp.Aspects.MethodExecutionArgs)" />. However, it can be static.
            </para>
        <br />
        <para>
       If an aspect defines many advices (among <see cref="T:PostSharp.Aspects.Advices.OnMethodEntryAdvice" />, <see cref="T:PostSharp.Aspects.Advices.OnMethodExitAdvice" />, <see cref="T:PostSharp.Aspects.Advices.OnMethodSuccessAdvice" />
       and <see cref="T:PostSharp.Aspects.Advices.OnMethodExceptionAdvice" />) that are meant to be applied to the same methods with consistent ordering, these advices should be
       grouped together (see <see cref="P:PostSharp.Aspects.Advices.GroupingAdvice.Master" /> property).
    </para>
        <note>
       Standalone advices or group masters should also be annotated by a custom attribute derived from <see cref="T:PostSharp.Aspects.Advices.Pointcut" />.
    </note>
      </remarks>
      <seealso cref="T:PostSharp.Aspects.OnMethodBoundaryAspect" />
      <seealso cref="T:PostSharp.Aspects.Advices.OnMethodExitAdvice" />
      <seealso cref="T:PostSharp.Aspects.Advices.OnMethodSuccessAdvice" />
      <seealso cref="T:PostSharp.Aspects.Advices.OnMethodEntryAdvice" />
    </member>
    <member name="T:PostSharp.Aspects.Advices.OnMethodExitAdvice">
      <summary>
            Custom attribute that, when applied on a method of an aspect class, specifies
            that this method is an advice having the same semantics as <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnExit(PostSharp.Aspects.MethodExecutionArgs)" />.
            </summary>
      <remarks>
        <para>
            The method to which this custom attribute is applied must be public and must have the same signature as
            <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnExit(PostSharp.Aspects.MethodExecutionArgs)" />. However, it can be static.
            </para>
        <br />
        <para>
       If an aspect defines many advices (among <see cref="T:PostSharp.Aspects.Advices.OnMethodEntryAdvice" />, <see cref="T:PostSharp.Aspects.Advices.OnMethodExitAdvice" />, <see cref="T:PostSharp.Aspects.Advices.OnMethodSuccessAdvice" />
       and <see cref="T:PostSharp.Aspects.Advices.OnMethodExceptionAdvice" />) that are meant to be applied to the same methods with consistent ordering, these advices should be
       grouped together (see <see cref="P:PostSharp.Aspects.Advices.GroupingAdvice.Master" /> property).
    </para>
        <note>
       Standalone advices or group masters should also be annotated by a custom attribute derived from <see cref="T:PostSharp.Aspects.Advices.Pointcut" />.
    </note>
      </remarks>
      <seealso cref="T:PostSharp.Aspects.OnMethodBoundaryAspect" />
      <seealso cref="T:PostSharp.Aspects.Advices.OnMethodExceptionAdvice" />
      <seealso cref="T:PostSharp.Aspects.Advices.OnMethodSuccessAdvice" />
      <seealso cref="T:PostSharp.Aspects.Advices.OnMethodEntryAdvice" />
    </member>
    <member name="T:PostSharp.Aspects.Advices.OnMethodSuccessAdvice">
      <summary>
            Custom attribute that, when applied on a method of an aspect class, specifies
            that this method is an advice having the same semantics as <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnSuccess(PostSharp.Aspects.MethodExecutionArgs)" />.
            </summary>
      <remarks>
        <para>
            The method to which this custom attribute is applied must be public and must have the same signature as
            <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnSuccess(PostSharp.Aspects.MethodExecutionArgs)" />. However, it can be static.
            </para>
        <br />
        <para>
       If an aspect defines many advices (among <see cref="T:PostSharp.Aspects.Advices.OnMethodEntryAdvice" />, <see cref="T:PostSharp.Aspects.Advices.OnMethodExitAdvice" />, <see cref="T:PostSharp.Aspects.Advices.OnMethodSuccessAdvice" />
       and <see cref="T:PostSharp.Aspects.Advices.OnMethodExceptionAdvice" />) that are meant to be applied to the same methods with consistent ordering, these advices should be
       grouped together (see <see cref="P:PostSharp.Aspects.Advices.GroupingAdvice.Master" /> property).
    </para>
        <note>
       Standalone advices or group masters should also be annotated by a custom attribute derived from <see cref="T:PostSharp.Aspects.Advices.Pointcut" />.
    </note>
      </remarks>
      <seealso cref="T:PostSharp.Aspects.OnMethodBoundaryAspect" />
      <seealso cref="T:PostSharp.Aspects.Advices.OnMethodExitAdvice" />
      <seealso cref="T:PostSharp.Aspects.Advices.OnMethodExceptionAdvice" />
      <seealso cref="T:PostSharp.Aspects.Advices.OnMethodEntryAdvice" />
    </member>
    <member name="T:PostSharp.Aspects.Advices.Property`1">
      <summary>
            Mimics the semantics of a parameterless property for use
            with the <see cref="T:PostSharp.Aspects.Advices.ImportMemberAttribute" /> aspect extension.
            </summary>
      <typeparam name="TValue">Property value type.</typeparam>
      <seealso cref="T:PostSharp.Aspects.Advices.Property`2" />
      <seealso cref="T:PostSharp.Aspects.Advices.PropertyGetter`1" />
      <seealso cref="T:PostSharp.Aspects.Advices.PropertySetter`1" />
    </member>
    <member name="M:PostSharp.Aspects.Advices.Property`1.#ctor(PostSharp.Aspects.Advices.PropertyGetter{`0},PostSharp.Aspects.Advices.PropertySetter{`0})">
      <internal />
    </member>
    <member name="P:PostSharp.Aspects.Advices.Property`1.Get">
      <summary>
            Gets a delegate enabling to invoke the <b>get</b> accessor
            of the imported property.
            </summary>
    </member>
    <member name="P:PostSharp.Aspects.Advices.Property`1.Set">
      <summary>
            Gets a delegate enabling to invoke the <b>set</b> accessor
            of the imported property.
            </summary>
    </member>
    <member name="T:PostSharp.Aspects.Advices.PropertyGetter`1">
      <summary>
            Defines the signature of methods implementing the <see cref="P:PostSharp.Aspects.Advices.Property`1.Get" />
            semantic of a parameterless property.
            </summary>
      <typeparam name="TValue">Property value type.</typeparam>
      <returns>The property value.</returns>
      <seealso cref="T:PostSharp.Aspects.Advices.Property`1" />
    </member>
    <member name="T:PostSharp.Aspects.Advices.PropertySetter`1">
      <summary>
            Defines the signature of methods implementing the <see cref="P:PostSharp.Aspects.Advices.Property`1.Set" />
            semantic of a parameterless property.
            </summary>
      <typeparam name="TValue">Property value type.</typeparam>
      <param name="value">The property value.</param>
      <seealso cref="T:PostSharp.Aspects.Advices.Property`1" />
    </member>
    <member name="T:PostSharp.Aspects.Advices.Property`2">
      <summary>
            Mimics the semantics of a property accepting a single index parameter, for use
            with the <see cref="T:PostSharp.Aspects.Advices.ImportMemberAttribute" /> aspect extension.
            </summary>
      <typeparam name="TIndex">Property index type.</typeparam>
      <typeparam name="TValue">Property value type.</typeparam>
      <seealso cref="T:PostSharp.Aspects.Advices.Property`1" />
      <seealso cref="T:PostSharp.Aspects.Advices.PropertyGetter`2" />
      <seealso cref="T:PostSharp.Aspects.Advices.PropertySetter`2" />
    </member>
    <member name="M:PostSharp.Aspects.Advices.Property`2.#ctor(PostSharp.Aspects.Advices.PropertyGetter{`0,`1},PostSharp.Aspects.Advices.PropertySetter{`0,`1})">
      <internal />
    </member>
    <member name="P:PostSharp.Aspects.Advices.Property`2.Get">
      <summary>
            Gets a delegate enabling to invoke the <b>get</b> accessor
            of the imported property.
            </summary>
    </member>
    <member name="P:PostSharp.Aspects.Advices.Property`2.Set">
      <summary>
            Gets a delegate enabling to invoke the <b>set</b> accessor
            of the imported property.
            </summary>
    </member>
    <member name="T:PostSharp.Aspects.Advices.PropertyGetter`2">
      <summary>
            Defines the signature of methods implementing the <see cref="P:PostSharp.Aspects.Advices.Property`2.Get" />
            semantic of a property with a single index parameter.
            </summary>
      <typeparam name="TValue">Property value type.</typeparam>
      <typeparam name="TIndex">Property index type.</typeparam>
      <param name="index">Index.</param>
      <returns>The property value.</returns>
      <seealso cref="T:PostSharp.Aspects.Advices.Property`2" />
    </member>
    <member name="T:PostSharp.Aspects.Advices.PropertySetter`2">
      <summary>
            Defines the signature of methods implementing the <see cref="P:PostSharp.Aspects.Advices.Property`2.Set" />
            semantic of a property with a single index parameter.
            </summary>
      <typeparam name="TValue">Property value type.</typeparam>
      <typeparam name="TIndex">Property index type.</typeparam>
      <param name="index">Index.</param>
      <param name="value">The property value.</param>
      <seealso cref="T:PostSharp.Aspects.Advices.Property`2" />
    </member>
    <member name="T:PostSharp.Aspects.Advices.SelfSelector">
      <summary>
        <see cref="T:PostSharp.Aspects.Advices.Pointcut" /> that selects exactly the aspect target.
            </summary>
    </member>
    <member name="T:PostSharp.Aspects.Arguments">
      <summary>
            Base class encapsulating method arguments. 
            </summary>
      <remarks>
        <para>This concrete class encapsulates an <i>empty</i>
            argument list. Generic overloads of this class can encapsulate argument lists of size included
            between 1 and 8. See <see cref="T:PostSharp.Aspects.ArgumentsArray" /> encapsulate argument lists of any size, but
            are typically used for size of 9 and higher.</para>
      </remarks>
      <see cref="T:PostSharp.Aspects.Arguments`1" />
      <see cref="T:PostSharp.Aspects.Arguments`2" />
      <see cref="T:PostSharp.Aspects.Arguments`3" />
      <see cref="T:PostSharp.Aspects.Arguments`4" />
      <see cref="T:PostSharp.Aspects.Arguments`5" />
      <see cref="T:PostSharp.Aspects.Arguments`6" />
      <see cref="T:PostSharp.Aspects.Arguments`7" />
      <see cref="T:PostSharp.Aspects.Arguments`8" />
      <see cref="T:PostSharp.Aspects.ArgumentsArray" />
    </member>
    <member name="F:PostSharp.Aspects.Arguments.Empty">
      <summary>
            Empty list of <see cref="T:PostSharp.Aspects.Arguments" />.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.Arguments.GetArgument(System.Int32)">
      <summary>
            Gets the value of the argument at a given index.
            </summary>
      <param name="index">Argument index.</param>
      <returns>The value of the argument at position <paramref name="index" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is lower than zero or greater or equal than <see cref="P:PostSharp.Aspects.Arguments.Count" />.</exception>
    </member>
    <member name="M:PostSharp.Aspects.Arguments.SetArgument(System.Int32,System.Object)">
      <summary>
            Sets the value of the argument at a given index.
            </summary>
      <param name="index">Argument index.</param>
      <param name="value">New value of the argument at position <paramref name="index" />.</param>
      <exception cref="T:System.InvalidCastException">
        <paramref name="value" /> is not assignable to parameter
            at position <paramref name="index" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is lower than zero or greater or equal than <see cref="P:PostSharp.Aspects.Arguments.Count" />.</exception>
    </member>
    <member name="M:PostSharp.Aspects.Arguments.CopyFrom(System.Object[],System.Int32)">
      <summary>
            Copies all the argument values from an <see cref="T:System.Array" />.
            </summary>
      <param name="array">The array that is the source of the argument values copied into the current <see cref="T:PostSharp.Aspects.Arguments" />.</param>
      <param name="index">An integer that represents the index in <paramref name="array" /> at which copying begins.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is lower than zero.</exception>
    </member>
    <member name="M:PostSharp.Aspects.Arguments.CopyTo(System.Object[],System.Int32)">
      <summary>
            Copies all arguments values to the specified <see cref="T:System.Array" /> starting at the specified destination <see cref="T:System.Array" /> index.
            </summary>
      <param name="array">The array that is the destination of argument values copied from the current <see cref="T:PostSharp.Aspects.Arguments" />.</param>
      <param name="index">An integer that represents the index in <paramref name="array" /> at which copying begins</param>
    </member>
    <member name="M:PostSharp.Aspects.Arguments.ToArray">
      <summary>
            Converts the current argument list into an <see cref="T:System.Array" />.
            </summary>
      <returns>An <see cref="T:System.Array" /> whose elements are equal to the values encapsulated by the current <see cref="T:PostSharp.Aspects.Arguments" />.</returns>
    </member>
    <member name="M:PostSharp.Aspects.Arguments.Clone">
      <summary>
            Returns a shallow copy of the current object.
            </summary>
      <returns>A shallow copy of the current object.</returns>
    </member>
    <member name="P:PostSharp.Aspects.Arguments.Count">
      <summary>
            Gets the number of arguments encapsulated by the current object.
            </summary>
    </member>
    <member name="P:PostSharp.Aspects.Arguments.Item(System.Int32)">
      <summary>
            Gets or sets the value of an argument.
            </summary>
      <param name="index">Argument index.</param>
      <returns>The argument value.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is lower than zero or greater or equal than <see cref="P:PostSharp.Aspects.Arguments.Count" />.</exception>
    </member>
    <member name="T:PostSharp.Aspects.Arguments`1">
      <summary>
            Implementation of <see cref="T:PostSharp.Aspects.Arguments" /> representing a list of 1 argument.
            </summary>
      <typeparam name="TArg0">Type of the first argument.</typeparam>
    </member>
    <member name="F:PostSharp.Aspects.Arguments`1.Arg0">
      <summary>
            First Argument.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.Arguments`1.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Aspects.Arguments`1" />.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.Arguments`1.GetArgument(System.Int32)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.Arguments`1.SetArgument(System.Int32,System.Object)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.Arguments`1.CopyTo(System.Object[],System.Int32)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.Arguments`1.CopyFrom(System.Object[],System.Int32)">
      <inheritdoc />
    </member>
    <member name="T:PostSharp.Aspects.Arguments`2">
      <summary>
            Implementation of <see cref="T:PostSharp.Aspects.Arguments" /> representing a list of 2 arguments.
            </summary>
      <typeparam name="TArg0">Type of the first argument.</typeparam>
      <typeparam name="TArg1">Type of the second argument.</typeparam>
    </member>
    <member name="F:PostSharp.Aspects.Arguments`2.Arg0">
      <summary>
            First argument.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Arguments`2.Arg1">
      <summary>
            Second argument.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.Arguments`2.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Aspects.Arguments`2" />.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.Arguments`2.GetArgument(System.Int32)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.Arguments`2.SetArgument(System.Int32,System.Object)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.Arguments`2.CopyTo(System.Object[],System.Int32)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.Arguments`2.CopyFrom(System.Object[],System.Int32)">
      <inheritdoc />
    </member>
    <member name="T:PostSharp.Aspects.Arguments`3">
      <summary>
            Implementation of <see cref="T:PostSharp.Aspects.Arguments" /> representing a list of 3 arguments.
            </summary>
      <typeparam name="TArg0">Type of the first argument.</typeparam>
      <typeparam name="TArg1">Type of the second argument.</typeparam>
      <typeparam name="TArg2">Type of the third argument.</typeparam>
    </member>
    <member name="F:PostSharp.Aspects.Arguments`3.Arg0">
      <summary>
            First argument.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Arguments`3.Arg1">
      <summary>
            Second argument.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Arguments`3.Arg2">
      <summary>
            Third argument.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.Arguments`3.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Aspects.Arguments`3" />.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.Arguments`3.GetArgument(System.Int32)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.Arguments`3.SetArgument(System.Int32,System.Object)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.Arguments`3.CopyTo(System.Object[],System.Int32)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.Arguments`3.CopyFrom(System.Object[],System.Int32)">
      <inheritdoc />
    </member>
    <member name="T:PostSharp.Aspects.Arguments`4">
      <summary>
            Implementation of <see cref="T:PostSharp.Aspects.Arguments" /> representing a list of 4 arguments.
            </summary>
      <typeparam name="TArg0">Type of the first argument.</typeparam>
      <typeparam name="TArg1">Type of the second argument.</typeparam>
      <typeparam name="TArg2">Type of the third argument.</typeparam>
      <typeparam name="TArg3">Type of the fourth argument.</typeparam>
    </member>
    <member name="F:PostSharp.Aspects.Arguments`4.Arg0">
      <summary>
            First argument.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Arguments`4.Arg1">
      <summary>
            Second argument.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Arguments`4.Arg2">
      <summary>
            Third argument.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Arguments`4.Arg3">
      <summary>
            Fourth argument.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.Arguments`4.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Aspects.Arguments`4" />.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.Arguments`4.GetArgument(System.Int32)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.Arguments`4.SetArgument(System.Int32,System.Object)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.Arguments`4.CopyTo(System.Object[],System.Int32)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.Arguments`4.CopyFrom(System.Object[],System.Int32)">
      <inheritdoc />
    </member>
    <member name="T:PostSharp.Aspects.Arguments`5">
      <summary>
            Implementation of <see cref="T:PostSharp.Aspects.Arguments" /> representing a list of 5 arguments.
            </summary>
      <typeparam name="TArg0">Type of the first argument.</typeparam>
      <typeparam name="TArg1">Type of the second argument.</typeparam>
      <typeparam name="TArg2">Type of the third argument.</typeparam>
      <typeparam name="TArg3">Type of the fourth argument.</typeparam>
      <typeparam name="TArg4">Type of the fifth argument.</typeparam>
    </member>
    <member name="F:PostSharp.Aspects.Arguments`5.Arg0">
      <summary>
            First argument.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Arguments`5.Arg1">
      <summary>
            Second argument.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Arguments`5.Arg2">
      <summary>
            Third argument.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Arguments`5.Arg3">
      <summary>
            Fourth argument.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Arguments`5.Arg4">
      <summary>
            Fifth argument.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.Arguments`5.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Aspects.Arguments`5" />.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.Arguments`5.GetArgument(System.Int32)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.Arguments`5.SetArgument(System.Int32,System.Object)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.Arguments`5.CopyTo(System.Object[],System.Int32)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.Arguments`5.CopyFrom(System.Object[],System.Int32)">
      <inheritdoc />
    </member>
    <member name="T:PostSharp.Aspects.Arguments`6">
      <summary>
            Implementation of <see cref="T:PostSharp.Aspects.Arguments" /> representing a list of 6 arguments.
            </summary>
      <typeparam name="TArg0">Type of the first argument.</typeparam>
      <typeparam name="TArg1">Type of the second argument.</typeparam>
      <typeparam name="TArg2">Type of the third argument.</typeparam>
      <typeparam name="TArg3">Type of the fourth argument.</typeparam>
      <typeparam name="TArg4">Type of the fifth argument.</typeparam>
      <typeparam name="TArg5">Type of the sixth argument.</typeparam>
    </member>
    <member name="F:PostSharp.Aspects.Arguments`6.Arg0">
      <summary>
            First argument.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Arguments`6.Arg1">
      <summary>
            Second argument.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Arguments`6.Arg2">
      <summary>
            Third argument.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Arguments`6.Arg3">
      <summary>
            Fourth argument.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Arguments`6.Arg4">
      <summary>
            Fifth argument.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Arguments`6.Arg5">
      <summary>
            Sixth argument.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.Arguments`6.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Aspects.Arguments`6" />.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.Arguments`6.GetArgument(System.Int32)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.Arguments`6.SetArgument(System.Int32,System.Object)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.Arguments`6.CopyTo(System.Object[],System.Int32)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.Arguments`6.CopyFrom(System.Object[],System.Int32)">
      <inheritdoc />
    </member>
    <member name="T:PostSharp.Aspects.Arguments`7">
      <summary>
            Implementation of <see cref="T:PostSharp.Aspects.Arguments" /> representing a list of 7 arguments.
            </summary>
      <typeparam name="TArg0">Type of the first argument.</typeparam>
      <typeparam name="TArg1">Type of the second argument.</typeparam>
      <typeparam name="TArg2">Type of the third argument.</typeparam>
      <typeparam name="TArg3">Type of the fourth argument.</typeparam>
      <typeparam name="TArg4">Type of the fifth argument.</typeparam>
      <typeparam name="TArg5">Type of the sixth argument.</typeparam>
      <typeparam name="TArg6">Type of the seventh argument.</typeparam>
    </member>
    <member name="F:PostSharp.Aspects.Arguments`7.Arg0">
      <summary>
            First argument.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Arguments`7.Arg1">
      <summary>
            Second argument.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Arguments`7.Arg2">
      <summary>
            Third argument.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Arguments`7.Arg3">
      <summary>
            Fourth argument.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Arguments`7.Arg4">
      <summary>
            Fifth argument.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Arguments`7.Arg5">
      <summary>
            Sixth argument.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Arguments`7.Arg6">
      <summary>
            Seventh argument.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.Arguments`7.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Aspects.Arguments`7" />.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.Arguments`7.GetArgument(System.Int32)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.Arguments`7.SetArgument(System.Int32,System.Object)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.Arguments`7.CopyTo(System.Object[],System.Int32)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.Arguments`7.CopyFrom(System.Object[],System.Int32)">
      <inheritdoc />
    </member>
    <member name="T:PostSharp.Aspects.Arguments`8">
      <summary>
            Implementation of <see cref="T:PostSharp.Aspects.Arguments" /> representing a list of 8 arguments.
            </summary>
      <typeparam name="TArg0">Type of the first argument.</typeparam>
      <typeparam name="TArg1">Type of the second argument.</typeparam>
      <typeparam name="TArg2">Type of the third argument.</typeparam>
      <typeparam name="TArg3">Type of the fourth argument.</typeparam>
      <typeparam name="TArg4">Type of the fifth argument.</typeparam>
      <typeparam name="TArg5">Type of the sixth argument.</typeparam>
      <typeparam name="TArg6">Type of the seventh argument.</typeparam>
      <typeparam name="TArg7">Type of the eighth argument.</typeparam>
    </member>
    <member name="F:PostSharp.Aspects.Arguments`8.Arg0">
      <summary>
            First argument.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Arguments`8.Arg1">
      <summary>
            Second argument.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Arguments`8.Arg2">
      <summary>
            Third argument.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Arguments`8.Arg3">
      <summary>
            Fourth argument.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Arguments`8.Arg4">
      <summary>
            Fifth argument.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Arguments`8.Arg5">
      <summary>
            Sixth argument.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Arguments`8.Arg6">
      <summary>
            Seventh argument.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Arguments`8.Arg7">
      <summary>
            Eighth argument.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.Arguments`8.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Aspects.Arguments`8" />.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.Arguments`8.GetArgument(System.Int32)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.Arguments`8.SetArgument(System.Int32,System.Object)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.Arguments`8.CopyTo(System.Object[],System.Int32)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.Arguments`8.CopyFrom(System.Object[],System.Int32)">
      <inheritdoc />
    </member>
    <member name="T:PostSharp.Aspects.ArgumentsArray">
      <summary>
            Implementation of <see cref="T:PostSharp.Aspects.Arguments" /> representing a
            list of arguments of arbitrary length and type. 
            </summary>
      <remarks>
            Unless generic implementations of
            <see cref="T:PostSharp.Aspects.Arguments" />, <see cref="T:PostSharp.Aspects.ArgumentsArray" /> boxes all arguments
            into an <see cref="T:System.Array" />, resulting in lower performance and higher memory usage.
            </remarks>
    </member>
    <member name="M:PostSharp.Aspects.ArgumentsArray.#ctor(System.Object[])">
      <summary>
            Initializes a new <see cref="T:PostSharp.Aspects.ArgumentsArray" />.
            </summary>
      <param name="arguments">
        <see cref="T:System.Array" /> containing the argument values.</param>
    </member>
    <member name="M:PostSharp.Aspects.ArgumentsArray.GetArgument(System.Int32)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.ArgumentsArray.SetArgument(System.Int32,System.Object)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.ArgumentsArray.CopyFrom(System.Object[],System.Int32)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.ArgumentsArray.CopyTo(System.Object[],System.Int32)">
      <inheritdoc />
    </member>
    <member name="P:PostSharp.Aspects.ArgumentsArray.Arguments">
      <summary>
            Gets or sets the underlying array of arguments.
            </summary>
      <remarks>When you set this property, the new <see cref="T:System.Array" /> must have the same length as the previous one.</remarks>
    </member>
    <member name="T:PostSharp.Aspects.Aspect">
      <summary>
            Base class for all aspects that are declared using multicast custom attributes (<see cref="T:PostSharp.Extensibility.MulticastAttribute" />).
            </summary>
      <remarks>
        <para>This class is not specific to any kind of declaration (method, field, type, ...). 
             Considering deriving your aspect from <see cref="T:PostSharp.Aspects.TypeLevelAspect" />, <see cref="T:PostSharp.Aspects.MethodLevelAspect" />, <see cref="T:PostSharp.Aspects.LocationLevelAspect" />,
            or <see cref="T:PostSharp.Aspects.EventLevelAspect" /> if it should be applied to a specifc kind of declarations.
            </para>
        <br />
        <note>
      This class does not provide any advice. You may derive your aspect class from a
      <see href="../../UserGuide/Aspects/AspectKinds/Overview.html">
        class providing
        predefined advice
      </see>
      , or build a
      <see href="../../UserGuide/Aspects/CompositeAspects/Overview.html">composite aspect</see>
      .
    </note>
        <seealso href="../../UserGuide/Aspects/AspectKinds/Overview.html">Aspect Kinds</seealso>
        <seealso href="../../UserGuide/Aspects/CompositeAspects/Overview.html">Composite Aspects</seealso>
        <br />
        <note>
      All classes implementing
      <see cref="T:PostSharp.Aspects.IAspect" />
      should typically be marked as serializable
      using the
      <see cref="T:System.SerializableAttribute" />
      custom attribute. Fields that
      are only used at runtime (and unknown at compile-time) should be carefully
      marked with the
      <see cref="T:System.NonSerializedAttribute" />
      custom attribute.
      When PostSharp is used on a platform that does not support aspect serialization
      (such as .NET Compact Framework, Silverlight, or Windows Phone), or when
      another aspect serializer is used, it is not necessary to mark the aspect
      class as serializable.
      For more information, see
      <see href="../../UserGuide/Aspects/Advanced/Serialization.html">Aspect Serialization</see>
      .
    </note>
        <seealso href="../../UserGuide/Aspects/Advanced/Serialization.html">Aspect Serialization</seealso>
      </remarks>
    </member>
    <member name="T:PostSharp.Extensibility.MulticastAttribute">
      <summary>
            Custom attribute that can be applied to multiple elements
            using wildcards.
            </summary>
      <remarks>
        <para>Each class derived from <see cref="T:PostSharp.Extensibility.MulticastAttribute" />
            should be decorated with an instance of <see cref="T:PostSharp.Extensibility.MulticastAttributeUsageAttribute" />.
            </para>
        <para>
            Multicasting is performed by the <b>MulticastAttributeTask</b>, which should be
            included in the project. After multicasting, custom attribute instances are
            available on the <b>CustomAttributeDictionaryTask</b> class.
            </para>
      </remarks>
    </member>
    <member name="P:PostSharp.Extensibility.MulticastAttribute.AttributeTargetElements">
      <summary>
            Gets or sets the kind of elements to which this custom attributes applies.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.MulticastAttribute.AttributeTargetAssemblies">
      <summary>
            Gets or sets the assemblies to which the current attribute apply.
            </summary>
      <value>
            Wildcard or regular expression specifying to which assemblies
            this instance applies, or <c>null</c> if this instance applies
            only to elements of the current assembly. Wildcard expressions should
            start with the <code>regex:</code> prefix.
            </value>
      <remarks>
            When this property is not specified or is <c>null</c>, the current
            attribute is multicasted only in the current assembly. Otherwise, it
            is multicasted also to external assemblies, i.e. to declarations that
            are <i>referenced</i> by the current assembly.
            </remarks>
    </member>
    <member name="P:PostSharp.Extensibility.MulticastAttribute.AttributeTargetTypes">
      <summary>
            Gets or sets the expression specifying to which types
            this instance applies.
            </summary>
      <value>
            A wildcard or regular expression specifying to which types
            this instance applies, or <c>null</c> this instance
            applies either to all types. Regular expressions should
            start with the <code>regex:</code> prefix.
            </value>
      <remarks>
            Ignored if the <see cref="P:PostSharp.Extensibility.MulticastAttribute.AttributeTargetElements" /> are only the module and/or the assembly.
            </remarks>
    </member>
    <member name="P:PostSharp.Extensibility.MulticastAttribute.AttributeTargetTypeAttributes">
      <summary>
            Gets or sets the visibilities of types to which this attribute applies.
            </summary>
      <remarks>
            On type-level, the only meaningfull enumeration values are related to visibility.
            </remarks>
    </member>
    <member name="P:PostSharp.Extensibility.MulticastAttribute.AttributeTargetMembers">
      <summary>
            Gets or sets the expression specifying to which members 
            this instance applies.
            </summary>
      <value>
            A wildcard or regular expression specifying to which members
            this instance applies, or <c>null</c> this instance
            applies either to all members whose kind is given in <see cref="P:PostSharp.Extensibility.MulticastAttribute.AttributeTargetElements" />.
            Regular expressions should start with the <code>regex:</code> prefix.
            </value>
      <remarks>
        <para>Ignored if the only <see cref="P:PostSharp.Extensibility.MulticastAttribute.AttributeTargetElements" /> are only types.
            </para>
      </remarks>
    </member>
    <member name="P:PostSharp.Extensibility.MulticastAttribute.AttributeTargetMemberAttributes">
      <summary>
            Gets or sets the visibilities, scopes, virtualities, and implementation
             of members to which this attribute applies.
            </summary>
      <remarks>
        <para>Ignored if the <see cref="P:PostSharp.Extensibility.MulticastAttribute.AttributeTargetElements" /> are only the module, the assembly,
            and/or types.
            </para>
        <para>
            The <see cref="T:PostSharp.Extensibility.MulticastAttributes" /> enumeration is a multi-part flag: there is one
            part for visibility, one for scope, one for virtuality, and one for implementation.
            If you specify one part, it will override the values defined on the custom attribute definition.
            If you do not specify it, the values defined on the custom attribute definition will be inherited.
            Note that custom attributes may apply restrictions on these attributes. For instance, 
            a custom attribute may not be valid on abstract methods. You are obviously not allowed
            to 'enlarge' the set of possible targets.
            </para>
      </remarks>
    </member>
    <member name="P:PostSharp.Extensibility.MulticastAttribute.AttributeTargetParameters">
      <summary>
            Gets or sets the expression specifying to which parameters 
            this instance applies.
            </summary>
      <value>
            A wildcard or regular expression specifying to which parameters
            this instance applies, or <c>null</c> this instance
            applies either to all members whose kind is given in <see cref="P:PostSharp.Extensibility.MulticastAttribute.AttributeTargetElements" />.
            Wildcard expressions should
            start with the <code>regex:</code> prefix.
            </value>
      <remarks>
        <para>Ignored if the only <see cref="P:PostSharp.Extensibility.MulticastAttribute.AttributeTargetElements" /> are only types.
            </para>
      </remarks>
    </member>
    <member name="P:PostSharp.Extensibility.MulticastAttribute.AttributeTargetParameterAttributes">
      <summary>
            Gets or sets the passing style (by value, <b>out</b> or <b>ref</b>)
             of parameters to which this attribute applies.
            </summary>
      <remarks>
        <para>Ignored if the <see cref="P:PostSharp.Extensibility.MulticastAttribute.AttributeTargetElements" /> do not include parameters.
            </para>
      </remarks>
    </member>
    <member name="P:PostSharp.Extensibility.MulticastAttribute.AttributeExclude">
      <summary>
            If true, indicates that this attribute <i>removes</i> all other instances of the
            same attribute type from the set of elements defined by the current instance.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.MulticastAttribute.AttributePriority">
      <summary>
            Gets or sets the priority of the current attribute in case that multiple 
            instances are defined on the same element (lower values are processed before).
            </summary>
      <remarks>
            You should use only 16-bit values in user code. Top 16 bits are reserved for the system.
            </remarks>
    </member>
    <member name="P:PostSharp.Extensibility.MulticastAttribute.AttributeReplace">
      <summary>
            Determines whether this attribute replaces other attributes found on the
            target declarations.
            </summary>
      <value>
        <c>true</c> if the current instance will replace previous ones, or <c>false</c>
            if it will be added to previous instances.
            </value>
    </member>
    <member name="P:PostSharp.Extensibility.MulticastAttribute.AttributeInheritance">
      <summary>
            Determines whether this attribute is inherited
            </summary>
      <remarks>
        <para>If this property is <c>true</c>, a copy of this attribute will be propagated along
            the lines of inheritance of the target element:</para>
        <list type="bullet">
          <item>On <b>classes</b>: all classed derived from that class.</item>
          <item>On <b>interfaces</b>: all classes implementing this interface.</item>
          <item>On <b>virtual, abstract or interface methods</b>: all methods overriding 
            or implementing this method.</item>
          <item>On <b>parameters</b> or <b>return value</b> of virtual, abstract or interface methods:
            corresponding parameter or return value on all methods or overriding or implementing the
            parent method of the target parameter or return value.</item>
        </list>
      </remarks>
    </member>
    <member name="P:PostSharp.Extensibility.MulticastAttribute.AttributeId">
      <summary>
        <b>Internal Only.</b> Identifier of the current instance of the custom attribute.
            </summary>
      <remarks>
            This property is used internally by PostSharp to uniquely identify instances of custom
            attributes and avoid adding duplicates. Do not use this property in customer code.
            </remarks>
    </member>
    <member name="T:PostSharp.Aspects.IAspect">
      <summary>
            Base interface for run-time semantics of all aspects.
            </summary>
      <seealso cref="T:PostSharp.Aspects.IAspectBuildSemantics" />
      <seealso cref="T:PostSharp.Aspects.AspectConfiguration" />
      <seealso cref="T:PostSharp.Aspects.Aspect" />
    </member>
    <member name="T:PostSharp.Aspects.IAspectBuildSemantics">
      <summary>
            Compile-time semantics of <see cref="T:PostSharp.Aspects.IAspect" />.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.IValidableAnnotation">
      <summary>
            Interface that, when implemented by a custom attribute (<see cref="T:System.Attribute" />),
            causes <c>PostSharp</c> to invoke a validation method for every instance
            of that custom attribute.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.IValidableAnnotation.CompileTimeValidate(System.Object)">
      <summary>
            Method invoked at build time to ensure that the aspect has been applied to
            the right target.
            </summary>
      <param name="target">Target element.</param>
      <returns>
        <c>true</c> if the aspect was applied to an acceptable target, otherwise
            <c>false</c>.</returns>
      <remarks>
            The implementation of this method is expected to emit an error message
            or an exception of type <see cref="T:PostSharp.Extensibility.InvalidAnnotationException" /> in case of error. Only returning <c>false</c> causes the aspect
            to be silently ignored.</remarks>
    </member>
    <member name="M:PostSharp.Aspects.IAspectBuildSemantics.GetAspectConfiguration(System.Object)">
      <summary>
            Method invoked at build tome to get the imperative configuration of the current <see cref="T:PostSharp.Aspects.Aspect" />.
            </summary>
      <param name="targetElement">Code element (<see cref="T:System.Runtime.InteropServices._Assembly" />, <see cref="T:System.Type" />, 
            <see cref="T:System.Reflection.FieldInfo" />, <see cref="T:System.Reflection.MethodBase" />, <see cref="T:System.Reflection.PropertyInfo" />, <see cref="T:System.Reflection.EventInfo" />, 
            <see cref="T:System.Reflection.ParameterInfo" />, or <see cref="T:PostSharp.Reflection.LocationInfo" />) to which the current aspect has been applied.
            </param>
      <returns>An <see cref="T:PostSharp.Aspects.AspectConfiguration" /> representing the imperative configuration
            of the current <see cref="T:PostSharp.Aspects.Aspect" />.</returns>
    </member>
    <member name="M:PostSharp.Aspects.Aspect.CreateAspectConfiguration">
      <summary>
            Method invoked at build time to create a concrete <see cref="T:PostSharp.Aspects.AspectConfiguration" /> instance specifically
            for the current <see cref="T:PostSharp.Aspects.Aspect" /> type.
            </summary>
      <returns>A new and empty instance of <see cref="T:PostSharp.Aspects.AspectConfiguration" />, whose concrete type corresponds to
            the concrete type of the <see cref="T:PostSharp.Aspects.Aspect" />.</returns>
      <remarks>
            This method should not set up the returned <see cref="T:PostSharp.Aspects.AspectConfiguration" />. After the current method has
            returned, the <see cref="M:PostSharp.Aspects.Aspect.SetAspectConfiguration(PostSharp.Aspects.AspectConfiguration,System.Object)" /> method will be invoked, and this method is responsible
            for setting up the <see cref="T:PostSharp.Aspects.AspectConfiguration" />object.
            </remarks>
    </member>
    <member name="M:PostSharp.Aspects.Aspect.SetAspectConfiguration(PostSharp.Aspects.AspectConfiguration,System.Object)">
      <summary>
            Method invoked at build time to set up an <see cref="T:PostSharp.Aspects.AspectConfiguration" /> object according to the current 
            <see cref="T:PostSharp.Aspects.Aspect" /> instance and a specified target element of the current aspect.
            </summary>
      <param name="aspectConfiguration">The <see cref="T:PostSharp.Aspects.AspectConfiguration" /> instance previously returned  by the
            <see cref="M:PostSharp.Aspects.Aspect.CreateAspectConfiguration" /> method.</param>
      <param name="targetElement">Code element (<see cref="T:System.Runtime.InteropServices._Assembly" />, <see cref="T:System.Type" />, 
            <see cref="T:System.Reflection.FieldInfo" />, <see cref="T:System.Reflection.MethodBase" />, <see cref="T:System.Reflection.PropertyInfo" />, <see cref="T:System.Reflection.EventInfo" />, 
            <see cref="T:System.Reflection.ParameterInfo" />, or <see cref="T:PostSharp.Reflection.LocationInfo" />) to which the current <see cref="T:PostSharp.Aspects.Aspect" />
            has been applied.
            </param>
      <remarks>
        <para>Classes overriding this method must always invoke the base implementation before performing their own
            changes to the 
            <see cref="T:PostSharp.Aspects.AspectConfiguration" />.</para>
      </remarks>
    </member>
    <member name="M:PostSharp.Aspects.Aspect.GetAspectConfiguration(System.Object)">
      <summary>
            Method invoked at build tome to get the imperative configuration of the current <see cref="T:PostSharp.Aspects.Aspect" />.
            </summary>
      <param name="targetElement">Code element (<see cref="T:System.Runtime.InteropServices._Assembly" />, <see cref="T:System.Type" />, 
            <see cref="T:System.Reflection.FieldInfo" />, <see cref="T:System.Reflection.MethodBase" />, <see cref="T:System.Reflection.PropertyInfo" />, <see cref="T:System.Reflection.EventInfo" />, 
            <see cref="T:System.Reflection.ParameterInfo" />, or <see cref="T:PostSharp.Reflection.LocationInfo" />) to which the current <see cref="T:PostSharp.Aspects.Aspect" />
            has been applied.
            </param>
      <returns>An <see cref="T:PostSharp.Aspects.AspectConfiguration" /> representing the imperative configuration
            of the current <see cref="T:PostSharp.Aspects.Aspect" />.</returns>
      <remarks>
        <para>This method can be customized by overriding <see cref="M:PostSharp.Aspects.Aspect.CreateAspectConfiguration" /> and/or
            <see cref="M:PostSharp.Aspects.Aspect.SetAspectConfiguration(PostSharp.Aspects.AspectConfiguration,System.Object)" /></para>.
            </remarks>
    </member>
    <member name="M:PostSharp.Aspects.Aspect.CompileTimeValidate(System.Object)">
      <summary>
            Method invoked at build time to ensure that the aspect has been applied to the right target.
            </summary>
      <param name="target">Code element (<see cref="T:System.Runtime.InteropServices._Assembly" />, <see cref="T:System.Type" />, 
            <see cref="T:System.Reflection.FieldInfo" />, <see cref="T:System.Reflection.MethodBase" />, <see cref="T:System.Reflection.PropertyInfo" />, <see cref="T:System.Reflection.EventInfo" />, 
            <see cref="T:System.Reflection.ParameterInfo" />, or <see cref="T:PostSharp.Reflection.LocationInfo" />) to which the aspect has been applied.</param>
      <returns>
        <c>true</c> if the aspect was applied to an acceptable target, otherwise
            <c>false</c>.</returns>
      <remarks>The implementation of this method is expected to emit an error message (see 
            <see cref="T:PostSharp.Extensibility.MessageSource" />) or an exception in case of error. Returning <c>false</c> without emitting an
            error message or exception causes the aspect to be silently ignored.</remarks>
    </member>
    <member name="P:PostSharp.Aspects.Aspect.AspectPriority">
      <summary>
            Gets or sets the weaving priority of the aspect.
            </summary>
      <value>The aspect priority, or <c>null</c> if the aspect priority is
            not specified.</value>
      <remarks>
        <para>Advices with lower priority are executed before in case of
            'entry' semantics (entering or invoking a method, setting a field
            value), but this order is inverted for advices of 'exit' semantics
            (leaving a method, getting a field value).
            </para>
        <para>This property must not be confused with 
            <see cref="P:PostSharp.Extensibility.MulticastAttribute.AttributePriority" />, which solely
            influences the multicasting process.</para>
      </remarks>
    </member>
    <member name="P:PostSharp.Aspects.Aspect.SerializerType">
      <summary>
            Gets or sets the <see cref="T:System.Type" /> of the serializer (a type derived
            from <see cref="T:PostSharp.Aspects.Serialization.AspectSerializer" />) used to serialize the aspect instance
            at build time and deserialize it at runtime.
            </summary>
    </member>
    <member name="T:PostSharp.Aspects.AspectConfigurationAttribute">
      <summary>
            Configures an aspect of type <see cref="T:PostSharp.Aspects.IAspect" />.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.AspectConfigurationAttribute.CreateAspectConfiguration">
      <summary>
            Creates a concrete <see cref="T:PostSharp.Aspects.AspectConfiguration" /> instance specifically for the current 
            <see cref="T:PostSharp.Aspects.AspectConfigurationAttribute" /> type.
            </summary>
      <returns>A new and empty instance of <see cref="T:PostSharp.Aspects.AspectConfiguration" />, whose concrete type corresponds to
            the concrete type of the <see cref="T:PostSharp.Aspects.AspectConfigurationAttribute" />.</returns>
      <remarks>
            This method should not set up the returned <see cref="T:PostSharp.Aspects.AspectConfiguration" />. After the current method has
            returned, the <see cref="M:PostSharp.Aspects.AspectConfigurationAttribute.SetAspectConfiguration(PostSharp.Aspects.AspectConfiguration)" /> method will be invoked, and this method is responsible
            for setting up the <see cref="T:PostSharp.Aspects.AspectConfiguration" />object.
            </remarks>
    </member>
    <member name="M:PostSharp.Aspects.AspectConfigurationAttribute.GetAspectConfiguration">
      <summary>
            Gets the <see cref="T:PostSharp.Aspects.AspectConfiguration" /> corresponding to the current custom attribute.
            </summary>
      <returns>An <see cref="T:PostSharp.Aspects.AspectConfiguration" /> corresponding to the current custom attribute.</returns>
      <remarks>
        <para>This method can be customized by overriding <see cref="M:PostSharp.Aspects.AspectConfigurationAttribute.CreateAspectConfiguration" /> and/or
            <see cref="M:PostSharp.Aspects.AspectConfigurationAttribute.SetAspectConfiguration(PostSharp.Aspects.AspectConfiguration)" /></para>.
            </remarks>
    </member>
    <member name="M:PostSharp.Aspects.AspectConfigurationAttribute.SetAspectConfiguration(PostSharp.Aspects.AspectConfiguration)">
      <summary>
            Sets up an <see cref="T:PostSharp.Aspects.AspectConfiguration" /> object according to the current  custom attribute instance.
            </summary>
      <param name="aspectConfiguration">The <see cref="T:PostSharp.Aspects.AspectConfiguration" /> instance previously returned  by the
            <see cref="M:PostSharp.Aspects.AspectConfigurationAttribute.CreateAspectConfiguration" /> method.</param>
      <remarks>
        <para>Classes overriding this method must always invoke the base implementation before performing their own
            changes to the <see cref="T:PostSharp.Aspects.AspectConfiguration" />.</para>
      </remarks>
    </member>
    <member name="P:PostSharp.Aspects.AspectConfigurationAttribute.AspectPriority">
      <summary>
            Gets or sets the weaving priority of the aspect.
            </summary>
      <value>The aspect priority, or <c>null</c> if the aspect priority is not specified.</value>
      <remarks>
        <para>Advices with lower priority are executed before in case of 'entry' semantics (entering or invoking a
            method, setting a field value), but this order is inverted for advices of 'exit' semantics (leaving a
            method, getting a field value).
            </para>
        <para>This property must not be confused with <see cref="P:PostSharp.Extensibility.MulticastAttribute.AttributePriority" />, which
            solely influences the multicasting process.</para>
      </remarks>
    </member>
    <member name="P:PostSharp.Aspects.AspectConfigurationAttribute.SerializerType">
      <summary>
            Gets or sets the <see cref="T:System.Type" /> of the serializer that will be used
            to configure the current aspect. 
            </summary>
      <remarks>
        <para>This type should have derive from <see cref="T:PostSharp.Aspects.Serialization.AspectSerializer" />
            and have a default constructor. Use <c>null</c> to specify that the aspect will not
            be serialized, but will be constructed using MSIL instructions.
            </para>
        <para />
      </remarks>
    </member>
    <member name="T:PostSharp.Aspects.AspectArgs">
      <summary>
            Base class for arguments of all advices.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.AspectArgs.#ctor(System.Object)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Aspects.AspectArgs" />.
            </summary>
      <param name="instance">The instance related to the advice invocation, or
            <c>null</c> if the advice is associated to a static element of code.</param>
    </member>
    <member name="P:PostSharp.Aspects.AspectArgs.Instance">
      <summary>
            Gets or sets the object instance on which the method is being executed.
            </summary>
      <remarks>
            This set may be set by user code only when the instance is a value type.
            As usually, user code is responsible for setting an object of the
            right type.
            </remarks>
    </member>
    <member name="P:PostSharp.Aspects.AspectArgs.InstanceCredentials">
      <summary>
            Gets the credentials of the current instance.
            </summary>
      <remarks>
            Credentials allow to use protected interfaces like <see cref="T:PostSharp.Aspects.IComposed`1" />.
            </remarks>
    </member>
    <member name="T:PostSharp.Aspects.AspectInfo">
      <summary>
            Reserved for future usage.
            </summary>
    </member>
    <member name="T:PostSharp.Aspects.AspectInstance">
      <summary>
            Completely specifies an aspect instance, including its target code element. An <see cref="T:PostSharp.Aspects.AspectInstance" />
            contains either the aspect instance itself (<see cref="T:PostSharp.Aspects.Aspect" /> property), either information allowing to construct the aspect 
            (<see cref="P:PostSharp.Aspects.AspectSpecification.AspectConstruction" />) and configure the weaver (<see cref="T:PostSharp.Aspects.AspectConfiguration" />).
            </summary>
    </member>
    <member name="T:PostSharp.Aspects.AspectSpecification">
      <summary>
            Completely specifies an aspect instance (but not its target). An <see cref="T:PostSharp.Aspects.AspectSpecification" /> either the aspect instance itself 
            (<see cref="P:PostSharp.Aspects.AspectSpecification.Aspect" /> property), either information allowing to construct the aspect (<see cref="P:PostSharp.Aspects.AspectSpecification.AspectConstruction" />) and configure the weaver (<see cref="P:PostSharp.Aspects.AspectSpecification.AspectConfiguration" />).
            </summary>
      <remarks>
            User code cannot create an instance of the <see cref="T:PostSharp.Aspects.AspectSpecification" /> class. Always create an instance of
            <see cref="T:PostSharp.Aspects.AspectInstance" /> instead.
            </remarks>
    </member>
    <member name="P:PostSharp.Aspects.AspectSpecification.AspectConfiguration">
      <summary>
            Gets the aspect configuration.
            </summary>
      <value>
            The aspect configuration, or <c>null</c> if none was provided.
            </value>
    </member>
    <member name="P:PostSharp.Aspects.AspectSpecification.AspectConstruction">
      <summary>
            Gets the aspect construction.
            </summary>
      <value>
            The aspect construction, or <c>null</c> if the aspect instance was provided instead.
            </value>
    </member>
    <member name="P:PostSharp.Aspects.AspectSpecification.Aspect">
      <summary>
            Gets the aspect instance.
            </summary>
      <value>
            The aspect instance, or <c>null</c> if the <see cref="P:PostSharp.Aspects.AspectSpecification.AspectConfiguration" /> was provided instead.
            </value>
    </member>
    <member name="P:PostSharp.Aspects.AspectSpecification.AspectAssemblyQualifiedTypeName">
      <summary>
            Gets the assembly-qualified type name of the aspect.
            </summary>
    </member>
    <member name="P:PostSharp.Aspects.AspectSpecification.AspectTypeName">
      <summary>
            Gets the type name of the aspect.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.AspectInstance.#ctor(System.Object,PostSharp.Aspects.IAspect)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Aspects.AspectInstance" /> from a runtime aspect instance (<see cref="T:PostSharp.Aspects.IAspect" />).
            </summary>
      <param name="targetElement">Code element (<see cref="T:System.Runtime.InteropServices._Assembly" />, <see cref="T:System.Type" />, 
            <see cref="T:System.Reflection.FieldInfo" />, <see cref="T:System.Reflection.MethodBase" />, <see cref="T:System.Reflection.PropertyInfo" />, <see cref="T:System.Reflection.EventInfo" />, 
            <see cref="T:System.Reflection.ParameterInfo" />, or <see cref="T:PostSharp.Reflection.LocationInfo" />) to which the current <see cref="T:PostSharp.Aspects.AspectInstance" />
            is applied.</param>
      <param name="aspect">The aspect runtime instance.</param>
    </member>
    <member name="M:PostSharp.Aspects.AspectInstance.#ctor(System.Object,PostSharp.Aspects.IAspect,PostSharp.Aspects.AspectConfiguration)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Aspects.AspectInstance" /> from a runtime aspect instance (<see cref="T:PostSharp.Aspects.IAspect" />)
            and its <see cref="T:PostSharp.Aspects.AspectConfiguration" />.
            </summary>
      <param name="targetElement">Code element (<see cref="T:System.Runtime.InteropServices._Assembly" />, <see cref="T:System.Type" />, 
            <see cref="T:System.Reflection.FieldInfo" />, <see cref="T:System.Reflection.MethodBase" />, <see cref="T:System.Reflection.PropertyInfo" />, <see cref="T:System.Reflection.EventInfo" />, 
            <see cref="T:System.Reflection.ParameterInfo" />, or <see cref="T:PostSharp.Reflection.LocationInfo" />) to which the current <see cref="T:PostSharp.Aspects.AspectInstance" />
            is applied.</param>
      <param name="aspect">The aspect runtime instance.</param>
      <param name="aspectConfiguration">The aspect configuration (the type of this parameter should be equal to the
            type configuration objects expected by the concrete <paramref name="aspect" />).</param>
    </member>
    <member name="M:PostSharp.Aspects.AspectInstance.#ctor(System.Object,PostSharp.Reflection.ObjectConstruction,PostSharp.Aspects.AspectConfiguration)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Aspects.AspectInstance" /> from
            </summary>
      <param name="targetElement" />
      <param name="aspectConstruction" />
      <param name="aspectConfiguration" />
    </member>
    <member name="P:PostSharp.Aspects.AspectInstance.TargetElement">
      <summary>
            Gets the code element (<see cref="T:System.Runtime.InteropServices._Assembly" />, <see cref="T:System.Type" />, 
            <see cref="T:System.Reflection.FieldInfo" />, <see cref="T:System.Reflection.MethodBase" />, <see cref="T:System.Reflection.PropertyInfo" />, <see cref="T:System.Reflection.EventInfo" />, 
            <see cref="T:System.Reflection.ParameterInfo" />, or <see cref="T:PostSharp.Reflection.LocationInfo" />) to which the current <see cref="T:PostSharp.Aspects.AspectInstance" />
            is applied.
            </summary>
    </member>
    <member name="T:PostSharp.Aspects.AspectUtilities">
      <summary>
            Utility methods for <c>PostSharp.Aspects</c>.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.AspectUtilities.GetCurrentInstanceCredentials">
      <summary>
            Gets the <see cref="T:PostSharp.Aspects.InstanceCredentials" /> of the calling instance. This method must be
            invoked from an instance method (not a static method) of a type that has been enhanced
            by an aspect.
            </summary>
      <returns>The <see cref="T:PostSharp.Aspects.InstanceCredentials" /> of the calling instance.</returns>
      <remarks>
            Calls to this method are transformed, at build time, to calls to
            <b>this.GetInstanceCredentials</b>, a method that is typically generated by <c>PostSharp</c>. 
            This is why the current method has actually no
            implementation.
            </remarks>
    </member>
    <member name="M:PostSharp.Aspects.AspectUtilities.InitializeCurrentAspects">
      <summary>
            Initializes the all the aspects of the calling instance. This method must be
            invoked from an instance method (not a static method) of a type that has been enhanced
            by an aspect.
            </summary>
      <remarks>
        <para>
            Calls to this method are transformed, at build time, to calls to
            <b>this.InitializeAspects</b>, a method that is typically generated by <c>PostSharp</c>. 
            This is why the current method has actually no implementation.
            </para>
        <para>
            The constructors of enhanced classes always initialize aspects. The only scenario
            where this method needs to be invoked manually is when instances are not built
            using the constructor, but for instance with the method <see cref="M:System.Runtime.Serialization.FormatterServices.GetUninitializedObject(System.Type)" />.
            </para>
      </remarks>
    </member>
    <member name="T:PostSharp.Aspects.AssemblyLevelAspect">
      <summary>
            Base class for all aspects applied on assemblies.
            </summary>
      <seealso cref="T:PostSharp.Aspects.IAssemblyLevelAspect" />
      <remarks>
        <note>
      This class does not provide any advice. You may derive your aspect class from a
      <see href="../../UserGuide/Aspects/AspectKinds/Overview.html">
        class providing
        predefined advice
      </see>
      , or build a
      <see href="../../UserGuide/Aspects/CompositeAspects/Overview.html">composite aspect</see>
      .
    </note>
        <seealso href="../../UserGuide/Aspects/AspectKinds/Overview.html">Aspect Kinds</seealso>
        <seealso href="../../UserGuide/Aspects/CompositeAspects/Overview.html">Composite Aspects</seealso>
        <br />
        <note>
      All classes implementing
      <see cref="T:PostSharp.Aspects.IAspect" />
      should typically be marked as serializable
      using the
      <see cref="T:System.SerializableAttribute" />
      custom attribute. Fields that
      are only used at runtime (and unknown at compile-time) should be carefully
      marked with the
      <see cref="T:System.NonSerializedAttribute" />
      custom attribute.
      When PostSharp is used on a platform that does not support aspect serialization
      (such as .NET Compact Framework, Silverlight, or Windows Phone), or when
      another aspect serializer is used, it is not necessary to mark the aspect
      class as serializable.
      For more information, see
      <see href="../../UserGuide/Aspects/Advanced/Serialization.html">Aspect Serialization</see>
      .
    </note>
        <seealso href="../../UserGuide/Aspects/Advanced/Serialization.html">Aspect Serialization</seealso>
      </remarks>
    </member>
    <member name="T:PostSharp.Aspects.IAssemblyLevelAspect">
      <summary>
            Runtime semantics of aspects applied at assembly level.
            </summary>
      <remarks>
            An assembly-level aspect has no equivalent to <b>RuntimeInitialize</b> since assemblies are never initialized.
            </remarks>
      <seealso cref="T:PostSharp.Aspects.IAssemblyLevelAspectBuildSemantics" />
      <seealso cref="T:PostSharp.Aspects.AssemblyLevelAspect" />
    </member>
    <member name="T:PostSharp.Aspects.IAssemblyLevelAspectBuildSemantics">
      <summary>
            Build-time semantics of aspects applied at assembly level.
            </summary>
      <seealso cref="T:PostSharp.Aspects.AssemblyLevelAspect" />
    </member>
    <member name="M:PostSharp.Aspects.IAssemblyLevelAspectBuildSemantics.CompileTimeInitialize(System.Runtime.InteropServices._Assembly)">
      <summary>
            Method invoked at build time to initialize the instance fields of the current aspect. This method is invoked
            before any other build-time method.
            </summary>
      <param name="assembly">Assembly to which the current aspect is applied</param>
    </member>
    <member name="M:PostSharp.Aspects.AssemblyLevelAspect.CompileTimeValidate(System.Runtime.InteropServices._Assembly)">
      <summary>
            Method invoked at build time to ensure that the aspect has been applied to the right target.
            </summary>
      <param name="assembly">Assembly on which the current aspect is applied.</param>
      <returns>
        <c>true</c> if the aspect was applied to an acceptable target, otherwise
            <c>false</c>.</returns>
      <remarks>The implementation of this method is expected to emit an error message (see 
            <see cref="T:PostSharp.Extensibility.MessageSource" />) or an exception in case of error. Returning <c>false</c> without emitting an
            error message or exception causes the aspect to be silently ignored.</remarks>
    </member>
    <member name="M:PostSharp.Aspects.AssemblyLevelAspect.CompileTimeValidate(System.Object)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.AssemblyLevelAspect.CompileTimeInitialize(System.Runtime.InteropServices._Assembly)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.AssemblyLevelAspect.SetAspectConfiguration(PostSharp.Aspects.AspectConfiguration,System.Runtime.InteropServices._Assembly)">
      <summary>
            Method invoked at build time to set up an <see cref="T:PostSharp.Aspects.AspectConfiguration" /> object according to the current 
            <see cref="T:PostSharp.Aspects.Aspect" /> instance and a specified target element of the current aspect.
            </summary>
      <param name="aspectConfiguration">The <see cref="T:PostSharp.Aspects.AspectConfiguration" /> instance previously returned  by the
            <see cref="M:PostSharp.Aspects.Aspect.CreateAspectConfiguration" /> method.</param>
      <param name="targetAssembly">Assembly to which the current aspect has been applied.</param>
      <remarks>
        <para>Classes overriding this method must always invoke the base implementation before performing their own
            changes to the 
            <see cref="T:PostSharp.Aspects.AspectConfiguration" />.</para>
      </remarks>
    </member>
    <member name="M:PostSharp.Aspects.AssemblyLevelAspect.SetAspectConfiguration(PostSharp.Aspects.AspectConfiguration,System.Object)">
      <inheritdoc />
    </member>
    <member name="T:PostSharp.Aspects.CompositionAspect">
      <summary>
            Aspect that, when applied on a type, introduce one or many new interfaces
            into that type, and let these interfaces be implemented by an object created
            at runtime.
            </summary>
      <remarks>
        <para>
            Use the <see cref="T:PostSharp.Post" />.<see cref="M:PostSharp.Post.Cast``2(``0)" />
            method to cast the enhanced type to the newly implemented interface. This
            cast is verified during post-compilation.
            </para>
        <br />
        <note>
      All classes implementing
      <see cref="T:PostSharp.Aspects.IAspect" />
      should typically be marked as serializable
      using the
      <see cref="T:System.SerializableAttribute" />
      custom attribute. Fields that
      are only used at runtime (and unknown at compile-time) should be carefully
      marked with the
      <see cref="T:System.NonSerializedAttribute" />
      custom attribute.
      When PostSharp is used on a platform that does not support aspect serialization
      (such as .NET Compact Framework, Silverlight, or Windows Phone), or when
      another aspect serializer is used, it is not necessary to mark the aspect
      class as serializable.
      For more information, see
      <see href="../../UserGuide/Aspects/Advanced/Serialization.html">Aspect Serialization</see>
      .
    </note>
        <seealso href="../../UserGuide/Aspects/Advanced/Serialization.html">Aspect Serialization</seealso>
      </remarks>
    </member>
    <member name="T:PostSharp.Aspects.TypeLevelAspect">
      <summary>
            Base class for all aspects applied on types.
            </summary>
      <seealso cref="T:PostSharp.Aspects.ITypeLevelAspect" />
      <remarks>
        <note>
      This class does not provide any advice. You may derive your aspect class from a
      <see href="../../UserGuide/Aspects/AspectKinds/Overview.html">
        class providing
        predefined advice
      </see>
      , or build a
      <see href="../../UserGuide/Aspects/CompositeAspects/Overview.html">composite aspect</see>
      .
    </note>
        <seealso href="../../UserGuide/Aspects/AspectKinds/Overview.html">Aspect Kinds</seealso>
        <seealso href="../../UserGuide/Aspects/CompositeAspects/Overview.html">Composite Aspects</seealso>
        <br />
        <note>
      All classes implementing
      <see cref="T:PostSharp.Aspects.IAspect" />
      should typically be marked as serializable
      using the
      <see cref="T:System.SerializableAttribute" />
      custom attribute. Fields that
      are only used at runtime (and unknown at compile-time) should be carefully
      marked with the
      <see cref="T:System.NonSerializedAttribute" />
      custom attribute.
      When PostSharp is used on a platform that does not support aspect serialization
      (such as .NET Compact Framework, Silverlight, or Windows Phone), or when
      another aspect serializer is used, it is not necessary to mark the aspect
      class as serializable.
      For more information, see
      <see href="../../UserGuide/Aspects/Advanced/Serialization.html">Aspect Serialization</see>
      .
    </note>
        <seealso href="../../UserGuide/Aspects/Advanced/Serialization.html">Aspect Serialization</seealso>
      </remarks>
    </member>
    <member name="T:PostSharp.Aspects.ITypeLevelAspect">
      <summary>
            Run-time semantics of aspects applied to types.
            </summary>
      <seealso cref="T:PostSharp.Aspects.ITypeLevelAspectBuildSemantics" />
    </member>
    <member name="M:PostSharp.Aspects.ITypeLevelAspect.RuntimeInitialize(System.Type)">
      <summary>
            Initializes the current aspect.
            </summary>
      <param name="type">Type to which the current aspect is applied.</param>
    </member>
    <member name="T:PostSharp.Aspects.ITypeLevelAspectBuildSemantics">
      <summary>
            Compile-time semantics of <see cref="T:PostSharp.Aspects.ITypeLevelAspect" />.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.ITypeLevelAspectBuildSemantics.CompileTimeInitialize(System.Type,PostSharp.Aspects.AspectInfo)">
      <summary>
            Method invoked at build time to initialize the instance fields of the current aspect. This method is invoked
            before any other build-time method.
            </summary>
      <param name="type">Type to which the current aspect is applied</param>
      <param name="aspectInfo">Reserved for future usage.</param>
    </member>
    <member name="M:PostSharp.Aspects.TypeLevelAspect.CompileTimeValidate(System.Type)">
      <summary>
            Method invoked at build time to ensure that the aspect has been applied to the right target.
            </summary>
      <param name="type">Type to which the aspect has been applied</param>
      <returns>
        <c>true</c> if the aspect was applied to an acceptable field, otherwise
            <c>false</c>.</returns>
      <remarks>The implementation of this method is expected to emit an error message (see 
            <see cref="T:PostSharp.Extensibility.MessageSource" />) or an exception in case of error. Returning <c>false</c> without emitting an
            error message or exception causes the aspect to be silently ignored.</remarks>
    </member>
    <member name="M:PostSharp.Aspects.TypeLevelAspect.CompileTimeValidate(System.Object)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.TypeLevelAspect.SetAspectConfiguration(PostSharp.Aspects.AspectConfiguration,System.Type)">
      <summary>
            Method invoked at build time to set up an <see cref="T:PostSharp.Aspects.AspectConfiguration" /> object according to the current 
            <see cref="T:PostSharp.Aspects.Aspect" /> instance and a specified target element of the current aspect.
            </summary>
      <param name="aspectConfiguration">The <see cref="T:PostSharp.Aspects.AspectConfiguration" /> instance previously returned  by the
            <see cref="M:PostSharp.Aspects.Aspect.CreateAspectConfiguration" /> method.</param>
      <param name="targetType">Type to which the current aspect has been applied.</param>
      <remarks>
        <para>Classes overriding this method must always invoke the base implementation before performing their own
            changes to the 
            <see cref="T:PostSharp.Aspects.AspectConfiguration" />.</para>
      </remarks>
    </member>
    <member name="M:PostSharp.Aspects.TypeLevelAspect.SetAspectConfiguration(PostSharp.Aspects.AspectConfiguration,System.Object)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.TypeLevelAspect.CompileTimeInitialize(System.Type,PostSharp.Aspects.AspectInfo)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.TypeLevelAspect.RuntimeInitialize(System.Type)">
      <inheritdoc />
    </member>
    <member name="T:PostSharp.Aspects.ICompositionAspect">
      <summary>
            Defines the semantics of an aspect that, when applied on a type, introduce one or many new interfaces
            into that type, and let these interfaces be implemented by an object created
            at runtime.
            </summary>
      <remarks>
            Use the <see cref="T:PostSharp.Post" />.<see cref="M:PostSharp.Post.Cast``2(``0)" />
            method to cast the enhanced type to the newly implemented interface. This
            cast is verified during post-compilation.
            </remarks>
    </member>
    <member name="M:PostSharp.Aspects.ICompositionAspect.CreateImplementationObject(PostSharp.Aspects.AspectArgs)">
      <summary>
            Method invoked at runtime, during the initialization of instances of the target type,
            to create the composed object.
            </summary>
      <returns>The composed object. This interface should implement the interfaces specified
            by the <see cref="P:PostSharp.Aspects.CompositionAspectConfiguration.PublicInterfaces" /> and 
            <see cref="P:PostSharp.Aspects.CompositionAspectConfiguration.ProtectedInterfaces" /> collections.</returns>
      <remarks>
            This method is invoked during at runtime after the base constructor has executed, and before
            the constructor of the current type is executed.
            </remarks>
    </member>
    <member name="M:PostSharp.Aspects.CompositionAspect.CreateImplementationObject(PostSharp.Aspects.AspectArgs)">
      <summary>
            Method invoked at runtime, during the initialization of instances of the target type,
            to create the composed object.
            </summary>
      <returns>The composed object. This interface should implement the interfaces specified
            by the <see cref="M:PostSharp.Aspects.CompositionAspect.GetPublicInterfaces(System.Type)" /> and 
            <see cref="M:PostSharp.Aspects.CompositionAspect.GetProtectedInterfaces(System.Type)" /> methods.</returns>
      <remarks>
            This method is invoked during at runtime after the base constructor has executed, and before
            the constructor of the current type is executed.
            </remarks>
    </member>
    <member name="M:PostSharp.Aspects.CompositionAspect.GetPublicInterfaces(System.Type)">
      <summary>
            Gets the array of interfaces that should be introduced publicly into
            the target type of the current aspect.
            </summary>
      <param name="targetType">
        <see cref="T:System.Type" /> to which the current aspect is applied.</param>
      <returns>The array of interfaces that should be introduced publicly into <see cref="T:System.Type" /><paramref name="targetType" />, or <c>null</c> if no interface should
            be introduced publicly.</returns>
    </member>
    <member name="M:PostSharp.Aspects.CompositionAspect.GetProtectedInterfaces(System.Type)">
      <summary>
            Gets the array of interfaces to be introduced indirectly into
            the target type of the current aspect. These interfaces will
            become accessible through the <see cref="T:PostSharp.Aspects.IProtectedInterface`1" /> 
            interface.
            </summary>
      <param name="targetType">
        <see cref="T:System.Type" /> to which the current aspect is applied.</param>
      <returns>The array of interfaces that should be introduced indirectly into <see cref="T:System.Type" /><paramref name="targetType" />, or <c>null</c> if no interface should be introduced indirectly.</returns>
    </member>
    <member name="M:PostSharp.Aspects.CompositionAspect.CreateAspectConfiguration">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.CompositionAspect.SetAspectConfiguration(PostSharp.Aspects.AspectConfiguration,System.Type)">
      <inheritdoc />
    </member>
    <member name="P:PostSharp.Aspects.CompositionAspect.OverrideAction">
      <summary>
            Specifies the action (<see cref="F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Fail" /> or <see cref="F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Ignore" />)
            to be overtaken when one of the interfaces returned by <see cref="M:PostSharp.Aspects.CompositionAspect.GetPublicInterfaces(System.Type)" /> or <see cref="M:PostSharp.Aspects.CompositionAspect.GetProtectedInterfaces(System.Type)" />
            is already implemented by the type to which the current aspect is applied.
            </summary>
      <seealso cref="P:PostSharp.Aspects.CompositionAspect.AncestorOverrideAction" />
    </member>
    <member name="P:PostSharp.Aspects.CompositionAspect.AncestorOverrideAction">
      <summary>
            Specifies the action (<see cref="F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Fail" /> or <see cref="F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Ignore" />)
            to be overtaken when an <i>ancestor</i> of one of the interfaces returned by <see cref="M:PostSharp.Aspects.CompositionAspect.GetPublicInterfaces(System.Type)" />
            is already implemented by the type to which the current aspect is applied.
            </summary>
      <seealso cref="P:PostSharp.Aspects.CompositionAspect.OverrideAction" />
    </member>
    <member name="P:PostSharp.Aspects.CompositionAspect.NonSerializedImplementation">
      <summary>
            Determines whether the field containing the interface implementation (and storing the object returned by
            <see cref="M:PostSharp.Aspects.CompositionAspect.CreateImplementationObject(PostSharp.Aspects.AspectArgs)" />) should be excluded from serialization by <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter" />.
            The same effect is typically obtained by applying the <see cref="T:System.NonSerializedAttribute" /> custom attribute to the field.
            </summary>
    </member>
    <member name="P:PostSharp.Aspects.CompositionAspect.GenerateImplementationAccessor">
      <summary>
            Determines whether the interface <see cref="T:PostSharp.Aspects.IComposed`1" /> should be introduced into the type to which the aspect
            is applied for each interface returned by the <see cref="M:PostSharp.Aspects.CompositionAspect.GetPublicInterfaces(System.Type)" /> method.
            </summary>
    </member>
    <member name="T:PostSharp.Aspects.Dependencies.AdviceDependencyAttribute">
      <summary>
            Specifies an aspect dependency matching an advice of the same aspect instance.
            </summary>
    </member>
    <member name="T:PostSharp.Aspects.Dependencies.AspectDependencyAttribute">
      <summary>
            Base class for all custom attributes defining aspect dependencies. An aspect dependency determines the
            behavior of aspects or advices when used in conjunction with other aspects and advices.
            Aspect dependencies determine ordering, requirements, conflicts, and commutativity of aspects and advices.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.Dependencies.AspectDependencyAttribute.#ctor(PostSharp.Aspects.Dependencies.AspectDependencyAction)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Aspects.Dependencies.AspectDependencyAttribute" /> without specifying the position,
            implicitly set to <see cref="F:PostSharp.Aspects.Dependencies.AspectDependencyPosition.Any" />.
            </summary>
      <param name="action">Dependency action.</param>
    </member>
    <member name="M:PostSharp.Aspects.Dependencies.AspectDependencyAttribute.#ctor(PostSharp.Aspects.Dependencies.AspectDependencyAction,PostSharp.Aspects.Dependencies.AspectDependencyPosition)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Aspects.Dependencies.AspectDependencyAttribute" /> and specifies a position.
            </summary>
      <param name="action">Dependency action.</param>
      <param name="position">Dependency position.</param>
    </member>
    <member name="P:PostSharp.Aspects.Dependencies.AspectDependencyAttribute.Action">
      <summary>
            Gets the dependency action, i.e. the kind of relationship specified by the dependency
            (<see cref="F:PostSharp.Aspects.Dependencies.AspectDependencyAction.Order" />, <see cref="F:PostSharp.Aspects.Dependencies.AspectDependencyAction.Require" />,
            <see cref="F:PostSharp.Aspects.Dependencies.AspectDependencyAction.Conflict" />, or <see cref="F:PostSharp.Aspects.Dependencies.AspectDependencyAction.Commute" />).
            </summary>
      <remarks>
            See documentation of <see cref="T:PostSharp.Aspects.Dependencies.AspectDependencyAction" /> for a description of the meaning of combined <see cref="P:PostSharp.Aspects.Dependencies.AspectDependencyAttribute.Action" />
            and <see cref="P:PostSharp.Aspects.Dependencies.AspectDependencyAttribute.Position" /> properties.
            </remarks>
    </member>
    <member name="P:PostSharp.Aspects.Dependencies.AspectDependencyAttribute.Position">
      <summary>
            Gets the position of the current dependency, i.e. actually the position of the <i>other</i>
            aspect or advices with respect to the one related to this dependency.
            </summary>
      <remarks>
            See documentation of <see cref="T:PostSharp.Aspects.Dependencies.AspectDependencyAction" /> for a description of the meaning of combined <see cref="P:PostSharp.Aspects.Dependencies.AspectDependencyAttribute.Action" />
            and <see cref="P:PostSharp.Aspects.Dependencies.AspectDependencyAttribute.Position" /> properties.
            </remarks>
    </member>
    <member name="P:PostSharp.Aspects.Dependencies.AspectDependencyAttribute.Target">
      <summary>
            Determines the target (<see cref="F:PostSharp.Aspects.Dependencies.AspectDependencyTarget.Default" /> or <see cref="F:PostSharp.Aspects.Dependencies.AspectDependencyTarget.Type" />)
            to which the aspect dependency apply.
            </summary>
      <remarks>See the documentation of <see cref="T:PostSharp.Aspects.Dependencies.AspectDependencyTarget" /> for details.</remarks>
    </member>
    <member name="P:PostSharp.Aspects.Dependencies.AspectDependencyAttribute.IsWarning">
      <summary>
            If <c>true</c>, specifies that the constraint (of type <see cref="F:PostSharp.Aspects.Dependencies.AspectDependencyAction.Require" />
            or <see cref="F:PostSharp.Aspects.Dependencies.AspectDependencyAction.Conflict" />) should emit a warning instead of an error if not
            respected.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.Dependencies.AdviceDependencyAttribute.#ctor(PostSharp.Aspects.Dependencies.AspectDependencyAction,PostSharp.Aspects.Dependencies.AspectDependencyPosition,System.String)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Aspects.Dependencies.AdviceDependencyAttribute" /> and specifies a position.
            </summary>
      <param name="action">Dependency action.</param>
      <param name="position">Dependency position.</param>
      <param name="adviceMethodName">Name of the advice method.</param>
    </member>
    <member name="M:PostSharp.Aspects.Dependencies.AdviceDependencyAttribute.#ctor(PostSharp.Aspects.Dependencies.AspectDependencyAction,System.String)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Aspects.Dependencies.AdviceDependencyAttribute" /> without specifying the position,
            implicitly set to <see cref="F:PostSharp.Aspects.Dependencies.AspectDependencyPosition.Any" />.
            </summary>
      <param name="action">Dependency action.</param>
      <param name="adviceMethodName">Name of the advice method.</param>
    </member>
    <member name="P:PostSharp.Aspects.Dependencies.AdviceDependencyAttribute.AdviceMethodName">
      <summary>
            Gets the name of the method implementing the advice.
            </summary>
    </member>
    <member name="T:PostSharp.Aspects.Dependencies.AspectDependencyAction">
      <summary>
            Enumeration of the different kinds of relationships of specified by aspect dependencies.
            </summary>
      <remarks>
        <para>The combined values of <see cref="T:PostSharp.Aspects.Dependencies.AspectDependencyAction" /> and <see cref="T:PostSharp.Aspects.Dependencies.AspectDependencyPosition" /> is interpreted
            as follows:</para>
        <table>
          <tr>
            <th>Action</th>
            <th>Position</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>
              <see cref="F:PostSharp.Aspects.Dependencies.AspectDependencyAction.Order" />
            </td>
            <td>
              <see cref="F:PostSharp.Aspects.Dependencies.AspectDependencyPosition.After" />
            </td>
            <td>The current aspect or advice should be positioned <i>after</i> the other aspect or advice
                    matched by the custom attribute.</td>
          </tr>
          <tr>
            <td>
              <see cref="F:PostSharp.Aspects.Dependencies.AspectDependencyAction.Order" />
            </td>
            <td>
              <see cref="F:PostSharp.Aspects.Dependencies.AspectDependencyPosition.Before" />
            </td>
            <td>The current aspect or advice should be positioned <i>before</i> the other aspect or advice
                    matched by the custom attribute.</td>
          </tr>
          <tr>
            <td>
              <see cref="F:PostSharp.Aspects.Dependencies.AspectDependencyAction.Require" />
            </td>
            <td>
              <see cref="F:PostSharp.Aspects.Dependencies.AspectDependencyPosition.Any" />
            </td>
            <td>The current aspect or advice requires another aspect or advice
                    matched by the custom attribute, at any position.</td>
          </tr>
          <tr>
            <td>
              <see cref="F:PostSharp.Aspects.Dependencies.AspectDependencyAction.Require" />
            </td>
            <td>
              <see cref="F:PostSharp.Aspects.Dependencies.AspectDependencyPosition.After" />
            </td>
            <td>The current aspect or advice requires another aspect or advice
                    matched by the custom attribute positioned <i>after</i> the current one.</td>
          </tr>
          <tr>
            <td>
              <see cref="F:PostSharp.Aspects.Dependencies.AspectDependencyAction.Require" />
            </td>
            <td>
              <see cref="F:PostSharp.Aspects.Dependencies.AspectDependencyPosition.Before" />
            </td>
            <td>The current aspect or advice requires another aspect or advice
                    matched by the custom attribute positioned <i>before</i> the current one.</td>
          </tr>
          <tr>
            <td>
              <see cref="F:PostSharp.Aspects.Dependencies.AspectDependencyAction.Conflict" />
            </td>
            <td>
              <see cref="F:PostSharp.Aspects.Dependencies.AspectDependencyPosition.Any" />
            </td>
            <td>The current aspect or advice conflicts with any aspect or advice
                    matched by the custom attribute, at any position.</td>
          </tr>
          <tr>
            <td>
              <see cref="F:PostSharp.Aspects.Dependencies.AspectDependencyAction.Conflict" />
            </td>
            <td>
              <see cref="F:PostSharp.Aspects.Dependencies.AspectDependencyPosition.After" />
            </td>
            <td>The current aspect or advice conflicts with any aspect or advice
                    matched by the custom attribute, if positioned <i>after</i> the current one.</td>
          </tr>
          <tr>
            <td>
              <see cref="F:PostSharp.Aspects.Dependencies.AspectDependencyAction.Conflict" />
            </td>
            <td>
              <see cref="F:PostSharp.Aspects.Dependencies.AspectDependencyPosition.Before" />
            </td>
            <td>The current aspect or advice conflicts with any aspect or advice
                    matched by the custom attribute, if positioned <i>before</i> the current one.</td>
          </tr>
          <tr>
            <td>
              <see cref="F:PostSharp.Aspects.Dependencies.AspectDependencyAction.Commute" />
            </td>
            <td />
            <td>The current aspect or advice commute with any other aspect or advice
                    matched by the custom attribute.
            </td>
          </tr>
        </table>
      </remarks>
    </member>
    <member name="F:PostSharp.Aspects.Dependencies.AspectDependencyAction.None">
      <summary>
            The dependency is ignored.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Dependencies.AspectDependencyAction.Order">
      <summary>
            The dependency specifies an order relationship.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Dependencies.AspectDependencyAction.Require">
      <summary>
            The depedency specifies that the current aspect or advice requires
            another aspect or advice.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Dependencies.AspectDependencyAction.Conflict">
      <summary>
            The dependency specifies that the current aspect or advice
            conflicts with another aspect or advice.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Dependencies.AspectDependencyAction.Commute">
      <summary>
            The dependency specifies that the current aspect or advice
            commutes with another aspect or advice.
            </summary>
    </member>
    <member name="T:PostSharp.Aspects.Dependencies.AspectDependencyPosition">
      <summary>
            Enumeration of the direction of the relationship specified by an aspect dependency.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Dependencies.AspectDependencyPosition.Any">
      <summary>
            Any order possible (or order not relevant).
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Dependencies.AspectDependencyPosition.Before">
      <summary>
            The current aspect or advice is positioned before the other aspect or handler.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Dependencies.AspectDependencyPosition.After">
      <summary>
            The current aspect or advice is positioned after the other aspect or handler.
            </summary>
    </member>
    <member name="T:PostSharp.Aspects.Dependencies.AspectDependencyTarget">
      <summary>
            Enumeration of targets (<see cref="F:PostSharp.Aspects.Dependencies.AspectDependencyTarget.Default" /> or <see cref="F:PostSharp.Aspects.Dependencies.AspectDependencyTarget.Type" />)
            to which the aspect dependency apply.
            </summary>
      <remarks>
        <para>This property is meaningful only for aspects that apply to type members. For aspects that 
            apply to types, type-level and default-level dependencies are the same thing.</para>
        <para>Member-level aspects may have semantics that actually apply at type level (for instance
            member introductions and imports). By setting the dependency target to
            <see cref="F:PostSharp.Aspects.Dependencies.AspectDependencyTarget.Type" />, you can specify that the aspect dependency applies
            to type-level semantics. Otherwise, it will apply to member-level semantics.</para>
      </remarks>
    </member>
    <member name="F:PostSharp.Aspects.Dependencies.AspectDependencyTarget.Default">
      <summary>
            Natural target of the aspect.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Dependencies.AspectDependencyTarget.Type">
      <summary>
            Declaring type of the natural target of the aspect.
            </summary>
    </member>
    <member name="T:PostSharp.Aspects.Dependencies.AspectDependencyAttributeCollection">
      <summary>
            Collection of <see cref="T:PostSharp.Aspects.Dependencies.AspectDependencyAttribute" />.
            </summary>
    </member>
    <member name="T:PostSharp.Aspects.Dependencies.AspectEffectDependencyAttribute">
      <summary>
            Specifies an aspect dependency matching aspects or advices having a given effect.
            </summary>
      <remarks>
        <para>
            All aspects (except the ones that have an empty implementation) have an effect on the program execution.
            The current custom attribute allows to express dependencies to aspects according to their effect.
            </para>
        <para>The list of standard effects is given in class <see cref="T:PostSharp.Aspects.Dependencies.StandardEffects" />. All advices have
            implicitly the effect <see cref="F:PostSharp.Aspects.Dependencies.StandardEffects.Custom" />. Most advices also have the effect
            <see cref="F:PostSharp.Aspects.Dependencies.StandardEffects.ChangeControlFlow" />, because they are able to modify the control flow (for instance, 
            skip the execution of the intercepted method or throwing an exception). An aspect or advice can declare
            it does <i>not</i> have a given effect by using the <see cref="T:PostSharp.Aspects.Dependencies.WaiveAspectEffectAttribute" /> custom attribute.
             </para>
      </remarks>
      <seealso cref="T:PostSharp.Aspects.Dependencies.StandardEffects" />
      <seealso cref="T:PostSharp.Aspects.Dependencies.WaiveAspectEffectAttribute" />
    </member>
    <member name="M:PostSharp.Aspects.Dependencies.AspectEffectDependencyAttribute.#ctor(PostSharp.Aspects.Dependencies.AspectDependencyAction,PostSharp.Aspects.Dependencies.AspectDependencyPosition,System.String)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Aspects.Dependencies.AspectEffectDependencyAttribute" /> and specifies a position.
            </summary>
      <param name="action">Dependency action.</param>
      <param name="position">Dependency position.</param>
      <param name="effect">Effect (see <see cref="T:PostSharp.Aspects.Dependencies.StandardEffects" />).</param>
    </member>
    <member name="M:PostSharp.Aspects.Dependencies.AspectEffectDependencyAttribute.#ctor(PostSharp.Aspects.Dependencies.AspectDependencyAction,System.String)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Aspects.Dependencies.AspectEffectDependencyAttribute" /> without specifying the position,
            implicitly set to <see cref="F:PostSharp.Aspects.Dependencies.AspectDependencyPosition.Any" />.
            </summary>
      <param name="action">Dependency action.</param>
      <param name="effect">Effect (see <see cref="T:PostSharp.Aspects.Dependencies.StandardEffects" />).</param>
    </member>
    <member name="P:PostSharp.Aspects.Dependencies.AspectEffectDependencyAttribute.Effect">
      <summary>
            Gets the effect that the aspects or advices must have in order to match the current dependency.
            </summary>
    </member>
    <member name="T:PostSharp.Aspects.Dependencies.AspectRoleDependencyAttribute">
      <summary>
            Specifies an aspect dependency matching aspects or advices that are a part of a given role.
            </summary>
      <remarks>
        <para>
            A role describes what the aspect actually does. A list of standard roles is available on the class
            <see cref="T:PostSharp.Aspects.Dependencies.StandardRoles" />. Aspect vendors are encouraged to enroll their aspects in one of these
            roles whenever it makes sense, and to document the other roles they have used.
            </para>
        <para>An aspect or advice can be enrolled in a role by using the <see cref="T:PostSharp.Aspects.Dependencies.ProvideAspectRoleAttribute" />
            custom attribute.
            </para>
      </remarks>
      <seealso cref="T:PostSharp.Aspects.Dependencies.ProvideAspectRoleAttribute" />
      <seealso cref="T:PostSharp.Aspects.Dependencies.StandardRoles" />
    </member>
    <member name="M:PostSharp.Aspects.Dependencies.AspectRoleDependencyAttribute.#ctor(PostSharp.Aspects.Dependencies.AspectDependencyAction,PostSharp.Aspects.Dependencies.AspectDependencyPosition,System.String)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Aspects.Dependencies.AspectRoleDependencyAttribute" /> and specifies a position.
            </summary>
      <param name="action">Dependency action.</param>
      <param name="position">Dependency position.</param>
      <param name="role">Role.</param>
    </member>
    <member name="M:PostSharp.Aspects.Dependencies.AspectRoleDependencyAttribute.#ctor(PostSharp.Aspects.Dependencies.AspectDependencyAction,System.String)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Aspects.Dependencies.AspectEffectDependencyAttribute" /> without specifying the position,
            implicitly set to <see cref="F:PostSharp.Aspects.Dependencies.AspectDependencyPosition.Any" />.
            </summary>
      <param name="action">Dependency action.</param>
      <param name="role">Role.</param>
    </member>
    <member name="P:PostSharp.Aspects.Dependencies.AspectRoleDependencyAttribute.Role">
      <summary>
            Gets the role that the aspects or advices must be a part of in order to match the current dependency.
            </summary>
    </member>
    <member name="T:PostSharp.Aspects.Dependencies.AspectTypeDependencyAttribute">
      <summary>
            Specifies an aspect dependency matching aspects of a specified type, and all its advices.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.Dependencies.AspectTypeDependencyAttribute.#ctor(PostSharp.Aspects.Dependencies.AspectDependencyAction,PostSharp.Aspects.Dependencies.AspectDependencyPosition,System.Type)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Aspects.Dependencies.AspectTypeDependencyAttribute" /> and specifies a position.
            </summary>
      <param name="action">Dependency action.</param>
      <param name="position">Dependency position.</param>
      <param name="aspectType">Aspect type (derived from <see cref="T:PostSharp.Aspects.IAspect" />).</param>
    </member>
    <member name="M:PostSharp.Aspects.Dependencies.AspectTypeDependencyAttribute.#ctor(PostSharp.Aspects.Dependencies.AspectDependencyAction,System.Type)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Aspects.Dependencies.AspectTypeDependencyAttribute" /> without specifying the position,
            implicitly set to <see cref="F:PostSharp.Aspects.Dependencies.AspectDependencyPosition.Any" />.
            </summary>
      <param name="action">Dependency action.</param>
      <param name="aspectType">Aspect type (derived from <see cref="T:PostSharp.Aspects.IAspect" />).</param>
    </member>
    <member name="P:PostSharp.Aspects.Dependencies.AspectTypeDependencyAttribute.AspectType">
      <summary>
            Gets the type from which the aspects should be derived in order to match the current dependency.
            </summary>
    </member>
    <member name="T:PostSharp.Aspects.Dependencies.ProvideAspectRoleAttribute">
      <summary>
            Specifies that the aspect or aspect advice to which this custom attribute is applied is a
            part of a given role. This aspect or advice can then be matched by <see cref="T:PostSharp.Aspects.Dependencies.AspectRoleDependencyAttribute" />/
            </summary>
      <seealso cref="T:PostSharp.Aspects.Dependencies.AspectRoleDependencyAttribute" />
    </member>
    <member name="M:PostSharp.Aspects.Dependencies.ProvideAspectRoleAttribute.#ctor(System.String)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Aspects.Dependencies.ProvideAspectRoleAttribute" />.
            </summary>
      <param name="role">Role.</param>
    </member>
    <member name="P:PostSharp.Aspects.Dependencies.ProvideAspectRoleAttribute.Role">
      <summary>
            Gets the role into which the aspect or advice to which this custom
            attribute is applied will be enrolled.
            </summary>
    </member>
    <member name="T:PostSharp.Aspects.Dependencies.StandardEffects">
      <summary>
            List of standard effects.
            </summary>
      <remarks>
        <para>See <see cref="T:PostSharp.Aspects.Dependencies.AspectEffectDependencyAttribute" /> for a discussion of effects.</para>
        <para>This list is not meant to be extended by vendors providing concrete aspects (implementing some business
            functionality). Roles should be used to categorized the business effect of concrete aspects. However, if you
            implement a new kind of abstract aspect  (for instance member suppression), you may need to define new effects.
            </para>
        <para>
                In that case, we at <c>PostSharp</c> encourage you contact us to define a new role string. If you define a
                new role string, we recommend you clearly define it so that users of your aspect can express dependencies
                with their own aspects, or third-party aspects.</para>
      </remarks>
      <seealso cref="T:PostSharp.Aspects.Dependencies.AspectEffectDependencyAttribute" />
      <seealso cref="T:PostSharp.Aspects.Dependencies.WaiveAspectEffectAttribute" />
      <seealso cref="T:PostSharp.Aspects.Dependencies.StandardRoles" />
    </member>
    <member name="F:PostSharp.Aspects.Dependencies.StandardEffects.MemberImport">
      <summary>
            Import of a type member.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Dependencies.StandardEffects.CustomAttributeIntroduction">
      <summary>
            Introduction of a custom attribute.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Dependencies.StandardEffects.InterfaceIntroduction">
      <summary>
            Introduction of an interface.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Dependencies.StandardEffects.MemberIntroduction">
      <summary>
            Introduction of a type member.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Dependencies.StandardEffects.Custom">
      <summary>
            Custom effect (implemented in an aspect advice). All advices have this effect by default,
            unless they are annotated by <see cref="T:PostSharp.Aspects.Dependencies.WaiveAspectEffectAttribute" />.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Dependencies.StandardEffects.ChangeControlFlow">
      <summary>
            Change the flow control (for instance by having the possibility to skip execution of an
            intercepted method).
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.Dependencies.StandardEffects.GetMemberIntroductionEffect(System.String)">
      <summary>
            Gets a string representing the effect of introducing a member into a type.
            </summary>
      <param name="memberName">Name of the introduced member.</param>
      <returns>A string that, by convention, represents the introduction of a member named
            <paramref name="memberName" /> into a type.</returns>
    </member>
    <member name="M:PostSharp.Aspects.Dependencies.StandardEffects.GetMemberImportEffect(System.String)">
      <summary>
            Gets a string representing the effect of importing a member into from the target
            type into the aspect.
            </summary>
      <param name="memberName">Name of the imported member.</param>
      <returns>A string that, by convention, represents the import of a member named
            <paramref name="memberName" /> from the target type into the aspect.</returns>
    </member>
    <member name="M:PostSharp.Aspects.Dependencies.StandardEffects.GetInterfaceIntroductionEffect(System.String)">
      <summary>
            Gets a string representing the effect of introducing an interface into a type.
            </summary>
      <param name="typeName">Name of the introduced interface.</param>
      <returns>A string that, by convention, represents the introduction of an interface named
            <paramref name="typeName" /> into a type.</returns>
    </member>
    <member name="T:PostSharp.Aspects.Dependencies.StandardRoles">
      <summary>
            List of standard roles.
            </summary>
      <remarks>
        <para>See <see cref="T:PostSharp.Aspects.Dependencies.AspectRoleDependencyAttribute" /> for a discussion of aspect roles.</para>
        <para>Roles are used to categorize aspects according to their function. This class
                defines standard names for the most commonly used aspect roles. If you are an aspect vendor,
                you are encouraged to enroll your aspects (using <see cref="T:PostSharp.Aspects.Dependencies.ProvideAspectRoleAttribute" />) into
                one of these roles. 
                </para>
        <para>
                If this list is not sufficient, we at <c>PostSharp</c> encourage you
                contact us to define a new role string. In any case, if you define a new role string, we recommend you
                clearly define it so that users of your aspect can express dependencies with their own aspects,
                or third-party aspects.</para>
      </remarks>
    </member>
    <member name="F:PostSharp.Aspects.Dependencies.StandardRoles.Validation">
      <summary>
            Validation of field, property, or parameter value.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Dependencies.StandardRoles.Tracing">
      <summary>
            Tracing and logging.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Dependencies.StandardRoles.PerformanceInstrumentation">
      <summary>
            Performance instrumentation (for instance performance counters).
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Dependencies.StandardRoles.Security">
      <summary>
            Security enforcing (typically authorization).
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Dependencies.StandardRoles.Caching">
      <summary>
            Caching.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Dependencies.StandardRoles.TransactionHandling">
      <summary>
            Transaction handling.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Dependencies.StandardRoles.ExceptionHandling">
      <summary>
            Exception handling.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Dependencies.StandardRoles.DataBinding">
      <summary>
            Data binding (for instance implementation of <see cref="T:System.ComponentModel.INotifyPropertyChanged" />).
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Dependencies.StandardRoles.Persistence">
      <summary>
            Object persistence (for instance Object-Relational Mapper).
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Dependencies.StandardRoles.EventBroker">
      <summary>
            Event broker (a system role used internally by <c>PostSharp</c> to realize
            the <see cref="M:PostSharp.Aspects.IEventInterceptionAspect.OnInvokeHandler(PostSharp.Aspects.EventInterceptionArgs)" />  handler).
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Dependencies.StandardRoles.Threading">
      <summary>
            Threading (locking).
            </summary>
    </member>
    <member name="T:PostSharp.Aspects.Dependencies.WaiveAspectEffectAttribute">
      <summary>
            Declares that the aspect class or advice to which this custom attribute is applied
            is exempt of a given effect.
            </summary>
      <remarks>
            See <see cref="T:PostSharp.Aspects.Dependencies.AspectEffectDependencyAttribute" /> for details about effects.
            </remarks>
    </member>
    <member name="M:PostSharp.Aspects.Dependencies.WaiveAspectEffectAttribute.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Aspects.Dependencies.WaiveAspectEffectAttribute" /> declaring that
            the aspect class or advice to which this custom attribute is applied has
            no effect at all.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.Dependencies.WaiveAspectEffectAttribute.#ctor(System.String[])">
      <summary>
            Initializes a new <see cref="T:PostSharp.Aspects.Dependencies.WaiveAspectEffectAttribute" /> declaring that
            the aspect class or advice to which this custom attribute is applied is
            exempt of the specified effects.
            </summary>
      <param name="effects">List of effects of which the aspect class or advice
            to which this custom attribute is applied is guaranteed to be exempt.</param>
    </member>
    <member name="T:PostSharp.Aspects.EventInterceptionArgs">
      <summary>
            Arguments of handlers of aspects of the type <see cref="T:PostSharp.Aspects.IEventInterceptionAspect" />.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.EventInterceptionArgs.ProceedAddHandler">
      <summary>
            Proceeds with adding the <see cref="T:System.Delegate" /> to the event to which the current aspect. 
            This method invokes the next handler in chain. 
            It is typically invoked from the implementation of <see cref="M:PostSharp.Aspects.IEventInterceptionAspect.OnAddHandler(PostSharp.Aspects.EventInterceptionArgs)" />.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.EventInterceptionArgs.ProceedRemoveHandler">
      <summary>
            Proceeds with removing the <see cref="T:System.Delegate" /> from the event to which the current aspect. 
            This method invokes the next handler in chain. 
            It is typically invoked from the implementation of <see cref="M:PostSharp.Aspects.IEventInterceptionAspect.OnRemoveHandler(PostSharp.Aspects.EventInterceptionArgs)" />.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.EventInterceptionArgs.ProceedInvokeHandler">
      <summary>
            Proceeds with invoking the <see cref="T:System.Delegate" /> with the arguments specified in the <see cref="P:PostSharp.Aspects.EventInterceptionArgs.Arguments" /> property.
            The delegate may change the <see cref="P:PostSharp.Aspects.EventInterceptionArgs.Arguments" /> and set the <see cref="P:PostSharp.Aspects.EventInterceptionArgs.ReturnValue" />.
            This method invokes the next handler in chain. 
            It is typically invoked from the implementation of <see cref="M:PostSharp.Aspects.IEventInterceptionAspect.OnInvokeHandler(PostSharp.Aspects.EventInterceptionArgs)" />.
            </summary>
    </member>
    <member name="P:PostSharp.Aspects.EventInterceptionArgs.Binding">
      <summary>
            Gets an interface that allows to invoke the next node in the chain of invocation of the intercepted method.
            </summary>
      <remarks>
        <!-- No matching elements were found for the following include tag -->
        <include file="Documentation.xml" path="/documentation/section[@name='bindingProperty']/*" />
      </remarks>
    </member>
    <member name="P:PostSharp.Aspects.EventInterceptionArgs.Handler">
      <summary>
            Gets the delegate being added, removed, or invoked.
            </summary>
    </member>
    <member name="P:PostSharp.Aspects.EventInterceptionArgs.ReturnValue">
      <summary>
            Gets the return value of the delegate.
            </summary>
      <remarks>
        <para>This property is meaningful only during a delegate invocation (not during an addition or removal).</para>
        <para>This property is typically set by the <see cref="M:PostSharp.Aspects.EventInterceptionArgs.ProceedInvokeHandler" /> method. It is also legal for
            an implementation of <see cref="M:PostSharp.Aspects.IEventInterceptionAspect.OnInvokeHandler(PostSharp.Aspects.EventInterceptionArgs)" /> to change the value of this property.</para>
      </remarks>
    </member>
    <member name="P:PostSharp.Aspects.EventInterceptionArgs.Event">
      <summary>
            Gets the event to which the current aspect has been applied.
            </summary>
      <remarks>
            Using this property causes the aspect weaver to generate code that has non-trivial runtime overhead. Avoid using
            this property whenever possible. One of the possible solution is to use compile-time initialization of
            aspect instances and to make use of reflection only at build time.
            </remarks>
    </member>
    <member name="P:PostSharp.Aspects.EventInterceptionArgs.Arguments">
      <summary>
            Gets the delegate arguments.
            </summary>
      <remarks>
        <para>This property is meaningful only during a delegate invocation (not during an addition or removal).</para>
        <para>This property is typically accessed by the <see cref="M:PostSharp.Aspects.EventInterceptionArgs.ProceedInvokeHandler" /> method. It is also legal for
            an implementation of <see cref="M:PostSharp.Aspects.IEventInterceptionAspect.OnInvokeHandler(PostSharp.Aspects.EventInterceptionArgs)" /> to read or change the value of this property.</para>
      </remarks>
    </member>
    <member name="T:PostSharp.Aspects.EventInterceptionAspect">
      <summary>
            Aspect that, when applied on an event, intercepts invocations of its semantics <c>Add</c> (<see cref="M:PostSharp.Aspects.EventInterceptionAspect.OnAddHandler(PostSharp.Aspects.EventInterceptionArgs)" />), 
            <c>Remove</c> (<see cref="M:PostSharp.Aspects.EventInterceptionAspect.OnRemoveHandler(PostSharp.Aspects.EventInterceptionArgs)" />) and <c>Invoke</c> (<see cref="M:PostSharp.Aspects.EventInterceptionAspect.OnInvokeHandler(PostSharp.Aspects.EventInterceptionArgs)" />) semantics.
            </summary>
      <remarks>
        <note>
      All classes implementing
      <see cref="T:PostSharp.Aspects.IAspect" />
      should typically be marked as serializable
      using the
      <see cref="T:System.SerializableAttribute" />
      custom attribute. Fields that
      are only used at runtime (and unknown at compile-time) should be carefully
      marked with the
      <see cref="T:System.NonSerializedAttribute" />
      custom attribute.
      When PostSharp is used on a platform that does not support aspect serialization
      (such as .NET Compact Framework, Silverlight, or Windows Phone), or when
      another aspect serializer is used, it is not necessary to mark the aspect
      class as serializable.
      For more information, see
      <see href="../../UserGuide/Aspects/Advanced/Serialization.html">Aspect Serialization</see>
      .
    </note>
        <seealso href="../../UserGuide/Aspects/Advanced/Serialization.html">Aspect Serialization</seealso>
      </remarks>
    </member>
    <member name="T:PostSharp.Aspects.EventLevelAspect">
      <summary>
            Base class for all aspects applied on events.
            </summary>
      <remarks>
        <note>
      This class does not provide any advice. You may derive your aspect class from a
      <see href="../../UserGuide/Aspects/AspectKinds/Overview.html">
        class providing
        predefined advice
      </see>
      , or build a
      <see href="../../UserGuide/Aspects/CompositeAspects/Overview.html">composite aspect</see>
      .
    </note>
        <seealso href="../../UserGuide/Aspects/AspectKinds/Overview.html">Aspect Kinds</seealso>
        <seealso href="../../UserGuide/Aspects/CompositeAspects/Overview.html">Composite Aspects</seealso>
        <br />
        <note>
      All classes implementing
      <see cref="T:PostSharp.Aspects.IAspect" />
      should typically be marked as serializable
      using the
      <see cref="T:System.SerializableAttribute" />
      custom attribute. Fields that
      are only used at runtime (and unknown at compile-time) should be carefully
      marked with the
      <see cref="T:System.NonSerializedAttribute" />
      custom attribute.
      When PostSharp is used on a platform that does not support aspect serialization
      (such as .NET Compact Framework, Silverlight, or Windows Phone), or when
      another aspect serializer is used, it is not necessary to mark the aspect
      class as serializable.
      For more information, see
      <see href="../../UserGuide/Aspects/Advanced/Serialization.html">Aspect Serialization</see>
      .
    </note>
        <seealso href="../../UserGuide/Aspects/Advanced/Serialization.html">Aspect Serialization</seealso>
      </remarks>
      <seealso cref="T:PostSharp.Aspects.IEventLevelAspect" />
    </member>
    <member name="T:PostSharp.Aspects.IEventLevelAspect">
      <summary>
            Runtime semantics of aspects that can be applied on events.
            </summary>
      <seealso cref="T:PostSharp.Aspects.EventLevelAspect" />
      <seealso cref="T:PostSharp.Aspects.IEventLevelAspectBuildSemantics" />
    </member>
    <member name="M:PostSharp.Aspects.IEventLevelAspect.RuntimeInitialize(System.Reflection.EventInfo)">
      <summary>
            Initializes the current aspect.
            </summary>
      <param name="eventInfo">Event to which the current aspect is applied.</param>
    </member>
    <member name="T:PostSharp.Aspects.IEventLevelAspectBuildSemantics">
      <summary>
            Build-time semantics of aspects that can be applied on events.
            </summary>
      <seealso cref="T:PostSharp.Aspects.EventLevelAspect" />
      <seealso cref="T:PostSharp.Aspects.IEventLevelAspect" />
    </member>
    <member name="M:PostSharp.Aspects.IEventLevelAspectBuildSemantics.CompileTimeInitialize(System.Reflection.EventInfo,PostSharp.Aspects.AspectInfo)">
      <summary>
            Method invoked at build time to initialize the instance fields of the current aspect. This method is invoked
            before any other build-time method.
            </summary>
      <param name="event">Event to which the current aspect is applied</param>
      <param name="aspectInfo">Reserved for future usage.</param>
    </member>
    <member name="M:PostSharp.Aspects.EventLevelAspect.RuntimeInitialize(System.Reflection.EventInfo)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.EventLevelAspect.CompileTimeInitialize(System.Reflection.EventInfo,PostSharp.Aspects.AspectInfo)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.EventLevelAspect.CompileTimeValidate(System.Reflection.EventInfo)">
      <summary>
            Method invoked at build time to ensure that the aspect has been applied to the right target.
            </summary>
      <param name="eventInfo">Event to which the aspect has been applied</param>
      <returns>
        <c>true</c> if the aspect was applied to an acceptable event, otherwise
            <c>false</c>.</returns>
      <remarks>The implementation of this method is expected to emit an error message (see 
            <see cref="T:PostSharp.Extensibility.MessageSource" />) or an exception in case of error. Returning <c>false</c> without emitting an
            error message or exception causes the aspect to be silently ignored.</remarks>
    </member>
    <member name="M:PostSharp.Aspects.EventLevelAspect.SetAspectConfiguration(PostSharp.Aspects.AspectConfiguration,System.Reflection.EventInfo)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.EventLevelAspect.SetAspectConfiguration(PostSharp.Aspects.AspectConfiguration,System.Object)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.EventLevelAspect.CompileTimeValidate(System.Object)">
      <inheritdoc />
    </member>
    <member name="T:PostSharp.Aspects.IEventInterceptionAspect">
      <summary>
            Runtime semantics of an aspect that, when applied on an event, intercepts invocations of its semantics <c>Add</c> (<see cref="M:PostSharp.Aspects.IEventInterceptionAspect.OnAddHandler(PostSharp.Aspects.EventInterceptionArgs)" />), 
            <c>Remove</c> (<see cref="M:PostSharp.Aspects.IEventInterceptionAspect.OnRemoveHandler(PostSharp.Aspects.EventInterceptionArgs)" />) and <c>Invoke</c> (<see cref="M:PostSharp.Aspects.IEventInterceptionAspect.OnInvokeHandler(PostSharp.Aspects.EventInterceptionArgs)" />) semantics.
            </summary>
      <see cref="T:PostSharp.Aspects.EventInterceptionAspect" />
      <see cref="T:PostSharp.Aspects.EventInterceptionAspectConfiguration" />
      <see cref="T:PostSharp.Aspects.EventInterceptionAspectConfigurationAttribute" />
    </member>
    <member name="M:PostSharp.Aspects.IEventInterceptionAspect.OnAddHandler(PostSharp.Aspects.EventInterceptionArgs)">
      <summary>
            Method invoked <i>instead</i> of the <c>Add</c> semantic of the event to which the current aspect is applied,
            i.e. when a new delegate is added to this event.
            </summary>
      <param name="args">Handler arguments.</param>
      <remarks>
        <note>
      Because of the way how the C# compiler implements
      <b>automatic events</b>
      (i.e. events where you
      don't implement the
      <c>Add</c>
      and
      <c>Remove</c>
      semantics manually), the
      <b>Invoke Event Handler</b>
      semantic (
      <see cref="M:PostSharp.Aspects.IEventInterceptionAspect.OnInvokeHandler(PostSharp.Aspects.EventInterceptionArgs)" />
      or equivalent) shall
      <b>not</b>
      be invoked for delegates that have been added from inside the class that declares this event.
    </note>
      </remarks>
    </member>
    <member name="M:PostSharp.Aspects.IEventInterceptionAspect.OnRemoveHandler(PostSharp.Aspects.EventInterceptionArgs)">
      <summary>
            Method invoked <i>instead</i> of the <c>Remove</c> semantic of the event to which the current aspect is applied,
            i.e. when a delegate is removed from this event.
            </summary>
      <param name="args">Handler arguments.</param>
      <remarks>
        <note>
      Because of the way how the C# compiler implements
      <b>automatic events</b>
      (i.e. events where you
      don't implement the
      <c>Add</c>
      and
      <c>Remove</c>
      semantics manually), the
      <b>Invoke Event Handler</b>
      semantic (
      <see cref="M:PostSharp.Aspects.IEventInterceptionAspect.OnInvokeHandler(PostSharp.Aspects.EventInterceptionArgs)" />
      or equivalent) shall
      <b>not</b>
      be invoked for delegates that have been added from inside the class that declares this event.
    </note>
      </remarks>
    </member>
    <member name="M:PostSharp.Aspects.IEventInterceptionAspect.OnInvokeHandler(PostSharp.Aspects.EventInterceptionArgs)">
      <summary>
            Method invoked when the event to which the current aspect is applied is fired, <i>for each</i> delegate
            of this event, and <i>instead of</i> invoking this delegate.
            </summary>
      <param name="args">Handler arguments.</param>
      <remarks>
        <note>
      Because of the way how the C# compiler implements
      <b>automatic events</b>
      (i.e. events where you
      don't implement the
      <c>Add</c>
      and
      <c>Remove</c>
      semantics manually), the
      <b>Invoke Event Handler</b>
      semantic (
      <see cref="M:PostSharp.Aspects.IEventInterceptionAspect.OnInvokeHandler(PostSharp.Aspects.EventInterceptionArgs)" />
      or equivalent) shall
      <b>not</b>
      be invoked for delegates that have been added from inside the class that declares this event.
    </note>
        <br />
        <note>
      The
      <b>Invoke Event Handler</b>
      semantic is different from normal event firing.
      Indeed, when you fire an event, all handlers that were added to this event are fired. However, the current method
      invokes only a single handler: the one passed to the
      <c>handler</c>
      parameter.
    </note>
      </remarks>
    </member>
    <member name="M:PostSharp.Aspects.EventInterceptionAspect.OnAddHandler(PostSharp.Aspects.EventInterceptionArgs)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.EventInterceptionAspect.OnRemoveHandler(PostSharp.Aspects.EventInterceptionArgs)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.EventInterceptionAspect.OnInvokeHandler(PostSharp.Aspects.EventInterceptionArgs)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.EventInterceptionAspect.CreateAspectConfiguration">
      <inheritdoc />
    </member>
    <member name="T:PostSharp.Aspects.ExternalAspect">
      <summary>
            Aspect implemented in a different type (implementing the <see cref="T:PostSharp.Aspects.IExternalAspectImplementation" />
            interface), typically contained in an external assembly. Classes derived from <see cref="T:PostSharp.Aspects.ExternalAspect" />
            must be annotated by the custom attribute <see cref="T:PostSharp.Aspects.ExternalAspectConfigurationAttribute" />.
            </summary>
      <remarks>
        <para>External aspects are useful when you develop for Silverlight or the .NET Compact Framework.
            Indeed, aspects cannot have build-time semantics on these platforms. If you need to execute logic
            at build time on these platforms, you need to implement this logic in an assembly linked with
            the normal .NET Framework (so <i>not</i> Silverlight or Compact Framework). You must relate an
            aspect with its implementation using the custom attribute <see cref="T:PostSharp.Aspects.ExternalAspectConfigurationAttribute" />.</para>
      </remarks>
    </member>
    <member name="T:PostSharp.Aspects.IExternalAspect">
      <summary>
            Allows to turn an arbitrary custom attribute into an aspect, while implementing the aspect in
            a different class. Classes implementing this interface must be annotated with the 
            <see cref="T:PostSharp.Aspects.ExternalAspectConfigurationAttribute" /> custom attribute.
            </summary>
      <remarks>
        <para>External aspects are useful when you develop for Silverlight or the .NET Compact Framework.
            Indeed, aspects cannot have build-time semantics on these platforms. If you need to execute logic
            at build time on these platforms, you need to implement this logic in an assembly linked with
            the normal .NET Framework (so <i>not</i> Silverlight or Compact Framework). You must relate an
            aspect with its implementation using the custom attribute <see cref="T:PostSharp.Aspects.ExternalAspectConfigurationAttribute" />.</para>
      </remarks>
    </member>
    <member name="T:PostSharp.Aspects.FieldLevelAspect">
      <summary>
            Base class for all aspects applied on fields.
            </summary>
      <seealso cref="T:PostSharp.Aspects.IFieldLevelAspect" />
      <remarks>
        <note>
      This class does not provide any advice. You may derive your aspect class from a
      <see href="../../UserGuide/Aspects/AspectKinds/Overview.html">
        class providing
        predefined advice
      </see>
      , or build a
      <see href="../../UserGuide/Aspects/CompositeAspects/Overview.html">composite aspect</see>
      .
    </note>
        <seealso href="../../UserGuide/Aspects/AspectKinds/Overview.html">Aspect Kinds</seealso>
        <seealso href="../../UserGuide/Aspects/CompositeAspects/Overview.html">Composite Aspects</seealso>
        <br />
        <note>
      All classes implementing
      <see cref="T:PostSharp.Aspects.IAspect" />
      should typically be marked as serializable
      using the
      <see cref="T:System.SerializableAttribute" />
      custom attribute. Fields that
      are only used at runtime (and unknown at compile-time) should be carefully
      marked with the
      <see cref="T:System.NonSerializedAttribute" />
      custom attribute.
      When PostSharp is used on a platform that does not support aspect serialization
      (such as .NET Compact Framework, Silverlight, or Windows Phone), or when
      another aspect serializer is used, it is not necessary to mark the aspect
      class as serializable.
      For more information, see
      <see href="../../UserGuide/Aspects/Advanced/Serialization.html">Aspect Serialization</see>
      .
    </note>
        <seealso href="../../UserGuide/Aspects/Advanced/Serialization.html">Aspect Serialization</seealso>
      </remarks>
    </member>
    <member name="T:PostSharp.Aspects.IFieldLevelAspect">
      <summary>
            Run-time semantics of aspects applied to fields.
            </summary>
      <seealso cref="T:PostSharp.Aspects.IFieldLevelAspectBuildSemantics" />
      <seealso cref="T:PostSharp.Aspects.FieldLevelAspect" />
    </member>
    <member name="M:PostSharp.Aspects.IFieldLevelAspect.RuntimeInitialize(System.Reflection.FieldInfo)">
      <summary>
            Method invoked at runtime before any other method of the aspect is invoked.
            </summary>
      <param name="field">Field on which this instance is applied.</param>
    </member>
    <member name="T:PostSharp.Aspects.IFieldLevelAspectBuildSemantics">
      <summary>
            Compile-time semantics of <see cref="T:PostSharp.Aspects.IFieldLevelAspect" />.
            </summary>
      <seealso cref="T:PostSharp.Aspects.IFieldLevelAspect" />
      <seealso cref="T:PostSharp.Aspects.FieldLevelAspect" />
    </member>
    <member name="M:PostSharp.Aspects.IFieldLevelAspectBuildSemantics.CompileTimeInitialize(System.Reflection.FieldInfo,PostSharp.Aspects.AspectInfo)">
      <summary>
            Method invoked at build time to initialize the instance fields of the current aspect. This method is invoked
            before any other build-time method.
            </summary>
      <param name="field">Field to which the current aspect is applied</param>
      <param name="aspectInfo">Reserved for future usage.</param>
    </member>
    <member name="M:PostSharp.Aspects.FieldLevelAspect.CompileTimeValidate(System.Reflection.FieldInfo)">
      <summary>
            Method invoked at build time to ensure that the aspect has been applied to the right target.
            </summary>
      <param name="field">Field to which the aspect has been applied</param>
      <returns>
        <c>true</c> if the aspect was applied to an acceptable field, otherwise
            <c>false</c>.</returns>
      <remarks>The implementation of this method is expected to emit an error message (see 
            <see cref="T:PostSharp.Extensibility.MessageSource" />) or an exception in case of error. Returning <c>false</c> without emitting an
            error message or exception causes the aspect to be silently ignored.</remarks>
    </member>
    <member name="M:PostSharp.Aspects.FieldLevelAspect.CompileTimeValidate(System.Object)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.FieldLevelAspect.CompileTimeInitialize(System.Reflection.FieldInfo,PostSharp.Aspects.AspectInfo)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.FieldLevelAspect.SetAspectConfiguration(PostSharp.Aspects.AspectConfiguration,System.Reflection.FieldInfo)">
      <summary>
            Method invoked at build time to set up an <see cref="T:PostSharp.Aspects.AspectConfiguration" /> object according to the current 
            <see cref="T:PostSharp.Aspects.Aspect" /> instance and a specified target element of the current aspect.
            </summary>
      <param name="aspectConfiguration">The <see cref="T:PostSharp.Aspects.AspectConfiguration" /> instance previously returned  by the
            <see cref="M:PostSharp.Aspects.Aspect.CreateAspectConfiguration" /> method.</param>
      <param name="targetField">Field to which the current aspect has been applied.</param>
      <remarks>
        <para>Classes overriding this method must always invoke the base implementation before performing their own
            changes to the 
            <see cref="T:PostSharp.Aspects.AspectConfiguration" />.</para>
      </remarks>
    </member>
    <member name="M:PostSharp.Aspects.FieldLevelAspect.SetAspectConfiguration(PostSharp.Aspects.AspectConfiguration,System.Object)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.FieldLevelAspect.RuntimeInitialize(System.Reflection.FieldInfo)">
      <inheritdoc />
    </member>
    <member name="T:PostSharp.Aspects.FlowBehavior">
      <summary>
            Enumerates the possible behaviors of the calling method after the calling method has returned.
            </summary>
      <remarks>
            This enumeration is used by the <see cref="T:PostSharp.Aspects.MethodExecutionArgs" /> class.
            </remarks>
    </member>
    <member name="F:PostSharp.Aspects.FlowBehavior.Default">
      <summary>
            Default flow behavior for the current method. For <b>OnEntry</b> or <b>OnExit</b>, the fault flow is
            <see cref="F:PostSharp.Aspects.FlowBehavior.Continue" />, for <b>OnException</b> it is <see cref="F:PostSharp.Aspects.FlowBehavior.RethrowException" />.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.FlowBehavior.Continue">
      <summary>
            Continue normally (in an <b>OnException</b> advice, does not rethrow the exception).
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.FlowBehavior.RethrowException">
      <summary>
            The current exception will be rethrown. Available only for <b>OnException</b>.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.FlowBehavior.Return">
      <summary>
            Return immediately from the current method. Available only for <b>OnEntry</b> and
            <b>OnException</b>. Note that you may want to set the <see cref="P:PostSharp.Aspects.MethodExecutionArgs.ReturnValue" />
            property, otherwise you may get a <see cref="T:System.NullReferenceException" />.
            </summary>
    </member>
    <member name="T:PostSharp.Aspects.AspectConfiguration">
      <summary>
            Configuration of an <see cref="T:PostSharp.Aspects.IAspect" />.
            </summary>
      <remarks>
            Every concrete aspect class has a corresponding configuration class derived from <see cref="T:PostSharp.Aspects.AspectConfiguration" />.
            </remarks>
    </member>
    <member name="P:PostSharp.Aspects.AspectConfiguration.AspectPriority">
      <summary>
            Gets or sets the aspect priority. Aspects with smaller priority are processed first. The default priority is zero.
            </summary>
      <remarks>
            Whenever possible, use dependencies (<see cref="P:PostSharp.Aspects.AspectConfiguration.Dependencies" /> collection) to specify the ordering of aspects.
            Unlike priorities, dependencies scale up in complexity, which can be important in larger projects.
            </remarks>
    </member>
    <member name="P:PostSharp.Aspects.AspectConfiguration.SerializerType">
      <summary>
            Gets or sets the type of the serializer that will be used
            to configure the current aspect. 
            </summary>
      <remarks>
            This type should have derive from <see cref="T:PostSharp.Aspects.Serialization.AspectSerializer" />
            and have a default constructor. Use <c>null</c> to specify that the aspect will not
            be serialized, but will be constructed using MSIL instructions.
            </remarks>
    </member>
    <member name="P:PostSharp.Aspects.AspectConfiguration.Dependencies">
      <summary>
            Gets or sets the collection of dependencies.
            </summary>
    </member>
    <member name="T:PostSharp.Aspects.IAspectProvider">
      <summary>
            Interface that, when implemented by an aspect class, allows aspect instances
            to provide other aspects to the weaver.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.IAspectProvider.ProvideAspects(System.Object)">
      <summary>
            Provides new aspects.
            </summary>
      <param name="targetElement">Code element (<see cref="T:System.Runtime.InteropServices._Assembly" />, <see cref="T:System.Type" />, 
            <see cref="T:System.Reflection.FieldInfo" />, <see cref="T:System.Reflection.MethodBase" />, <see cref="T:System.Reflection.PropertyInfo" />, <see cref="T:System.Reflection.EventInfo" />, 
            <see cref="T:System.Reflection.ParameterInfo" />, or <see cref="T:PostSharp.Reflection.LocationInfo" />) to which the current aspect has been applied.
            </param>
    </member>
    <member name="T:PostSharp.Aspects.IComposed`1">
      <summary>
            Interface exposing the implementation of another interface introduced
            by a <see cref="T:PostSharp.Aspects.CompositionAspect" />.
            </summary>
      <typeparam name="T">Interface whose implementation is expose.</typeparam>
    </member>
    <member name="M:PostSharp.Aspects.IComposed`1.GetImplementation(PostSharp.Aspects.InstanceCredentials)">
      <summary>
            Gets the object implementing the interface <typeparamref name="T" />
            on behalf of the current instance.
            </summary>
      <param name="credentials">Credentials provided by the current instance.</param>
      <returns>The object implementing the interface <typeparamref name="T" />
            on behalf of the current instance.
            </returns>
    </member>
    <member name="T:PostSharp.Aspects.CompositionAspectConfiguration">
      <summary>
            Configuration of aspects of type <see cref="T:PostSharp.Aspects.ICompositionAspect" />.
            </summary>
      <seealso cref="T:PostSharp.Aspects.CompositionAspectConfigurationAttribute" />
    </member>
    <member name="P:PostSharp.Aspects.CompositionAspectConfiguration.PublicInterfaces">
      <summary>
            Gets or sets the array of interfaces that should be introduced publicly into the target type of the aspect.
            </summary>
    </member>
    <member name="P:PostSharp.Aspects.CompositionAspectConfiguration.ProtectedInterfaces">
      <summary>
            Gets or sets the array of interfaces to be introduced indirectly into the target type of the aspect. These
            interfaces will become accessible through the <see cref="T:PostSharp.Aspects.IProtectedInterface`1" /> interface.
            </summary>
    </member>
    <member name="P:PostSharp.Aspects.CompositionAspectConfiguration.OverrideAction">
      <summary>
            Specifies the action (<see cref="F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Fail" /> or <see cref="F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Ignore" />)
            to be overtaken when one of the interfaces specified by <see cref="P:PostSharp.Aspects.CompositionAspectConfiguration.PublicInterfaces" /> or <see cref="P:PostSharp.Aspects.CompositionAspectConfiguration.ProtectedInterfaces" />
            is already implemented by the type to which the aspect is applied.
            </summary>
      <seealso cref="P:PostSharp.Aspects.CompositionAspectConfiguration.AncestorOverrideAction" />
    </member>
    <member name="P:PostSharp.Aspects.CompositionAspectConfiguration.AncestorOverrideAction">
      <summary>
            Specifies the action (<see cref="F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Fail" /> or <see cref="F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Ignore" />)
            to be overtaken when an <i>ancestor</i> of one of the interfaces specified by <see cref="P:PostSharp.Aspects.CompositionAspectConfiguration.PublicInterfaces" />
            is already implemented by the type to which the current aspect is applied.
            </summary>
      <seealso cref="P:PostSharp.Aspects.CompositionAspectConfiguration.OverrideAction" />
    </member>
    <member name="P:PostSharp.Aspects.CompositionAspectConfiguration.NonSerializedImplementation">
      <summary>
            Determines whether the field containing the interface implementation (and storing the object returned by
            <see cref="M:PostSharp.Aspects.ICompositionAspect.CreateImplementationObject(PostSharp.Aspects.AspectArgs)" />) should be excluded from serialization by <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter" />.
            The same effect is typically obtained by applying the <see cref="T:System.NonSerializedAttribute" /> custom attribute to the field.
            </summary>
    </member>
    <member name="P:PostSharp.Aspects.CompositionAspectConfiguration.GenerateImplementationAccessor">
      <summary>
            Determines whether the interface <see cref="T:PostSharp.Aspects.IComposed`1" /> should be introduced into the type to which the aspect
            is applied for each interface specified by the <see cref="P:PostSharp.Aspects.CompositionAspectConfiguration.PublicInterfaces" /> property.
            </summary>
    </member>
    <member name="T:PostSharp.Aspects.CompositionAspectConfigurationAttribute">
      <summary>
            Custom attribute that, when applied on a class implementing <see cref="T:PostSharp.Aspects.ICompositionAspect" />,
            defines the declarative configuration of that aspect.
            </summary>
      <seealso cref="T:PostSharp.Aspects.AspectConfigurationAttribute" />
      <seealso cref="T:PostSharp.Aspects.ICompositionAspect" />
    </member>
    <member name="P:PostSharp.Aspects.CompositionAspectConfigurationAttribute.PublicInterfaces">
      <summary>
            Gets or sets the array of type names of interfaces that should be introduced publicly into
            the target type of the aspect.
            </summary>
    </member>
    <member name="P:PostSharp.Aspects.CompositionAspectConfigurationAttribute.ProtectedInterfaces">
      <summary>
            Gets or sets the array of type names of interfaces to be introduced indirectly into the target type of the aspect. These
            interfaces will become accessible through the <see cref="T:PostSharp.Aspects.IProtectedInterface`1" /> interface.
            </summary>
    </member>
    <member name="P:PostSharp.Aspects.CompositionAspectConfigurationAttribute.OverrideAction">
      <summary>
            Specifies the action (<see cref="F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Fail" /> or <see cref="F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Ignore" />)
            to be overtaken when one of the interfaces specified by <see cref="P:PostSharp.Aspects.CompositionAspectConfigurationAttribute.PublicInterfaces" /> or <see cref="P:PostSharp.Aspects.CompositionAspectConfigurationAttribute.ProtectedInterfaces" />
            is already implemented by the type to which the aspect is applied.
            </summary>
      <seealso cref="P:PostSharp.Aspects.CompositionAspectConfigurationAttribute.AncestorOverrideAction" />
    </member>
    <member name="P:PostSharp.Aspects.CompositionAspectConfigurationAttribute.AncestorOverrideAction">
      <summary>
            Specifies the action (<see cref="F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Fail" /> or <see cref="F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Ignore" />)
            to be overtaken when an <i>ancestor</i> of one of the interfaces specified by <see cref="P:PostSharp.Aspects.CompositionAspectConfigurationAttribute.PublicInterfaces" />
            is already implemented by the type to which the current aspect is applied.
            </summary>
      <seealso cref="P:PostSharp.Aspects.CompositionAspectConfigurationAttribute.OverrideAction" />
    </member>
    <member name="P:PostSharp.Aspects.CompositionAspectConfigurationAttribute.NonSerializedImplementation">
      <summary>
            Determines whether the field containing the interface implementation (and storing the object returned by
            <see cref="M:PostSharp.Aspects.ICompositionAspect.CreateImplementationObject(PostSharp.Aspects.AspectArgs)" />) should be excluded from serialization by <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter" />.
            The same effect is typically obtained by applying the <see cref="T:System.NonSerializedAttribute" /> custom attribute to the field.
            </summary>
    </member>
    <member name="P:PostSharp.Aspects.CompositionAspectConfigurationAttribute.GenerateImplementationAccessor">
      <summary>
            Determines whether the interface <see cref="T:PostSharp.Aspects.IComposed`1" /> should be introduced into the type to which the aspect
            is applied for each interface specified by the <see cref="P:PostSharp.Aspects.CompositionAspectConfigurationAttribute.PublicInterfaces" /> property.
            </summary>
    </member>
    <member name="T:PostSharp.Aspects.ICustomAttributeIntroductionAspect">
      <summary>
            Semantics of an aspect that, when applied to a target, adds a custom attribute to this target.
            </summary>
      <remarks>
            This aspect operates purely on metadata and has no runtime semantic at all. Therefore, it is essential
            to provide a <see cref="T:PostSharp.Aspects.CustomAttributeIntroductionAspectConfiguration" /> and to set the
            <see cref="P:PostSharp.Aspects.CustomAttributeIntroductionAspectConfiguration.ObjectConstruction" /> property.
            </remarks>
    </member>
    <member name="T:PostSharp.Aspects.CustomAttributeIntroductionAspectConfiguration">
      <summary>
            Configuration of aspects of type <see cref="T:PostSharp.Aspects.ICustomAttributeIntroductionAspect" />.
            </summary>
    </member>
    <member name="P:PostSharp.Aspects.CustomAttributeIntroductionAspectConfiguration.ObjectConstruction">
      <summary>
            Gets or sets the construction of the custom attribute that must be applied to the target of this aspect.
            </summary>
    </member>
    <member name="T:PostSharp.Aspects.CustomAttributeIntroductionAspect">
      <summary>
            Aspect that, when applied to a target, adds a custom attribute to this target.
            </summary>
      <remarks>
        <note>
      All classes implementing
      <see cref="T:PostSharp.Aspects.IAspect" />
      should typically be marked as serializable
      using the
      <see cref="T:System.SerializableAttribute" />
      custom attribute. Fields that
      are only used at runtime (and unknown at compile-time) should be carefully
      marked with the
      <see cref="T:System.NonSerializedAttribute" />
      custom attribute.
      When PostSharp is used on a platform that does not support aspect serialization
      (such as .NET Compact Framework, Silverlight, or Windows Phone), or when
      another aspect serializer is used, it is not necessary to mark the aspect
      class as serializable.
      For more information, see
      <see href="../../UserGuide/Aspects/Advanced/Serialization.html">Aspect Serialization</see>
      .
    </note>
        <seealso href="../../UserGuide/Aspects/Advanced/Serialization.html">Aspect Serialization</seealso>
      </remarks>
    </member>
    <member name="M:PostSharp.Aspects.CustomAttributeIntroductionAspect.#ctor(PostSharp.Reflection.ObjectConstruction)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Aspects.CustomAttributeIntroductionAspect" />.
            </summary>
      <param name="attribute">Construction of the custom attribute to be added to the target.</param>
    </member>
    <member name="P:PostSharp.Aspects.CustomAttributeIntroductionAspect.CustomAttribute">
      <summary>
            Gets the construction of the custom attribute that must be applied to the target of this aspect.
            </summary>
    </member>
    <member name="T:PostSharp.Aspects.IEventBinding">
      <summary>
            Interface through which an event-level aspect or advice can
            invoke the next node in the chain of invocation.
            </summary>
      <seealso cref="T:PostSharp.Aspects.Advices.ImportMemberAttribute" />
    </member>
    <member name="M:PostSharp.Aspects.IEventBinding.AddHandler(System.Object@,System.Delegate)">
      <summary>
            Invoke the <b>Add Event Handler</b> semantic on the next node in the chain of invocation.
            </summary>
      <param name="instance">Target instance on which the event is defined (<c>null</c> if the event is static).</param>
      <param name="handler">Handler to be added to the event.</param>
      <remarks>
        <para>
      The
      <paramref name="instance" />
      parameter is passed by reference so that instance methods of value types (
      <c>struct</c>
      in C#) are allowed to change the value of the instance.
    </para>
      </remarks>
    </member>
    <member name="M:PostSharp.Aspects.IEventBinding.RemoveHandler(System.Object@,System.Delegate)">
      <summary>
            Invoke the <b>Remove Event Handler</b> semantic on the next node in the chain of invocation.
            </summary>
      <param name="instance">Target instance on which the event is defined (<c>null</c> if the event is static).</param>
      <param name="handler">Handler to be removed from the event.</param>
      <remarks>
        <para>
      The
      <paramref name="instance" />
      parameter is passed by reference so that instance methods of value types (
      <c>struct</c>
      in C#) are allowed to change the value of the instance.
    </para>
      </remarks>
    </member>
    <member name="M:PostSharp.Aspects.IEventBinding.InvokeHandler(System.Object@,System.Delegate,PostSharp.Aspects.Arguments)">
      <summary>
            Invoke the <b>Invoke Event Handler</b> semantic on the next node in the chain of invocation.
            </summary>
      <param name="instance">Target instance on which the event is defined (<c>null</c> if the event is static).</param>
      <param name="handler">Handler to be removed from the event.</param>
      <param name="arguments">Arguments with which the <paramref name="handler" /> should be invoked.</param>
      <remarks>
        <para>
      The
      <paramref name="instance" />
      parameter is passed by reference so that instance methods of value types (
      <c>struct</c>
      in C#) are allowed to change the value of the instance.
    </para>
        <br />
        <note>
      The
      <b>Invoke Event Handler</b>
      semantic is different from normal event firing.
      Indeed, when you fire an event, all handlers that were added to this event are fired. However, the current method
      invokes only a single handler: the one passed to the
      <c>handler</c>
      parameter.
    </note>
      </remarks>
    </member>
    <member name="T:PostSharp.Aspects.EventInterceptionAspectConfigurationAttribute">
      <summary>
            Custom attribute that, when applied on a class implementing <see cref="T:PostSharp.Aspects.IEventInterceptionAspect" />,
            defines the declarative configuration of that aspect.
            </summary>
      <seealso cref="T:PostSharp.Aspects.EventInterceptionAspectConfiguration" />
      <seealso cref="T:PostSharp.Aspects.IEventInterceptionAspect" />
    </member>
    <member name="T:PostSharp.Aspects.EventInterceptionAspectConfiguration">
      <summary>
            Configuration of aspects of type <see cref="T:PostSharp.Aspects.IEventInterceptionAspect" />.
            </summary>
      <seealso cref="T:PostSharp.Aspects.EventInterceptionAspectConfigurationAttribute" />
    </member>
    <member name="T:PostSharp.Aspects.ExternalAspectConfiguration">
      <summary>
            Configuration of aspects of type <see cref="T:PostSharp.Aspects.IExternalAspect" />.
            </summary>
    </member>
    <member name="P:PostSharp.Aspects.ExternalAspectConfiguration.ImplementationTypeName">
      <summary>
            Gets or sets the type implementing the aspect. This type must implement the interface <see cref="T:PostSharp.Aspects.IExternalAspectImplementation" />.
            </summary>
    </member>
    <member name="T:PostSharp.Aspects.ExternalAspectConfigurationAttribute">
      <summary>
            Specifies the type name of the implementation of external aspects (<see cref="T:PostSharp.Aspects.IExternalAspect" />).
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.ExternalAspectConfigurationAttribute.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Aspects.ExternalAspectConfigurationAttribute" />.
            In user code, use the <see cref="M:PostSharp.Aspects.ExternalAspectConfigurationAttribute.#ctor(System.String)" />
            constructor instead of this one.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.ExternalAspectConfigurationAttribute.#ctor(System.String)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Aspects.ExternalAspectConfigurationAttribute" />.
            </summary>
      <param name="implementationTypeName">Assembly-qualified name of the implementation
            type. This type should implement the <see cref="T:PostSharp.Aspects.IExternalAspectImplementation" />
            interface.</param>
    </member>
    <member name="P:PostSharp.Aspects.ExternalAspectConfigurationAttribute.ImplementationTypeName">
      <summary>
            Gets the assembly-qualified name of the implementation  type.
            This type must implement the <see cref="T:PostSharp.Aspects.IExternalAspectImplementation" /> interface.
            </summary>
    </member>
    <member name="T:PostSharp.Aspects.IExternalAspectImplementation">
      <summary>
            Implementation of an <see cref="T:PostSharp.Aspects.IExternalAspect" />.
            </summary>
      <remarks>
            Classes implementing this interface are instantiated in the post-compiler and are executed against the full .NET Framework.
            However, when processing a Silverlight or Compact Framework project, classes of this project cannot be instantiated in the
            post-compiler, neither can code be executed. Therefore, all aspects should be represented as object constructions 
            (<see cref="T:PostSharp.Reflection.ObjectConstruction" />), and not aspect instances themselves.
            </remarks>
    </member>
    <member name="M:PostSharp.Aspects.IExternalAspectImplementation.ProvideImplementationAspects(System.Object,PostSharp.Reflection.ObjectConstruction)">
      <summary />
      <param name="target">Code element (<see cref="T:System.Type" />, <see cref="T:System.Reflection.FieldInfo" />, <see cref="T:System.Reflection.MethodInfo" />,
            <see cref="T:System.Reflection.ConstructorInfo" />, <see cref="T:System.Reflection.ParameterInfo" />, ...) on which the
            aspect is applied.</param>
      <param name="aspectConstruction">Representation of the aspect instance (implementing <see cref="T:PostSharp.Aspects.IExternalAspect" />)
            requiring external implementation.</param>
    </member>
    <member name="T:PostSharp.Aspects.IImplementMethodAspect">
      <summary>
            Runtime semantics of an aspect that implements methods without previous
            implementations, like <b>abstract</b> or <b>external</b> methods.
            </summary>
      <seealso cref="T:PostSharp.Aspects.ImplementMethodAspect" />
      <seealso cref="T:PostSharp.Aspects.ImplementMethodAspectConfiguration" />
      <seealso cref="T:PostSharp.Aspects.ImplementMethodAspectConfigurationAttribute" />
    </member>
    <member name="T:PostSharp.Aspects.IMethodLevelAspect">
      <summary>
            Runtime semantics of aspects applied to methods.
            </summary>
      <seealso cref="T:PostSharp.Aspects.IMethodLevelAspectBuildSemantics" />
    </member>
    <member name="M:PostSharp.Aspects.IMethodLevelAspect.RuntimeInitialize(System.Reflection.MethodBase)">
      <summary>
            Initializes the current aspect.
            </summary>
      <param name="method">Method to which the current aspect is applied.</param>
    </member>
    <member name="M:PostSharp.Aspects.IImplementMethodAspect.OnExecution(PostSharp.Aspects.MethodExecutionArgs)">
      <summary>
            Method invoked instead of the body of the modified method.
            </summary>
      <param name="eventArgs">Event arguments specifying which method is being
            executed, on which object instance and with which parameters.</param>
      <remarks>
        <para>
            The implementation is allowed to modify output arguments passed in the <paramref name="eventArgs" />
            array, but it is required to respect argument types (otherwise an <see cref="T:System.InvalidCastException" />
            will be thrown at runtime).
            </para>
      </remarks>
    </member>
    <member name="T:PostSharp.Aspects.ImplementMethodAspectConfiguration">
      <summary>
            Configuration of aspects of type <see cref="T:PostSharp.Aspects.IImplementMethodAspect" />.
            </summary>
      <seealso cref="T:PostSharp.Aspects.ImplementMethodAspectConfigurationAttribute" />
    </member>
    <member name="T:PostSharp.Aspects.ImplementMethodAspectConfigurationAttribute">
      <summary>
            Custom attribute that, when applied on a class implementing <see cref="T:PostSharp.Aspects.IImplementMethodAspect" />,
            defines the declarative configuration of that aspect.
            </summary>
      <seealso cref="T:PostSharp.Aspects.ImplementMethodAspectConfiguration" />
      <seealso cref="T:PostSharp.Aspects.IImplementMethodAspect" />
    </member>
    <member name="T:PostSharp.Aspects.IInstanceLevelAspect">
      <summary>
            Runtime semantics of aspects applied on types, but having the same lifetime as <i>instances</i>
            of this type.
            </summary>
      <remarks>This interface is defined for convenience but does not define any semantic. Implementing
            both interfaces <see cref="T:PostSharp.Aspects.ITypeLevelAspect" /> and <see cref="T:PostSharp.Aspects.IInstanceScopedAspect" /> is strictly
            equivalent to implementing the <see cref="T:PostSharp.Aspects.IInstanceLevelAspect" /> interface.</remarks>
    </member>
    <member name="T:PostSharp.Aspects.IInstanceScopedAspect">
      <summary>
            Runtime semantics of aspects that have the same lifetime as <i>instance</i> of types
            to which their are applied (or instance of the declaring type of members to which they are applied).
            </summary>
      <remarks>
        <para>When an aspect is instance-scoped, a new instance of this aspect is created whenever an instance of the
            type to which it has been applied is created (concretely, before the call to the base constructor and the own constructor of this type).</para>
        <para>New aspect instances are obtained using the <b>prototype</b> design pattern. As any other aspect, an instance-scope aspect
            has a static instance initialized at build time, then serialized, deserialized at runtime, and initialized by <b>RuntimeInitialize</b>.
            This static instance then serves as a <i>prototype</i>.  When a new instance of the target type is created, the prototype is cloned
            by the method <see cref="M:PostSharp.Aspects.IInstanceScopedAspect.CreateInstance(PostSharp.Aspects.AspectArgs)" /> (typically implemented by a call to <see cref="M:System.Object.MemberwiseClone" />). Then some system
            initializations (for instance member import) are performed on the aspect instance, and finally the <see cref="M:PostSharp.Aspects.IInstanceScopedAspect.RuntimeInitializeInstance" />
            method is invoked.
            </para>
        <para>When an aspect implementing the <see cref="T:PostSharp.Aspects.IInstanceScopedAspect" /> interface is applied on a static method, field, property, or event,
            the aspect will be statically scoped and the interface will be ignored.</para>
      </remarks>
    </member>
    <member name="M:PostSharp.Aspects.IInstanceScopedAspect.CreateInstance(PostSharp.Aspects.AspectArgs)">
      <summary>
            Creates a new instance of the aspect based on the current instance, serving as a prototype.
            </summary>
      <param name="aspectArgs">Aspect arguments.</param>
      <returns>A new instance of the aspect, typically a clone of the current prototype instance.</returns>
      <remarks>
            This method is typically implemented by invoking <see cref="M:System.Object.MemberwiseClone" />.
            </remarks>
    </member>
    <member name="M:PostSharp.Aspects.IInstanceScopedAspect.RuntimeInitializeInstance">
      <summary>
            Initializes the aspect instance. This method is invoked when all system elements of the aspect (like member imports)
            have completed.
            </summary>
    </member>
    <member name="T:PostSharp.Aspects.ILocationBinding">
      <summary>
            Interface through which a field- or property-level aspect or advice can
            invoke the next node in the chain of invocation.
            </summary>
      <seealso cref="T:PostSharp.Aspects.Advices.ImportMemberAttribute" />
    </member>
    <member name="M:PostSharp.Aspects.ILocationBinding.GetValue(System.Object@,PostSharp.Aspects.Arguments)">
      <summary>
            Invokes the <b>Get Location Value</b> semantic on the next node in the chain of invocation.
            </summary>
      <param name="instance">Target instance from which the field or property should be retrieved (<c>null</c> if the field or property is static).</param>
      <param name="index">Index arguments, if the location is an indexer property.</param>
      <returns>The value stored at the location.</returns>
      <remarks>
        <para>
      The
      <paramref name="instance" />
      parameter is passed by reference so that instance methods of value types (
      <c>struct</c>
      in C#) are allowed to change the value of the instance.
    </para>
      </remarks>
    </member>
    <member name="M:PostSharp.Aspects.ILocationBinding.SetValue(System.Object@,PostSharp.Aspects.Arguments,System.Object)">
      <summary>
            Invokes the <b>Set Location Value</b> semantic on the next node in the chain of invocation.
            </summary>
      <param name="instance">Target instance from which the field or property should be retrieved (<c>null</c> if the field or property is static).</param>
      <param name="index">Index arguments, if the location is an indexer property.</param>
      <param name="value">New value to be stored at the location.</param>
      <remarks>
        <para>
      The
      <paramref name="instance" />
      parameter is passed by reference so that instance methods of value types (
      <c>struct</c>
      in C#) are allowed to change the value of the instance.
    </para>
      </remarks>
    </member>
    <member name="T:PostSharp.Aspects.ILocationInterceptionAspect">
      <summary>
            Runtime semantics of an aspect that, when applied on a location (field or property), intercepts invocations of
            the <c>Get</c> (<see cref="M:PostSharp.Aspects.ILocationInterceptionAspect.OnGetValue(PostSharp.Aspects.LocationInterceptionArgs)" />) and <c>Set</c> (<see cref="M:PostSharp.Aspects.ILocationInterceptionAspect.OnSetValue(PostSharp.Aspects.LocationInterceptionArgs)" />) semantics.
            </summary>
      <see cref="T:PostSharp.Aspects.LocationInterceptionAspect" />
      <see cref="T:PostSharp.Aspects.LocationInterceptionAspectConfiguration" />
      <see cref="T:PostSharp.Aspects.LocationInterceptionAspectConfigurationAttribute" />
    </member>
    <member name="T:PostSharp.Aspects.ILocationLevelAspect">
      <summary>
            Runtime semantics of aspects defined on a field, property, or parameter.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.ILocationLevelAspect.RuntimeInitialize(PostSharp.Reflection.LocationInfo)">
      <summary>
            Initializes the current aspect.
            </summary>
      <param name="locationInfo">Location to which the current aspect is applied.</param>
    </member>
    <member name="M:PostSharp.Aspects.ILocationInterceptionAspect.OnGetValue(PostSharp.Aspects.LocationInterceptionArgs)">
      <summary>
            Method invoked <i>instead</i> of the <c>Get</c> semantic of the field or property to which the current aspect is applied,
            i.e. when the value of this field or property is retrieved.
            </summary>
      <param name="args">Advice arguments.</param>
    </member>
    <member name="M:PostSharp.Aspects.ILocationInterceptionAspect.OnSetValue(PostSharp.Aspects.LocationInterceptionArgs)">
      <summary>
            Method invoked <i>instead</i> of the <c>Set</c> semantic of the field or property to which the current aspect is applied,
            i.e. when the value of this field or property is changed.
            </summary>
      <param name="args">Advice arguments.</param>
    </member>
    <member name="T:PostSharp.Aspects.LocationInterceptionAspectConfiguration">
      <summary>
            Configuration of aspects of type <see cref="T:PostSharp.Aspects.ILocationLevelAspect" />.
            </summary>
    </member>
    <member name="T:PostSharp.Aspects.LocationInterceptionAspectConfigurationAttribute">
      <summary>
            Custom attribute that, when applied on a class implementing <see cref="T:PostSharp.Aspects.ILocationInterceptionAspect" />,
            defines the declarative configuration of that aspect.
            </summary>
      <seealso cref="T:PostSharp.Aspects.LocationInterceptionAspectConfiguration" />
      <seealso cref="T:PostSharp.Aspects.ILocationLevelAspect" />
    </member>
    <member name="T:PostSharp.Aspects.ILocationLevelAspectBuildSemantics">
      <summary>
            Compile-time semantics of <see cref="T:PostSharp.Aspects.IMethodLevelAspect" />.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.ILocationLevelAspectBuildSemantics.CompileTimeInitialize(PostSharp.Reflection.LocationInfo,PostSharp.Aspects.AspectInfo)">
      <summary>
            Method invoked at build time to initialize the instance fields of the current aspect. This method is invoked
            before any other build-time method.
            </summary>
      <param name="location">Location to which the current aspect is applied</param>
      <param name="aspectInfo">Reserved for future usage.</param>
    </member>
    <member name="T:PostSharp.Aspects.IMethodBinding">
      <summary>
            Interface through which a method-level aspect or advice can
            invoke the next node in the chain of invocation.
            </summary>
      <seealso cref="T:PostSharp.Aspects.Advices.ImportMemberAttribute" />
    </member>
    <member name="M:PostSharp.Aspects.IMethodBinding.Invoke(System.Object@,PostSharp.Aspects.Arguments)">
      <summary>
            Invokes the next node in the chain of invocation.
            </summary>
      <param name="instance">Target instance on which the method should be invoked (<c>null</c> if the method is static).</param>
      <param name="arguments">Method arguments.</param>
      <returns>Return value of the method.</returns>
      <remarks>
        <para>
      The
      <paramref name="instance" />
      parameter is passed by reference so that instance methods of value types (
      <c>struct</c>
      in C#) are allowed to change the value of the instance.
    </para>
      </remarks>
    </member>
    <member name="T:PostSharp.Aspects.IMethodInterceptionAspect">
      <summary>
            Runtime semantics of an aspect that, when applied on a method, intercepts invocations of this method.
            </summary>
      <see cref="T:PostSharp.Aspects.MethodInterceptionAspect" />
      <see cref="T:PostSharp.Aspects.MethodInterceptionAspectConfiguration" />
      <see cref="T:PostSharp.Aspects.MethodInterceptionAspectConfigurationAttribute" />
    </member>
    <member name="M:PostSharp.Aspects.IMethodInterceptionAspect.OnInvoke(PostSharp.Aspects.MethodInterceptionArgs)">
      <summary>
            Method invoked <i>instead</i> of the method to which the aspect has been applied.
            </summary>
      <param name="args">Advice arguments.</param>
    </member>
    <member name="T:PostSharp.Aspects.MethodInterceptionAspectConfiguration">
      <summary>
            Configuration of aspects of type <see cref="T:PostSharp.Aspects.IMethodInterceptionAspect" />.
            </summary>
      <seealso cref="T:PostSharp.Aspects.MethodInterceptionAspectConfigurationAttribute" />
      <seealso cref="T:PostSharp.Aspects.IMethodInterceptionAspect" />
    </member>
    <member name="T:PostSharp.Aspects.MethodInterceptionAspectConfigurationAttribute">
      <summary>
            Custom attribute that, when applied on a class implementing <see cref="T:PostSharp.Aspects.IMethodInterceptionAspect" />,
            defines the declarative configuration of that aspect.
            </summary>
      <seealso cref="T:PostSharp.Aspects.IMethodInterceptionAspect" />
      <seealso cref="T:PostSharp.Aspects.MethodInterceptionAspectConfiguration" />
    </member>
    <member name="T:PostSharp.Aspects.IMethodLevelAspectBuildSemantics">
      <summary>
            Compile-time semantics of <see cref="T:PostSharp.Aspects.IMethodLevelAspect" />.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.IMethodLevelAspectBuildSemantics.CompileTimeInitialize(System.Reflection.MethodBase,PostSharp.Aspects.AspectInfo)">
      <summary>
            Method invoked at build time to initialize the instance fields of the current aspect. This method is invoked
            before any other build-time method.
            </summary>
      <param name="method">Method to which the current aspect is applied</param>
      <param name="aspectInfo">Reserved for future usage.</param>
    </member>
    <member name="T:PostSharp.Aspects.ImplementMethodAspect">
      <summary>
            Aspect that, when applied to a method defined in the current assembly,
            replaces the implementation of this method by a call to the current custom
            attribute. This aspect is useful to implement <c>extern</c> or <c>abstract</c>
            methods using an aspect.
            </summary>
      <remarks>
        <note>
      All classes implementing
      <see cref="T:PostSharp.Aspects.IAspect" />
      should typically be marked as serializable
      using the
      <see cref="T:System.SerializableAttribute" />
      custom attribute. Fields that
      are only used at runtime (and unknown at compile-time) should be carefully
      marked with the
      <see cref="T:System.NonSerializedAttribute" />
      custom attribute.
      When PostSharp is used on a platform that does not support aspect serialization
      (such as .NET Compact Framework, Silverlight, or Windows Phone), or when
      another aspect serializer is used, it is not necessary to mark the aspect
      class as serializable.
      For more information, see
      <see href="../../UserGuide/Aspects/Advanced/Serialization.html">Aspect Serialization</see>
      .
    </note>
        <seealso href="../../UserGuide/Aspects/Advanced/Serialization.html">Aspect Serialization</seealso>
      </remarks>
    </member>
    <member name="T:PostSharp.Aspects.MethodLevelAspect">
      <summary>
            Base class for all aspects applied on methods.
            </summary>
      <seealso cref="T:PostSharp.Aspects.IMethodLevelAspect" />
      <remarks>
        <note>
      This class does not provide any advice. You may derive your aspect class from a
      <see href="../../UserGuide/Aspects/AspectKinds/Overview.html">
        class providing
        predefined advice
      </see>
      , or build a
      <see href="../../UserGuide/Aspects/CompositeAspects/Overview.html">composite aspect</see>
      .
    </note>
        <seealso href="../../UserGuide/Aspects/AspectKinds/Overview.html">Aspect Kinds</seealso>
        <seealso href="../../UserGuide/Aspects/CompositeAspects/Overview.html">Composite Aspects</seealso>
        <br />
        <note>
      All classes implementing
      <see cref="T:PostSharp.Aspects.IAspect" />
      should typically be marked as serializable
      using the
      <see cref="T:System.SerializableAttribute" />
      custom attribute. Fields that
      are only used at runtime (and unknown at compile-time) should be carefully
      marked with the
      <see cref="T:System.NonSerializedAttribute" />
      custom attribute.
      When PostSharp is used on a platform that does not support aspect serialization
      (such as .NET Compact Framework, Silverlight, or Windows Phone), or when
      another aspect serializer is used, it is not necessary to mark the aspect
      class as serializable.
      For more information, see
      <see href="../../UserGuide/Aspects/Advanced/Serialization.html">Aspect Serialization</see>
      .
    </note>
        <seealso href="../../UserGuide/Aspects/Advanced/Serialization.html">Aspect Serialization</seealso>
      </remarks>
    </member>
    <member name="M:PostSharp.Aspects.MethodLevelAspect.CompileTimeValidate(System.Reflection.MethodBase)">
      <summary>
            Method invoked at build time to ensure that the aspect has been applied to the right target.
            </summary>
      <param name="method">Method to which the aspect has been applied</param>
      <returns>
        <c>true</c> if the aspect was applied to an acceptable field, otherwise
            <c>false</c>.</returns>
      <remarks>The implementation of this method is expected to emit an error message (see 
            <see cref="T:PostSharp.Extensibility.MessageSource" />) or an exception in case of error. Returning <c>false</c> without emitting an
            error message or exception causes the aspect to be silently ignored.</remarks>
    </member>
    <member name="M:PostSharp.Aspects.MethodLevelAspect.CompileTimeValidate(System.Object)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.MethodLevelAspect.CompileTimeInitialize(System.Reflection.MethodBase,PostSharp.Aspects.AspectInfo)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.MethodLevelAspect.SetAspectConfiguration(PostSharp.Aspects.AspectConfiguration,System.Reflection.MethodBase)">
      <summary>
            Method invoked at build time to set up an <see cref="T:PostSharp.Aspects.AspectConfiguration" /> object according to the current 
            <see cref="T:PostSharp.Aspects.Aspect" /> instance and a specified target element of the current aspect.
            </summary>
      <param name="aspectConfiguration">The <see cref="T:PostSharp.Aspects.AspectConfiguration" /> instance previously returned  by the
            <see cref="M:PostSharp.Aspects.Aspect.CreateAspectConfiguration" /> method.</param>
      <param name="targetMethod">Method to which the current aspect has been applied.</param>
      <remarks>
        <para>Classes overriding this method must always invoke the base implementation before performing their own
            changes to the 
            <see cref="T:PostSharp.Aspects.AspectConfiguration" />.</para>
      </remarks>
    </member>
    <member name="M:PostSharp.Aspects.MethodLevelAspect.SetAspectConfiguration(PostSharp.Aspects.AspectConfiguration,System.Object)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.MethodLevelAspect.RuntimeInitialize(System.Reflection.MethodBase)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.ImplementMethodAspect.OnExecution(PostSharp.Aspects.MethodExecutionArgs)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.ImplementMethodAspect.CreateAspectConfiguration">
      <inheritdoc />
    </member>
    <member name="T:PostSharp.Aspects.InstanceCredentials">
      <summary>
            Credentials that give access to 'protected' semantics.
            </summary>
      <remarks>
            A protected semantic is specified by an interface with public visibility, but
            code can only get this interface when it provides the semantics represented
            by the current type. Instance semantics are typically retrieved by an instance
            method <b>GetInstanceCredentials</b>, which has <i>protected</i> visibility.
            This method is implemented by PostSharp Laos automatically.
            </remarks>
    </member>
    <member name="M:PostSharp.Aspects.InstanceCredentials.MakeNew">
      <summary>
            Creates a new <see cref="T:PostSharp.Aspects.InstanceCredentials" />.
            </summary>
      <returns>A new <see cref="T:PostSharp.Aspects.InstanceCredentials" />.</returns>
    </member>
    <member name="F:PostSharp.Aspects.InstanceCredentials.Null">
      <summary>
            Gets a null (or empty) <see cref="T:PostSharp.Aspects.InstanceCredentials" />/
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.InstanceCredentials.Equals(PostSharp.Aspects.InstanceCredentials)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.InstanceCredentials.Equals(System.Object)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.InstanceCredentials.AssertEquals(PostSharp.Aspects.InstanceCredentials)">
      <summary>
            Throws an exception if given credentials are not equal
            to the current one.
            </summary>
      <param name="others">Other credentials.</param>
    </member>
    <member name="M:PostSharp.Aspects.InstanceCredentials.GetHashCode">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.InstanceCredentials.op_Equality(PostSharp.Aspects.InstanceCredentials,PostSharp.Aspects.InstanceCredentials)">
      <summary>
            Determines whether two <see cref="T:PostSharp.Aspects.InstanceCredentials" /> are equal.
            </summary>
      <param name="left">An <see cref="T:PostSharp.Aspects.InstanceCredentials" /> object.</param>
      <param name="right">An <see cref="T:PostSharp.Aspects.InstanceCredentials" /> object.</param>
      <returns>
        <c>true</c> if <paramref name="left" /> equals <paramref name="right" />,
            otherwise <c>false</c>.</returns>
    </member>
    <member name="M:PostSharp.Aspects.InstanceCredentials.op_Inequality(PostSharp.Aspects.InstanceCredentials,PostSharp.Aspects.InstanceCredentials)">
      <summary>
            Determines whether two <see cref="T:PostSharp.Aspects.InstanceCredentials" /> are different.
            </summary>
      <param name="left">An <see cref="T:PostSharp.Aspects.InstanceCredentials" /> object.</param>
      <param name="right">An <see cref="T:PostSharp.Aspects.InstanceCredentials" /> object.</param>
      <returns>
        <c>true</c> if <paramref name="left" /> is different than <paramref name="right" />,
            otherwise <c>false</c>.</returns>
    </member>
    <member name="M:PostSharp.Aspects.InstanceCredentials.ToString">
      <inheritdoc />
    </member>
    <member name="T:PostSharp.Aspects.InstanceLevelAspect">
      <summary>
            Base class for aspects applied on types, but having the same lifetime as
            instances of the type to which they are applied.
            </summary>
      <remarks>
        <para>See <see cref="T:PostSharp.Aspects.IInstanceScopedAspect" /> for a discussion of instance-scoped aspects.</para>
        <br />
        <note>
      All classes implementing
      <see cref="T:PostSharp.Aspects.IAspect" />
      should typically be marked as serializable
      using the
      <see cref="T:System.SerializableAttribute" />
      custom attribute. Fields that
      are only used at runtime (and unknown at compile-time) should be carefully
      marked with the
      <see cref="T:System.NonSerializedAttribute" />
      custom attribute.
      When PostSharp is used on a platform that does not support aspect serialization
      (such as .NET Compact Framework, Silverlight, or Windows Phone), or when
      another aspect serializer is used, it is not necessary to mark the aspect
      class as serializable.
      For more information, see
      <see href="../../UserGuide/Aspects/Advanced/Serialization.html">Aspect Serialization</see>
      .
    </note>
        <seealso href="../../UserGuide/Aspects/Advanced/Serialization.html">Aspect Serialization</seealso>
      </remarks>
      <seealso cref="T:PostSharp.Aspects.IInstanceScopedAspect" />
    </member>
    <member name="M:PostSharp.Aspects.InstanceLevelAspect.CreateInstance(PostSharp.Aspects.AspectArgs)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.InstanceLevelAspect.RuntimeInitializeInstance">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.InstanceLevelAspect.CreateAspectConfiguration">
      <inheritdoc />
    </member>
    <member name="P:PostSharp.Aspects.InstanceLevelAspect.Instance">
      <summary>
            Gets the object to which the current aspect has been applied.
            </summary>
    </member>
    <member name="T:PostSharp.Aspects.Advices.InterfaceOverrideAction">
      <summary>
            Enumeration of actions to be overtaken when an interface that should be introduced into a type is already
            implemented by that type.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Default">
      <summary>
        <see cref="F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Fail" />.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Fail">
      <summary>
            Fails and emits an error message.
            </summary>
    </member>
    <member name="F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Ignore">
      <summary>
            Silently ignore this interface (does not introduct it).
            </summary>
    </member>
    <member name="T:PostSharp.Aspects.Internals.AdviceOptimizationAttribute">
      <internal />
    </member>
    <member name="T:PostSharp.Aspects.Internals.EventBinding">
      <internal />
    </member>
    <member name="M:PostSharp.Aspects.Internals.EventBinding.AddHandler(System.Object@,System.Delegate,System.Object)">
      <internal />
    </member>
    <member name="M:PostSharp.Aspects.Internals.EventBinding.RemoveHandler(System.Object@,System.Delegate,System.Object)">
      <internal />
    </member>
    <member name="M:PostSharp.Aspects.Internals.EventBinding.InvokeHandler(System.Object@,System.Delegate,PostSharp.Aspects.Arguments,System.Object)">
      <internal />
    </member>
    <member name="T:PostSharp.Aspects.Internals.EventInterceptionAdviceOptimizationAttribute">
      <internal />
    </member>
    <member name="M:PostSharp.Aspects.Internals.EventInterceptionAdviceOptimizationAttribute.#ctor(PostSharp.Aspects.Internals.EventInterceptionAdviceOptimizations)">
      <internal />
    </member>
    <member name="P:PostSharp.Aspects.Internals.EventInterceptionAdviceOptimizationAttribute.Optimizations">
      <internal />
    </member>
    <member name="T:PostSharp.Aspects.Internals.EventInterceptionAdviceOptimizations">
      <internal />
    </member>
    <member name="T:PostSharp.Aspects.Internals.EventInterceptionArgsImpl">
      <internal />
    </member>
    <member name="M:PostSharp.Aspects.Internals.EventInterceptionArgsImpl.#ctor(System.Object,PostSharp.Aspects.Arguments,System.Delegate)">
      <internal />
    </member>
    <member name="F:PostSharp.Aspects.Internals.EventInterceptionArgsImpl.TypedBinding">
      <internal />
    </member>
    <member name="M:PostSharp.Aspects.Internals.EventInterceptionArgsImpl.ProceedAddHandler">
      <internal />
    </member>
    <member name="M:PostSharp.Aspects.Internals.EventInterceptionArgsImpl.ProceedRemoveHandler">
      <internal />
    </member>
    <member name="M:PostSharp.Aspects.Internals.EventInterceptionArgsImpl.ProceedInvokeHandler">
      <internal />
    </member>
    <member name="P:PostSharp.Aspects.Internals.EventInterceptionArgsImpl.Binding">
      <internal />
    </member>
    <member name="T:PostSharp.Aspects.Internals.LocationBinding`1">
      <internal />
    </member>
    <member name="M:PostSharp.Aspects.Internals.LocationBinding`1.GetValue(System.Object@,PostSharp.Aspects.Arguments,System.Object)">
      <internal />
    </member>
    <member name="M:PostSharp.Aspects.Internals.LocationBinding`1.SetValue(System.Object@,PostSharp.Aspects.Arguments,`0,System.Object)">
      <internal />
    </member>
    <member name="T:PostSharp.Aspects.Internals.LocationInterceptionAdviceOptimizationAttribute">
      <internal />
    </member>
    <member name="M:PostSharp.Aspects.Internals.LocationInterceptionAdviceOptimizationAttribute.#ctor(PostSharp.Aspects.Internals.LocationInterceptionAdviceOptimizations)">
      <internal />
    </member>
    <member name="P:PostSharp.Aspects.Internals.LocationInterceptionAdviceOptimizationAttribute.Optimizations">
      <internal />
    </member>
    <member name="T:PostSharp.Aspects.Internals.LocationInterceptionAdviceOptimizations">
      <internal />
    </member>
    <member name="T:PostSharp.Aspects.Internals.MethodBinding">
      <internal />
    </member>
    <member name="M:PostSharp.Aspects.Internals.MethodBinding.Invoke(System.Object@,PostSharp.Aspects.Arguments,System.Object)">
      <internal />
    </member>
    <member name="T:PostSharp.Aspects.Internals.MethodBinding`1">
      <internal />
    </member>
    <member name="M:PostSharp.Aspects.Internals.MethodBinding`1.Invoke(System.Object@,PostSharp.Aspects.Arguments,System.Object)">
      <internal />
    </member>
    <member name="T:PostSharp.Aspects.Internals.MethodExecutionAdviceOptimizationAttribute">
      <internal />
    </member>
    <member name="M:PostSharp.Aspects.Internals.MethodExecutionAdviceOptimizationAttribute.#ctor(PostSharp.Aspects.Internals.MethodExecutionAdviceOptimizations)">
      <internal />
    </member>
    <member name="P:PostSharp.Aspects.Internals.MethodExecutionAdviceOptimizationAttribute.Optimizations">
      <internal />
    </member>
    <member name="T:PostSharp.Aspects.Internals.MethodExecutionAdviceOptimizations">
      <internal />
    </member>
    <member name="T:PostSharp.Aspects.Internals.MethodInterceptionAdviceOptimizationAttribute">
      <internal />
    </member>
    <member name="M:PostSharp.Aspects.Internals.MethodInterceptionAdviceOptimizationAttribute.#ctor(PostSharp.Aspects.Internals.MethodInterceptionAdviceOptimizations)">
      <internal />
    </member>
    <member name="P:PostSharp.Aspects.Internals.MethodInterceptionAdviceOptimizationAttribute.Optimizations">
      <internal />
    </member>
    <member name="T:PostSharp.Aspects.Internals.MethodInterceptionAdviceOptimizations">
      <internal />
    </member>
    <member name="T:PostSharp.Aspects.Internals.RequiresAdviceAnalysisAttribute">
      <internal />
    </member>
    <member name="T:PostSharp.Aspects.Internals.RequiresEventInterceptionAdviceAnalysisAttribute">
      <internal />
    </member>
    <member name="T:PostSharp.Aspects.Internals.RequiresLocationInterceptionAdviceAnalysisAttribute">
      <internal />
    </member>
    <member name="T:PostSharp.Aspects.Internals.RequiresMethodExecutionAdviceAnalysisAttribute">
      <internal />
    </member>
    <member name="T:PostSharp.Aspects.Internals.RequiresMethodInterceptionAdviceAnalysisAttribute">
      <internal />
    </member>
    <member name="T:PostSharp.Aspects.Internals.RuntimeInitializeOptimizationAttribute">
      <internal />
    </member>
    <member name="M:PostSharp.Aspects.Internals.RuntimeInitializeOptimizationAttribute.#ctor(PostSharp.Aspects.Internals.RuntimeInitializeOptimizations)">
      <internal />
    </member>
    <member name="P:PostSharp.Aspects.Internals.RuntimeInitializeOptimizationAttribute.Optimizations">
      <internal />
    </member>
    <member name="T:PostSharp.Aspects.Internals.RuntimeInitializeOptimizations">
      <internal />
    </member>
    <member name="T:PostSharp.Aspects.Internals.CreateInstanceOptimizationAttribute">
      <internal />
    </member>
    <member name="M:PostSharp.Aspects.Internals.CreateInstanceOptimizationAttribute.#ctor(PostSharp.Aspects.Internals.CreateInstanceOptimizations)">
      <internal />
    </member>
    <member name="P:PostSharp.Aspects.Internals.CreateInstanceOptimizationAttribute.Optimizations">
      <internal />
    </member>
    <member name="T:PostSharp.Aspects.Internals.CreateInstanceOptimizations">
      <internal />
    </member>
    <member name="T:PostSharp.Aspects.Internals.RequiresCreateInstanceAnalysisAttribute">
      <internal />
    </member>
    <member name="T:PostSharp.Aspects.Internals.EventBroker">
      <internal />
    </member>
    <member name="M:PostSharp.Aspects.Internals.EventBroker.#ctor(System.Object)">
      <internal />
    </member>
    <member name="M:PostSharp.Aspects.Internals.EventBroker.SubscribeImpl">
      <internal />
    </member>
    <member name="M:PostSharp.Aspects.Internals.EventBroker.UnsubscribeImpl">
      <internal />
    </member>
    <member name="M:PostSharp.Aspects.Internals.EventBroker.OnHandlerInvoked(System.Delegate,PostSharp.Aspects.Arguments)">
      <internal />
    </member>
    <member name="M:PostSharp.Aspects.Internals.EventBroker.AddHandler(System.Delegate)">
      <internal />
    </member>
    <member name="M:PostSharp.Aspects.Internals.EventBroker.RemoveHandler(System.Delegate)">
      <internal />
    </member>
    <member name="M:PostSharp.Aspects.Internals.EventBroker.OnEventFired(PostSharp.Aspects.Arguments)">
      <internal />
    </member>
    <member name="P:PostSharp.Aspects.Internals.EventBroker.Instance">
      <internal />
    </member>
    <member name="T:PostSharp.Aspects.Internals.LocationInterceptionArgsImpl`1">
      <internal />
    </member>
    <member name="T:PostSharp.Aspects.LocationInterceptionArgs">
      <summary>
            Arguments of advices of aspect type <see cref="T:PostSharp.Aspects.ILocationInterceptionAspect" />.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.LocationInterceptionArgs.ProceedGetValue">
      <summary>
            Invokes the <b>Get Location Value</b> semantic on the next node in the chain of invocation and stores the location value in the <see cref="P:PostSharp.Aspects.LocationInterceptionArgs.Value" /> property.
            </summary>
      <remarks>
        <para>
            Note that this method overwrites the content of the <see cref="P:PostSharp.Aspects.LocationInterceptionArgs.Value" /> property. Therefore, you should not call this invoke
            from a <see cref="M:PostSharp.Aspects.ILocationInterceptionAspect.OnSetValue(PostSharp.Aspects.LocationInterceptionArgs)" /> advice unless you store the value before. If you need to retrieve
            the current value of the location from a <see cref="M:PostSharp.Aspects.ILocationInterceptionAspect.OnSetValue(PostSharp.Aspects.LocationInterceptionArgs)" /> advice, it is recommended you
            use the <see cref="M:PostSharp.Aspects.LocationInterceptionArgs.GetCurrentValue" /> method.
            </para>
        <br />
        <note>
      This method is designed to be invoked during the execution of the advice. If you need to retrieve or store the value of the location at a different time, it is
      recommended to use the
      <see cref="P:PostSharp.Aspects.LocationInterceptionArgs.Binding" />
      . Indeed, a binding is stateless, while
      <see cref="T:PostSharp.Aspects.LocationInterceptionArgs" />
      instances may be shared
      among different aspects.
    </note>
      </remarks>
    </member>
    <member name="M:PostSharp.Aspects.LocationInterceptionArgs.ProceedSetValue">
      <summary>
            Invokes the <b>Set Location Value</b> semantic on the next node in the chain of invocation and stores the value of the <see cref="P:PostSharp.Aspects.LocationInterceptionArgs.Value" /> property into
            the location.
            </summary>
      <remarks>
        <para>Note that this method requires trhe value to be stored in the <see cref="P:PostSharp.Aspects.LocationInterceptionArgs.Value" /> property. If you need to retrieve
            the current value of the location from a <see cref="M:PostSharp.Aspects.ILocationInterceptionAspect.OnSetValue(PostSharp.Aspects.LocationInterceptionArgs)" /> advice, it is recommended you
            use the <see cref="M:PostSharp.Aspects.LocationInterceptionArgs.GetCurrentValue" /> method.
            </para>
        <br />
        <note>
      This method is designed to be invoked during the execution of the advice. If you need to retrieve or store the value of the location at a different time, it is
      recommended to use the
      <see cref="P:PostSharp.Aspects.LocationInterceptionArgs.Binding" />
      . Indeed, a binding is stateless, while
      <see cref="T:PostSharp.Aspects.LocationInterceptionArgs" />
      instances may be shared
      among different aspects.
    </note>
      </remarks>
    </member>
    <member name="M:PostSharp.Aspects.LocationInterceptionArgs.GetCurrentValue">
      <summary>
            Retrieves the current value of the location without overwriting the <see cref="P:PostSharp.Aspects.LocationInterceptionArgs.Value" /> property.
            </summary>
      <returns>The current value of the location, as returned by the next node in the chain of invocation (see <see cref="P:PostSharp.Aspects.LocationInterceptionArgs.Binding" />).</returns>
      <remarks>
        <note>
      This method is designed to be invoked during the execution of the advice. If you need to retrieve or store the value of the location at a different time, it is
      recommended to use the
      <see cref="P:PostSharp.Aspects.LocationInterceptionArgs.Binding" />
      . Indeed, a binding is stateless, while
      <see cref="T:PostSharp.Aspects.LocationInterceptionArgs" />
      instances may be shared
      among different aspects.
    </note>
      </remarks>
    </member>
    <member name="M:PostSharp.Aspects.LocationInterceptionArgs.SetNewValue(System.Object)">
      <summary>
            Sets the value of the location without overwriting the <see cref="P:PostSharp.Aspects.LocationInterceptionArgs.Value" /> property.
            </summary>
      <param name="value">The value to be passed to the next node in the chain of invocation (see <see cref="P:PostSharp.Aspects.LocationInterceptionArgs.Binding" />).</param>
      <remarks>
        <br />
        <note>
      This method is designed to be invoked during the execution of the advice. If you need to retrieve or store the value of the location at a different time, it is
      recommended to use the
      <see cref="P:PostSharp.Aspects.LocationInterceptionArgs.Binding" />
      . Indeed, a binding is stateless, while
      <see cref="T:PostSharp.Aspects.LocationInterceptionArgs" />
      instances may be shared
      among different aspects.
    </note>
      </remarks>
    </member>
    <member name="P:PostSharp.Aspects.LocationInterceptionArgs.Binding">
      <summary>
            Gets an interface that allows to invoke the next node in the chain of invocation of the intercepted method.
            </summary>
      <remarks>
        <!-- No matching elements were found for the following include tag -->
        <include file="Documentation.xml" path="/documentation/section[@name='bindingProperty']/*" />
      </remarks>
    </member>
    <member name="P:PostSharp.Aspects.LocationInterceptionArgs.Value">
      <summary>
            Gets or sets the location value.
            </summary>
      <remarks>
        <para>
            Inside an <see cref="M:PostSharp.Aspects.ILocationInterceptionAspect.OnGetValue(PostSharp.Aspects.LocationInterceptionArgs)" /> advice, this property is available after
            the next advice in chain has been invoked using <see cref="M:PostSharp.Aspects.LocationInterceptionArgs.ProceedGetValue" />. However, 
            inside an <see cref="M:PostSharp.Aspects.ILocationInterceptionAspect.OnSetValue(PostSharp.Aspects.LocationInterceptionArgs)" /> advice, the value is available immediately,
            and is used as input by <see cref="M:PostSharp.Aspects.LocationInterceptionArgs.ProceedSetValue" />. 
            </para>
        <para>
            See <see cref="M:PostSharp.Aspects.LocationInterceptionArgs.GetCurrentValue" /> and <see cref="M:PostSharp.Aspects.LocationInterceptionArgs.SetNewValue(System.Object)" />
            to get or set the value of the location without affecting the value of this property.
            </para>
      </remarks>
    </member>
    <member name="P:PostSharp.Aspects.LocationInterceptionArgs.Index">
      <summary>
            Gets the current index arguments (in case of a property with parameters).
            </summary>
    </member>
    <member name="P:PostSharp.Aspects.LocationInterceptionArgs.Location">
      <summary>
            Gets the location (field, property or parameter) related to the aspect or advice being executed.
            </summary>
      <remarks>
        <para>
            Using this property causes the aspect weaver to generate code that has non-trivial runtime overhead. Avoid using
            this property whenever possible. One of the possible solution is to use compile-time initialization of
            aspect instances and to make use of reflection only at build time.
            </para>
      </remarks>
    </member>
    <member name="P:PostSharp.Aspects.LocationInterceptionArgs.LocationName">
      <summary>
            Gets the name of the location (field, property or parameter) related to the aspect or advice being executed.
            </summary>
    </member>
    <member name="P:PostSharp.Aspects.LocationInterceptionArgs.LocationFullName">
      <summary>
            Gets the full name (including the full name of the declaring type) of the location (field, property or parameter) related to the aspect or advice being executed.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.Internals.LocationInterceptionArgsImpl`1.#ctor(System.Object,PostSharp.Aspects.Arguments)">
      <internal />
    </member>
    <member name="F:PostSharp.Aspects.Internals.LocationInterceptionArgsImpl`1.TypedBinding">
      <internal />
    </member>
    <member name="F:PostSharp.Aspects.Internals.LocationInterceptionArgsImpl`1.TypedValue">
      <internal />
    </member>
    <member name="M:PostSharp.Aspects.Internals.LocationInterceptionArgsImpl`1.ProceedGetValue">
      <internal />
    </member>
    <member name="M:PostSharp.Aspects.Internals.LocationInterceptionArgsImpl`1.ProceedSetValue">
      <internal />
    </member>
    <member name="M:PostSharp.Aspects.Internals.LocationInterceptionArgsImpl`1.GetCurrentValue">
      <internal />
    </member>
    <member name="M:PostSharp.Aspects.Internals.LocationInterceptionArgsImpl`1.SetNewValue(System.Object)">
      <internal />
    </member>
    <member name="P:PostSharp.Aspects.Internals.LocationInterceptionArgsImpl`1.Binding">
      <internal />
    </member>
    <member name="P:PostSharp.Aspects.Internals.LocationInterceptionArgsImpl`1.Value">
      <internal />
    </member>
    <member name="T:PostSharp.Aspects.Internals.MethodInterceptionArgsImpl">
      <internal />
    </member>
    <member name="T:PostSharp.Aspects.MethodInterceptionArgs">
      <summary>
            Arguments of advices of aspect type <see cref="T:PostSharp.Aspects.IMethodInterceptionAspect" />.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.MethodInterceptionArgs.Proceed">
      <summary>
            Proceeds with invocation of the method that has been intercepted, passing the <see cref="P:PostSharp.Aspects.MethodInterceptionArgs.Arguments" /> to that method and 
            storing its return value into the <see cref="P:PostSharp.Aspects.MethodInterceptionArgs.ReturnValue" /> property.
            </summary>
    </member>
    <member name="P:PostSharp.Aspects.MethodInterceptionArgs.Binding">
      <summary>
            Gets an interface that allows to invoke the next node in the chain of invocation of the intercepted method.
            </summary>
      <remarks>
        <!-- No matching elements were found for the following include tag -->
        <include file="Documentation.xml" path="/documentation/section[@name='bindingProperty']/*" />
      </remarks>
    </member>
    <member name="P:PostSharp.Aspects.MethodInterceptionArgs.ReturnValue">
      <summary>
            Gets or sets the return value of the method.
            </summary>
    </member>
    <member name="P:PostSharp.Aspects.MethodInterceptionArgs.Method">
      <summary>
            Gets the method to which the current aspect has been applied.
            </summary>
      <remarks>
            Using this property causes the aspect weaver to generate code that has non-trivial runtime overhead. Avoid using
            this property whenever possible. One of the possible solution is to use compile-time initialization of
            aspect instances and to make use of reflection only at build time.
            </remarks>
    </member>
    <member name="P:PostSharp.Aspects.MethodInterceptionArgs.Arguments">
      <summary>
            Gets the list of arguments with which the method has been invoked.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.Internals.MethodInterceptionArgsImpl.#ctor(System.Object,PostSharp.Aspects.Arguments)">
      <internal />
    </member>
    <member name="F:PostSharp.Aspects.Internals.MethodInterceptionArgsImpl.TypedBinding">
      <internal />
    </member>
    <member name="M:PostSharp.Aspects.Internals.MethodInterceptionArgsImpl.Proceed">
      <internal />
    </member>
    <member name="P:PostSharp.Aspects.Internals.MethodInterceptionArgsImpl.Binding">
      <internal />
    </member>
    <member name="P:PostSharp.Aspects.Internals.MethodInterceptionArgsImpl.ReturnValue">
      <internal />
    </member>
    <member name="T:PostSharp.Aspects.Internals.MethodInterceptionArgsImpl`1">
      <internal />
    </member>
    <member name="M:PostSharp.Aspects.Internals.MethodInterceptionArgsImpl`1.#ctor(System.Object,PostSharp.Aspects.Arguments)">
      <internal />
    </member>
    <member name="F:PostSharp.Aspects.Internals.MethodInterceptionArgsImpl`1.TypedBinding">
      <internal />
    </member>
    <member name="F:PostSharp.Aspects.Internals.MethodInterceptionArgsImpl`1.TypedReturnValue">
      <internal />
    </member>
    <member name="M:PostSharp.Aspects.Internals.MethodInterceptionArgsImpl`1.Proceed">
      <internal />
    </member>
    <member name="P:PostSharp.Aspects.Internals.MethodInterceptionArgsImpl`1.Binding">
      <internal />
    </member>
    <member name="P:PostSharp.Aspects.Internals.MethodInterceptionArgsImpl`1.ReturnValue">
      <internal />
    </member>
    <member name="T:PostSharp.Aspects.IOnExceptionAspect">
      <summary>
            Runtime semantics of an aspect that, when applied on a method,
            defines an exception handler around the whole method body
            and let the implementation of this interface handle the exception.
            </summary>
      <seealso cref="T:PostSharp.Aspects.OnExceptionAspect" />
      <seealso cref="T:PostSharp.Aspects.OnExceptionAspectConfiguration" />
      <seealso cref="T:PostSharp.Aspects.OnExceptionAspectConfigurationAttribute" />
    </member>
    <member name="M:PostSharp.Aspects.IOnExceptionAspect.OnException(PostSharp.Aspects.MethodExecutionArgs)">
      <summary>
            Method executed <b>after</b> the body of methods to which this aspect is applied,
            in case that the method resulted with an exception (i.e., in a <c>catch</c> block).
            </summary>
      <param name="args">Advice arguments.</param>
    </member>
    <member name="T:PostSharp.Aspects.OnExceptionAspectConfiguration">
      <summary>
            Configuration of the <see cref="T:PostSharp.Aspects.IOnExceptionAspect" /> aspect.
            </summary>
      <seealso cref="T:PostSharp.Aspects.OnExceptionAspectConfigurationAttribute" />
    </member>
    <member name="P:PostSharp.Aspects.OnExceptionAspectConfiguration.ExceptionType">
      <summary>
            Gets or sets the type of exceptions that are caught by this aspect.
            </summary>
      <remarks>
            If this property is <c>null</c>, any <see cref="T:System.Exception" /> shall be caught.
            </remarks>
    </member>
    <member name="T:PostSharp.Aspects.OnExceptionAspectConfigurationAttribute">
      <summary>
            Custom attribute that, when applied on a class implementing <see cref="T:PostSharp.Aspects.IOnExceptionAspect" />,
            defines the configuration of that aspect.
            </summary>
    </member>
    <member name="P:PostSharp.Aspects.OnExceptionAspectConfigurationAttribute.ExceptionType">
      <summary>
            Gets or sets the type of exceptions that are caught by this aspect.
            </summary>
      <remarks>
            If this property is <c>null</c>, any <see cref="T:System.Exception" /> shall be caught.
            </remarks>
    </member>
    <member name="T:PostSharp.Aspects.IOnMethodBoundaryAspect">
      <summary>
            Runtime semantics of <see cref="T:PostSharp.Aspects.OnMethodBoundaryAspect" />.
            </summary>
      <remarks>
        <para>See <see cref="T:PostSharp.Aspects.OnMethodBoundaryAspect" /> for details.</para>
      </remarks>
      <seealso cref="T:PostSharp.Aspects.OnMethodBoundaryAspect" />
      <seealso cref="T:PostSharp.Aspects.OnMethodBoundaryAspectConfiguration" />
      <seealso cref="T:PostSharp.Aspects.OnMethodBoundaryAspectConfigurationAttribute" />
    </member>
    <member name="M:PostSharp.Aspects.IOnMethodBoundaryAspect.OnEntry(PostSharp.Aspects.MethodExecutionArgs)">
      <summary>
            Method executed <b>before</b> the body of methods to which this aspect is applied.
            </summary>
      <param name="args">Event arguments specifying which method
            is being executed, which are its arguments, and how should the execution continue
            after the execution of <see cref="M:PostSharp.Aspects.IOnMethodBoundaryAspect.OnEntry(PostSharp.Aspects.MethodExecutionArgs)" />.</param>
      <remarks>
            If the aspect is applied to a constructor, the current method is invoked
            after the <b>this</b> pointer has been initialized, that is, after
            the base constructor has been called.
            </remarks>
    </member>
    <member name="M:PostSharp.Aspects.IOnMethodBoundaryAspect.OnExit(PostSharp.Aspects.MethodExecutionArgs)">
      <summary>
            Method executed <b>after</b> the body of methods to which this aspect is applied,
            even when the method exists with an exception (this method is invoked from
            the <b>finally</b> block).
            </summary>
      <param name="args">Event arguments specifying which method
            is being executed and which are its arguments.</param>
    </member>
    <member name="M:PostSharp.Aspects.IOnMethodBoundaryAspect.OnSuccess(PostSharp.Aspects.MethodExecutionArgs)">
      <summary>
            Method executed <b>after</b> the body of methods to which this aspect is applied,
            but only when the method successfully returns (i.e. when no exception flies out
            the method.).
            </summary>
      <param name="args">Event arguments specifying which method
            is being executed and which are its arguments.</param>
    </member>
    <member name="M:PostSharp.Aspects.IOnMethodBoundaryAspect.OnException(PostSharp.Aspects.MethodExecutionArgs)">
      <summary>
            Method executed <b>after</b> the body of methods to which this aspect is applied,
            in case that the method resulted with an exception.
            </summary>
      <param name="args">Event arguments specifying which method
            is being executed and which are its arguments.</param>
    </member>
    <member name="T:PostSharp.Aspects.OnMethodBoundaryAspectConfiguration">
      <summary>
            Configuration of the <see cref="T:PostSharp.Aspects.IOnMethodBoundaryAspect" /> aspect.
            </summary>
      <seealso cref="T:PostSharp.Aspects.OnMethodBoundaryAspectConfigurationAttribute" />
      <seealso cref="T:PostSharp.Aspects.IOnMethodBoundaryAspect" />
    </member>
    <member name="T:PostSharp.Aspects.OnMethodBoundaryAspectConfigurationAttribute">
      <summary>
            Custom attribute that, when applied on a class implementing <see cref="T:PostSharp.Aspects.IOnMethodBoundaryAspect" />,
            defines the configuration of that aspect.
            </summary>
      <seealso cref="T:PostSharp.Aspects.OnMethodBoundaryAspectConfiguration" />
      <seealso cref="T:PostSharp.Aspects.IOnMethodBoundaryAspect" />
    </member>
    <member name="T:PostSharp.Aspects.IProtectedInterface`1">
      <summary>
            Gives access to a 'protected' interface, typically introduced
            by a <see cref="T:PostSharp.Aspects.CompositionAspect" /> or a <see cref="T:PostSharp.Aspects.Advices.IntroduceInterfaceAttribute" /></summary>
      <typeparam name="T">Exposed interface.</typeparam>
      <remarks>
            A 'protected' interface is not directly implemented by the type. 
            Instead, the type exposes it through the <see cref="T:PostSharp.Aspects.IProtectedInterface`1" /> interface. When an object 
            wants access to a protected interface, it must provide valid <see cref="T:PostSharp.Aspects.InstanceCredentials" />.
            Since the method providing <see cref="T:PostSharp.Aspects.InstanceCredentials" /> is protected, it
            allows an instance to control which code can have access to protected semantics.
            </remarks>
    </member>
    <member name="M:PostSharp.Aspects.IProtectedInterface`1.GetInterface(PostSharp.Aspects.InstanceCredentials)">
      <summary>
            Gets a protected interface.
            </summary>
      <param name="credentials">Credentials of the current instance.</param>
      <returns>The implementation of the interface <typeparamref name="T" />.</returns>
    </member>
    <member name="T:PostSharp.Aspects.LocationInterceptionAspect">
      <summary>
            Aspect that, when applied on a location (field or property), intercepts invocations of
            the <c>Get</c> (<see cref="M:PostSharp.Aspects.LocationInterceptionAspect.OnGetValue(PostSharp.Aspects.LocationInterceptionArgs)" />) and <c>Set</c> (<see cref="M:PostSharp.Aspects.LocationInterceptionAspect.OnSetValue(PostSharp.Aspects.LocationInterceptionArgs)" />) semantics.
            </summary>
      <seealso cref="T:PostSharp.Aspects.LocationInterceptionAspectConfigurationAttribute" />
      <remarks>
        <note>
      All classes implementing
      <see cref="T:PostSharp.Aspects.IAspect" />
      should typically be marked as serializable
      using the
      <see cref="T:System.SerializableAttribute" />
      custom attribute. Fields that
      are only used at runtime (and unknown at compile-time) should be carefully
      marked with the
      <see cref="T:System.NonSerializedAttribute" />
      custom attribute.
      When PostSharp is used on a platform that does not support aspect serialization
      (such as .NET Compact Framework, Silverlight, or Windows Phone), or when
      another aspect serializer is used, it is not necessary to mark the aspect
      class as serializable.
      For more information, see
      <see href="../../UserGuide/Aspects/Advanced/Serialization.html">Aspect Serialization</see>
      .
    </note>
        <seealso href="../../UserGuide/Aspects/Advanced/Serialization.html">Aspect Serialization</seealso>
      </remarks>
    </member>
    <member name="T:PostSharp.Aspects.LocationLevelAspect">
      <summary>
            Base class for aspects defined in fields, properties, or parameters.
            </summary>
      <remarks>
        <note>
      This class does not provide any advice. You may derive your aspect class from a
      <see href="../../UserGuide/Aspects/AspectKinds/Overview.html">
        class providing
        predefined advice
      </see>
      , or build a
      <see href="../../UserGuide/Aspects/CompositeAspects/Overview.html">composite aspect</see>
      .
    </note>
        <seealso href="../../UserGuide/Aspects/AspectKinds/Overview.html">Aspect Kinds</seealso>
        <seealso href="../../UserGuide/Aspects/CompositeAspects/Overview.html">Composite Aspects</seealso>
        <br />
        <note>
      All classes implementing
      <see cref="T:PostSharp.Aspects.IAspect" />
      should typically be marked as serializable
      using the
      <see cref="T:System.SerializableAttribute" />
      custom attribute. Fields that
      are only used at runtime (and unknown at compile-time) should be carefully
      marked with the
      <see cref="T:System.NonSerializedAttribute" />
      custom attribute.
      When PostSharp is used on a platform that does not support aspect serialization
      (such as .NET Compact Framework, Silverlight, or Windows Phone), or when
      another aspect serializer is used, it is not necessary to mark the aspect
      class as serializable.
      For more information, see
      <see href="../../UserGuide/Aspects/Advanced/Serialization.html">Aspect Serialization</see>
      .
    </note>
        <seealso href="../../UserGuide/Aspects/Advanced/Serialization.html">Aspect Serialization</seealso>
      </remarks>
      <seealso cref="T:PostSharp.Aspects.ILocationLevelAspect" />
    </member>
    <member name="M:PostSharp.Aspects.LocationLevelAspect.RuntimeInitialize(PostSharp.Reflection.LocationInfo)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.LocationLevelAspect.CompileTimeInitialize(PostSharp.Reflection.LocationInfo,PostSharp.Aspects.AspectInfo)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.LocationLevelAspect.CompileTimeValidate(PostSharp.Reflection.LocationInfo)">
      <summary>
            Method invoked at build time to ensure that the aspect has been applied to the right target.
            </summary>
      <param name="locationInfo">Location to which the aspect has been applied</param>
      <returns>
        <c>true</c> if the aspect was applied to an acceptable field, otherwise
            <c>false</c>.</returns>
      <remarks>The implementation of this method is expected to emit an error message (see 
            <see cref="T:PostSharp.Extensibility.MessageSource" />) or an exception in case of error. Returning <c>false</c> without emitting an
            error message or exception causes the aspect to be silently ignored.</remarks>
    </member>
    <member name="M:PostSharp.Aspects.LocationLevelAspect.SetAspectConfiguration(PostSharp.Aspects.AspectConfiguration,PostSharp.Reflection.LocationInfo)">
      <summary>
            Method invoked at build time to set up an <see cref="T:PostSharp.Aspects.AspectConfiguration" /> object according to the current 
            <see cref="T:PostSharp.Aspects.Aspect" /> instance and a specified target element of the current aspect.
            </summary>
      <param name="aspectConfiguration">The <see cref="T:PostSharp.Aspects.AspectConfiguration" /> instance previously returned  by the
            <see cref="M:PostSharp.Aspects.Aspect.CreateAspectConfiguration" /> method.</param>
      <param name="targetLocation">Location to which the current aspect has been applied.</param>
      <remarks>
        <para>Classes overriding this method must always invoke the base implementation before performing their own
            changes to the 
            <see cref="T:PostSharp.Aspects.AspectConfiguration" />.</para>
      </remarks>
    </member>
    <member name="M:PostSharp.Aspects.LocationLevelAspect.SetAspectConfiguration(PostSharp.Aspects.AspectConfiguration,System.Object)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.LocationLevelAspect.CompileTimeValidate(System.Object)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.LocationInterceptionAspect.OnGetValue(PostSharp.Aspects.LocationInterceptionArgs)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.LocationInterceptionAspect.OnSetValue(PostSharp.Aspects.LocationInterceptionArgs)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.LocationInterceptionAspect.CreateAspectConfiguration">
      <inheritdoc />
    </member>
    <member name="T:PostSharp.Aspects.MethodExecutionArgs">
      <summary>
            Arguments of advices of aspects of type <see cref="T:PostSharp.Aspects.OnMethodBoundaryAspect" />, <see cref="T:PostSharp.Aspects.OnExceptionAspect" />,
            and <see cref="T:PostSharp.Aspects.ImplementMethodAspect" />.
            </summary>
      <remarks>
        <note>
      As a result of weaving optimizations, instances of classes derived from <see cref="T:PostSharp.Aspects.AspectArgs" /> may be shared among different aspects. Therefore,
      aspect code should not attempt to access this object once the control has been given over to the next node in the chain of invocation. Consider working
      with <see href="../../UserGuide/Aspects/Binding.html">bindings</see> if you need such deferred execution.
    </note>
        <seealso href="../../UserGuide/Aspects/Binding.html">Aspect Bindings</seealso>
      </remarks>
    </member>
    <member name="M:PostSharp.Aspects.MethodExecutionArgs.#ctor(System.Object,PostSharp.Aspects.Arguments)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Aspects.MethodExecutionArgs" />.
            </summary>
      <param name="instance">Object instance on which the method is currently
            executed, or <c>null</c> if the method is static.</param>
      <param name="arguments">Arguments with which the method is being invoked.</param>
    </member>
    <member name="P:PostSharp.Aspects.MethodExecutionArgs.Method">
      <summary>
            Gets the method being executed.
            </summary>
      <remarks>
        <para>If the executed method is generic or if its declaring type is generic,
            the current property contains the generic instance being executed.</para>
        <para>
            Using this property causes the aspect weaver to generate code that has non-trivial runtime overhead. Avoid using
            this property whenever possible. One of the possible solution is to use compile-time initialization of
            aspect instances and to make use of reflection only at build time. See <see cref="M:PostSharp.Aspects.MethodLevelAspect.CompileTimeInitialize(System.Reflection.MethodBase,PostSharp.Aspects.AspectInfo)" />
            for details.
            </para>
      </remarks>
      <seealso cref="M:PostSharp.Aspects.MethodLevelAspect.CompileTimeInitialize(System.Reflection.MethodBase,PostSharp.Aspects.AspectInfo)" />
    </member>
    <member name="P:PostSharp.Aspects.MethodExecutionArgs.Arguments">
      <summary>
            Gets the arguments with which the method has been invoked.
            </summary>
      <remarks>
        <note>The property setter should never be used in user code.</note>
      </remarks>
    </member>
    <member name="P:PostSharp.Aspects.MethodExecutionArgs.ReturnValue">
      <summary>
            Gets or sets the method return value.
            </summary>
      <remarks>
            You can modify the return value only when the join point is located
            after a method execution (<see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnSuccess(PostSharp.Aspects.MethodExecutionArgs)" />,
            <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnException(PostSharp.Aspects.MethodExecutionArgs)" /> or <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnExit(PostSharp.Aspects.MethodExecutionArgs)" />,
            or in case you force the method to exit using the <see cref="P:PostSharp.Aspects.MethodExecutionArgs.FlowBehavior" /> property.
            </remarks>
    </member>
    <member name="P:PostSharp.Aspects.MethodExecutionArgs.Exception">
      <summary>
            Gets the exception currently flying.
            </summary>
      <value>An <see cref="P:PostSharp.Aspects.MethodExecutionArgs.Exception" />, or <c>null</c> if the method is exiting normally.</value>
      <remarks>
        <para>You cannot replace the exception by setting this property. Throw a new exception from the aspect if you need to replace the current exception.</para>
      </remarks>
    </member>
    <member name="P:PostSharp.Aspects.MethodExecutionArgs.FlowBehavior">
      <summary>
            Determines the control flow of the target method once the advice is exited.
            </summary>
      <see cref="T:PostSharp.Aspects.FlowBehavior" />
    </member>
    <member name="P:PostSharp.Aspects.MethodExecutionArgs.MethodExecutionTag">
      <summary>
            User-defined state information whose lifetime is linked to the
            current method execution. Aspects derived from <see cref="T:PostSharp.Aspects.IOnMethodBoundaryAspect" />
            should use this property to save state information between
            different events (<see cref="M:PostSharp.Aspects.IOnMethodBoundaryAspect.OnEntry(PostSharp.Aspects.MethodExecutionArgs)" />,
            <see cref="M:PostSharp.Aspects.IOnMethodBoundaryAspect.OnExit(PostSharp.Aspects.MethodExecutionArgs)" /> and <see cref="M:PostSharp.Aspects.IOnMethodBoundaryAspect.OnException(PostSharp.Aspects.MethodExecutionArgs)" />).
            </summary>
    </member>
    <member name="T:PostSharp.Aspects.MethodInterceptionAspect">
      <summary>
            Aspect that, when applied on a method, intercepts invocations of this method.
            </summary>
      <seealso cref="T:PostSharp.Aspects.MethodInterceptionAspectConfigurationAttribute" />
      <remarks>
        <note>
      All classes implementing
      <see cref="T:PostSharp.Aspects.IAspect" />
      should typically be marked as serializable
      using the
      <see cref="T:System.SerializableAttribute" />
      custom attribute. Fields that
      are only used at runtime (and unknown at compile-time) should be carefully
      marked with the
      <see cref="T:System.NonSerializedAttribute" />
      custom attribute.
      When PostSharp is used on a platform that does not support aspect serialization
      (such as .NET Compact Framework, Silverlight, or Windows Phone), or when
      another aspect serializer is used, it is not necessary to mark the aspect
      class as serializable.
      For more information, see
      <see href="../../UserGuide/Aspects/Advanced/Serialization.html">Aspect Serialization</see>
      .
    </note>
        <seealso href="../../UserGuide/Aspects/Advanced/Serialization.html">Aspect Serialization</seealso>
      </remarks>
    </member>
    <member name="M:PostSharp.Aspects.MethodInterceptionAspect.OnInvoke(PostSharp.Aspects.MethodInterceptionArgs)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.MethodInterceptionAspect.CreateAspectConfiguration">
      <inheritdoc />
    </member>
    <member name="T:PostSharp.Aspects.OnExceptionAspect">
      <summary>
            Aspect that, when applied to a method, defines an exception
            handler around the whole method and calls a custom method in this exception
            handler.
            </summary>
      <see cref="T:PostSharp.Aspects.OnMethodBoundaryAspect" />
      <seealso cref="T:PostSharp.Aspects.OnExceptionAspectConfigurationAttribute" />
      <remarks>
        <para>
            The <see cref="T:PostSharp.Aspects.OnMethodBoundaryAspect" /> aspect adds an exception handler to the method to which it is applied.
            It allows you to easily encapsulate exception handling policies as a custom attribute.</para>
        <para>The most important method is <see cref="M:PostSharp.Aspects.OnExceptionAspect.OnException(PostSharp.Aspects.MethodExecutionArgs)" />. It is the exception handler in itself.</para>
        <para> The current exception is available from the <see cref="P:PostSharp.Aspects.MethodExecutionArgs.Exception" /> property of the <see cref="T:PostSharp.Aspects.MethodExecutionArgs" />&gt;
            object. This property is read-only. If you need to  replace the current exception by another one, you should throw a new exception 
            from the handler. If you need to ignore the exception, set the <see cref="P:PostSharp.Aspects.MethodExecutionArgs.FlowBehavior" /> property to
            <see cref="F:PostSharp.Aspects.FlowBehavior.Continue" />.</para>
        <br />
        <note>
      All classes implementing
      <see cref="T:PostSharp.Aspects.IAspect" />
      should typically be marked as serializable
      using the
      <see cref="T:System.SerializableAttribute" />
      custom attribute. Fields that
      are only used at runtime (and unknown at compile-time) should be carefully
      marked with the
      <see cref="T:System.NonSerializedAttribute" />
      custom attribute.
      When PostSharp is used on a platform that does not support aspect serialization
      (such as .NET Compact Framework, Silverlight, or Windows Phone), or when
      another aspect serializer is used, it is not necessary to mark the aspect
      class as serializable.
      For more information, see
      <see href="../../UserGuide/Aspects/Advanced/Serialization.html">Aspect Serialization</see>
      .
    </note>
        <seealso href="../../UserGuide/Aspects/Advanced/Serialization.html">Aspect Serialization</seealso>
      </remarks>
    </member>
    <member name="M:PostSharp.Aspects.OnExceptionAspect.OnException(PostSharp.Aspects.MethodExecutionArgs)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.OnExceptionAspect.GetExceptionType(System.Reflection.MethodBase)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.OnExceptionAspect.CreateAspectConfiguration">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.OnExceptionAspect.SetAspectConfiguration(PostSharp.Aspects.AspectConfiguration,System.Reflection.MethodBase)">
      <inheritdoc />
    </member>
    <member name="T:PostSharp.Aspects.OnMethodBoundaryAspect">
      <summary>
            Aspect that, when applied to a method defined in the current assembly, inserts a piece
            of code before and after the body of these methods.
            </summary>
      <remarks>
        <para>The <see cref="T:PostSharp.Aspects.OnMethodBoundaryAspect" /> aspect results in the target method to 
            be wrapped into a <c>try</c> ... <c>catch</c> ... <c>finally</c> block. You can
            implement four advices: <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnEntry(PostSharp.Aspects.MethodExecutionArgs)" />, executed at the beginning of the block;
            <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnSuccess(PostSharp.Aspects.MethodExecutionArgs)" />, executed only when the method is successful (i.e. does not
            result in an exception); <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnException(PostSharp.Aspects.MethodExecutionArgs)" />, invoked when the method results in 
            an exception; and <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnExit(PostSharp.Aspects.MethodExecutionArgs)" />, always executed after method execution
            (whether the method resulted in an exception or not).</para>
        <para>Schematically, the aspect transforms the original method as follows:</para>
        <code language="C#" file="OnMethodBoundaryPseudoCode.txt" />
        <para>Note that this code is only schematic; actually generated instructions are 
            more complex because they have to cope with parameter boxing and control flow 
            modification, among others.
            </para>
        <para>An object of type <see cref="T:PostSharp.Aspects.MethodExecutionArgs" /> is passed to every of the four advices. This 
            object allows you to:
            </para>
        <list type="bullet">
          <item>
            <b>Get or set arguments</b>.
                    Input and output arguments are available on the property <see cref="P:PostSharp.Aspects.MethodExecutionArgs.Arguments" />. You can change output (<c>out</c>) and by-reference (<c>ref</c>)
                        arguments, but not input arguments.If you need to modify arguments passed by value, consider using a <see cref="T:PostSharp.Aspects.MethodInterceptionAspect" />. 
             (see property );</item>
          <item>
            <b>Get the current exception</b>.
                    The current exception is available on property <see cref="P:PostSharp.Aspects.MethodExecutionArgs.Exception" />, but from the <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnException(PostSharp.Aspects.MethodExecutionArgs)" /> advice.
                        You cannot replace the exception by setting this property. Throw a new exception from the aspect if you need to replace the current exception.
                        
                </item>
          <item>
            <b>Get or set the return value</b>.The return value is available on the <see cref="P:PostSharp.Aspects.MethodExecutionArgs.ReturnValue" /> property.</item>
          <item>
            <b>Change the method control flow</b>. You can change the value of the <see cref="P:PostSharp.Aspects.MethodExecutionArgs.FlowBehavior" /> property to specify
            whether the target method should execute after the execution of the current advice. This may be useful to implement a caching aspect or an exception handler.</item>
          <item>
            <b>Share state between advices</b>. You can use the <see cref="P:PostSharp.Aspects.MethodExecutionArgs.MethodExecutionTag" /> property to store state between the execution of
            different advices related to the same execution of a method. For instance, you can store a cache key in <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnEntry(PostSharp.Aspects.MethodExecutionArgs)" /> and find it back on <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnSuccess(PostSharp.Aspects.MethodExecutionArgs)" />. Using
            <see cref="P:PostSharp.Aspects.MethodExecutionArgs.MethodExecutionTag" /> is the only way to share state that is both thread-safe and reentrant. All other implementations are buggy. </item>
        </list>
        <br />
        <note>
      All classes implementing
      <see cref="T:PostSharp.Aspects.IAspect" />
      should typically be marked as serializable
      using the
      <see cref="T:System.SerializableAttribute" />
      custom attribute. Fields that
      are only used at runtime (and unknown at compile-time) should be carefully
      marked with the
      <see cref="T:System.NonSerializedAttribute" />
      custom attribute.
      When PostSharp is used on a platform that does not support aspect serialization
      (such as .NET Compact Framework, Silverlight, or Windows Phone), or when
      another aspect serializer is used, it is not necessary to mark the aspect
      class as serializable.
      For more information, see
      <see href="../../UserGuide/Aspects/Advanced/Serialization.html">Aspect Serialization</see>
      .
    </note>
        <seealso href="../../UserGuide/Aspects/Advanced/Serialization.html">Aspect Serialization</seealso>
      </remarks>
      <example>
        <para>
      The following class implements an aspect that writes a trace message before and after the execution of the methods to which the aspect is applied.
      The example demonstrates the use of <see cref="T:PostSharp.Aspects.OnMethodBoundaryAspect" />, and shows how to use <see cref="M:PostSharp.Aspects.MethodLevelAspect.RuntimeInitialize(System.Reflection.MethodBase)" />
      to improve runtime performance. 
    </para>
        <para>
      Note that fields <c>enteringMessage</c> and <c>exitingMessage</c> are initialized from method <c>RuntimeInitialize</c>. This method is invoked only once, before
      the aspect instance is used for the first time. It may have been possible to format the trace message from methods <c>OnEntry</c> and <c>OnExit</c>, but doing so
      would hurt performance for two reasons:
    </para>
        <list type="number">
          <item>Getting the reflection object (<see cref="T:System.Reflection.MethodBase" />) is rather expensive.</item>
          <item>Concatening a string creates a new string instance, which causes an overhead to memory allocation and garbage collection.</item>
        </list>
        <para>
      The aspect results in instructions that can be inlined by the JIT/NGen compiler, which makes the aspect almost as fast as hand-written code.
    </para>
        <code language="c#" file="TraceAttribute.cs" />
      </example>
      <example>
        <para>
      The following class implements an aspect that caches the return value of methods to which it is applied.
      The example demonstrates the use of <see cref="T:PostSharp.Aspects.OnMethodBoundaryAspect" />, and shows how to use <see cref="P:PostSharp.Aspects.MethodExecutionArgs.FlowBehavior" />
      to skip the execution of a method when its value is found in cache. The property <see cref="P:PostSharp.Aspects.MethodExecutionArgs.MethodExecutionTag" /> is used to store
      the cache key between the <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnEntry(PostSharp.Aspects.MethodExecutionArgs)" /> and <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnSuccess(PostSharp.Aspects.MethodExecutionArgs)" /> advices.
    </para>
        <para>
      Note that the field <c>methodName</c> is initialized from method <c>CompileTimeInitialize</c>. This method is invoked at build time, then the value of the field is serialized
      into the assembly. Thanks to this mechanism, no reflection is needed at runtime.
    </para>
        <code language="c#" file="CacheAttribute.cs" />
      </example>
    </member>
    <member name="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnEntry(PostSharp.Aspects.MethodExecutionArgs)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnExit(PostSharp.Aspects.MethodExecutionArgs)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnSuccess(PostSharp.Aspects.MethodExecutionArgs)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnException(PostSharp.Aspects.MethodExecutionArgs)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.OnMethodBoundaryAspect.CreateAspectConfiguration">
      <inheritdoc />
    </member>
    <member name="T:PostSharp.Aspects.Serialization.AspectSerializer">
      <summary>
            Base class for Laos serializers, whose role is to serialize aspect instances at compile-time and
            deserialize them at runtime.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.Serialization.AspectSerializer.Serialize(PostSharp.Aspects.IAspect[],System.IO.Stream)">
      <summary>
            Serializes an array of aspects into a stream.
            </summary>
      <param name="aspects">Array of aspects to be serialized.</param>
      <param name="stream">Stream into which aspects have to be serialized.</param>
    </member>
    <member name="M:PostSharp.Aspects.Serialization.AspectSerializer.Deserialize(System.IO.Stream)">
      <summary>
            Deserializes a stream into an array if aspects.
            </summary>
      <param name="stream">Stream containing serialized aspects.</param>
      <returns>An array of aspects.</returns>
      <remarks>
            The implementation is not allowed to change the order or array elements.
            </remarks>
    </member>
    <member name="M:PostSharp.Aspects.Serialization.AspectSerializer.Deserialize(System.Reflection.Assembly,System.String)">
      <summary>
            Deserializes aspects contained in a managed resource of an assembly.
            </summary>
      <param name="assembly">Assembly containing the serialized aspects.</param>
      <param name="resourceName">Name of the managed resources into which aspects have been serialized.</param>
      <returns>An array of aspects.</returns>
    </member>
    <member name="T:PostSharp.Aspects.Serialization.BinaryAspectSerializationBinder">
      <summary>
            Implementation of <see cref="T:System.Runtime.Serialization.SerializationBinder" /> used at runtime when aspect instances
            are deserialized. By overriding the default binder, you can resolve assembly names differently.
            This can be useful if assemblies have been renamed or merged between PostSharp run and execution
            </summary>
      <example>
            LaosSerializationBinder binder = new LaosSerializationBinder();
            binder.Retarget("MyAssembly", "MyAssemblyMerged");
            BinaryLaosSerializer.Binder = binder;
            </example>
    </member>
    <member name="M:PostSharp.Aspects.Serialization.BinaryAspectSerializationBinder.Retarget(System.String,System.String)">
      <summary>
            Retarget an assembly name to a new one.
            </summary>
      <param name="oldAssemblyName">Old assembly name (in short form only).</param>
      <param name="newAssemblyName">New assembly name (in short or full form).</param>
    </member>
    <member name="M:PostSharp.Aspects.Serialization.BinaryAspectSerializationBinder.BindToType(System.String,System.String)">
      <inheritdoc />
    </member>
    <member name="T:PostSharp.Aspects.Serialization.BinaryAspectSerializer">
      <summary>
            Implementation of <see cref="T:PostSharp.Aspects.Serialization.AspectSerializer" /> based on the
            <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter" /> provided by the full version
            of the .NET Framework.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.Serialization.BinaryAspectSerializer.Serialize(PostSharp.Aspects.IAspect[],System.IO.Stream)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.Serialization.BinaryAspectSerializer.Deserialize(System.IO.Stream)">
      <inheritdoc />
    </member>
    <member name="P:PostSharp.Aspects.Serialization.BinaryAspectSerializer.SurrogateSelector">
      <summary>
            Gets or sets the <see cref="T:System.Runtime.Serialization.SurrogateSelector" /> used to deserialize aspects.
            </summary>
      <remarks>
        <para>Developers may provide their own <see cref="T:System.Runtime.Serialization.SurrogateSelector" />, provided
            that they put the old selector in the chain.</para>
      </remarks>
    </member>
    <member name="P:PostSharp.Aspects.Serialization.BinaryAspectSerializer.Binder">
      <summary>
            Gets or sets the <see cref="T:System.Runtime.Serialization.SerializationBinder" /> used to deserialize aspects.
            </summary>
      <value>A <see cref="T:System.Runtime.Serialization.SerializationBinder" />, or <c>null</c>
            to use the default one. By default, <see cref="T:PostSharp.Aspects.Serialization.BinaryAspectSerializationBinder" />
            is used.</value>
      <remarks>
            You should set this property before the first aspect is deserialized;
            that is, before the static constructor of the first enhanced type is invoked.</remarks>
    </member>
    <member name="T:PostSharp.Aspects.Serialization.IStateBagSerializable">
      <summary>
            Interface to be implemented by classes that should be serializable using
            a <see cref="T:PostSharp.Aspects.Serialization.StateBagSerializer" />. These classes should also implement
            a default (parameterless) constructor.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.Serialization.IStateBagSerializable.Serialize(PostSharp.Aspects.Serialization.StateBag)">
      <summary>
            Serializes the current object into a <see cref="T:PostSharp.Aspects.Serialization.StateBag" />/
            </summary>
      <param name="stateBag">
        <see cref="T:PostSharp.Aspects.Serialization.StateBag" /> into which the current object has to be saved.</param>
    </member>
    <member name="M:PostSharp.Aspects.Serialization.IStateBagSerializable.Deserialize(PostSharp.Aspects.Serialization.StateBag)">
      <summary>
            Deserialized the current object from a <see cref="T:PostSharp.Aspects.Serialization.StateBag" />.
            </summary>
      <param name="stateBag">The <see cref="T:PostSharp.Aspects.Serialization.StateBag" /> into which the object was previously serialized,
            and from which it should be reserialized.</param>
      <remarks>
            This method is called during deserialization just after the default (parameterless) constructor
            has been invoked.
            </remarks>
    </member>
    <member name="T:PostSharp.Aspects.Serialization.MsilAspectSerializer">
      <summary>
            When used as a value of <see cref="T:PostSharp.Aspects.AspectConfigurationAttribute" />.<see cref="P:PostSharp.Aspects.AspectConfigurationAttribute.SerializerType" />
            property, specifies that the aspect should not be serialized but should instead be constructed at runtime using MSIL instructions.
            </summary>
      <remarks>
            This class is <b>not</b> a serializer. When you use MSIL aspect construction, the aspect is built at runtime
            just as normal custom attributes, and any change made at build time is lost.
            </remarks>
    </member>
    <member name="M:PostSharp.Aspects.Serialization.MsilAspectSerializer.Serialize(PostSharp.Aspects.IAspect[],System.IO.Stream)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.Serialization.MsilAspectSerializer.Deserialize(System.IO.Stream)">
      <inheritdoc />
    </member>
    <member name="T:PostSharp.Aspects.Serialization.StateBag">
      <summary>
            Simple recursive structure of name-value collections used by the <see cref="T:PostSharp.Aspects.Serialization.StateBagSerializer" />
            to implement portable serialization.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.Serialization.StateBag.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Aspects.Serialization.StateBag" />.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.Serialization.StateBag.SetValue(System.String,System.String)">
      <summary>
            Sets a value in the current <see cref="T:PostSharp.Aspects.Serialization.StateBag" />.
            </summary>
      <param name="name">Item name.</param>
      <param name="value">Item value.</param>
    </member>
    <member name="M:PostSharp.Aspects.Serialization.StateBag.GetValue(System.String)">
      <summary>
            Gets a value of the current <see cref="T:PostSharp.Aspects.Serialization.StateBag" />.
            </summary>
      <param name="name">Name of the requested value.</param>
      <returns>The value named <paramref name="name" />, or <c>null</c>
            if the <see cref="T:PostSharp.Aspects.Serialization.StateBag" /> does not contain this value.</returns>
    </member>
    <member name="M:PostSharp.Aspects.Serialization.StateBag.CreateBag(System.String)">
      <summary>
            Create a child <see cref="T:PostSharp.Aspects.Serialization.StateBag" /> and assign it a name.
            </summary>
      <param name="name">Name of the child bag.</param>
      <returns>The new <see cref="T:PostSharp.Aspects.Serialization.StateBag" />.</returns>
    </member>
    <member name="M:PostSharp.Aspects.Serialization.StateBag.SetBag(System.String,PostSharp.Aspects.Serialization.IStateBagSerializable)">
      <summary>
            Sets a child <see cref="T:PostSharp.Aspects.Serialization.StateBag" /> to the <see cref="T:PostSharp.Aspects.Serialization.StateBag" /> obtained
            by deserializing an object.
            </summary>
      <param name="name">Name of the child <see cref="T:PostSharp.Aspects.Serialization.StateBag" /> in the current <see cref="T:PostSharp.Aspects.Serialization.StateBag" />.</param>
      <param name="obj">Object to deserialize.</param>
    </member>
    <member name="M:PostSharp.Aspects.Serialization.StateBag.GetBag(System.String)">
      <summary>
            Gets a child <see cref="T:PostSharp.Aspects.Serialization.StateBag" />.
            </summary>
      <param name="name">Name of the child <see cref="T:PostSharp.Aspects.Serialization.StateBag" />.</param>
      <returns>The child <see cref="T:PostSharp.Aspects.Serialization.StateBag" /> named <paramref name="name" />, or <c>null</c>
            if there is no child <see cref="T:PostSharp.Aspects.Serialization.StateBag" /> of this name.</returns>
    </member>
    <member name="M:PostSharp.Aspects.Serialization.StateBag.Serialize(System.IO.BinaryWriter)">
      <summary>
            Serializes the current <see cref="T:PostSharp.Aspects.Serialization.StateBag" /> into a <see cref="T:System.IO.BinaryWriter" />.
            </summary>
      <param name="writer">A <see cref="T:System.IO.BinaryWriter" />.</param>
    </member>
    <member name="M:PostSharp.Aspects.Serialization.StateBag.Deserialize(System.IO.BinaryReader)">
      <summary>
            Deserializes a stream (given a <see cref="T:System.IO.BinaryReader" />) into a <see cref="T:PostSharp.Aspects.Serialization.StateBag" />.
            </summary>
      <param name="reader">A <see cref="T:System.IO.BinaryReader" />.</param>
      <returns>The <see cref="T:PostSharp.Aspects.Serialization.StateBag" /> built from <paramref name="reader" />.</returns>
    </member>
    <member name="P:PostSharp.Aspects.Serialization.StateBag.Item(System.String)">
      <summary>
            Gets or sets a value in the current <see cref="T:PostSharp.Aspects.Serialization.StateBag" />.
            </summary>
      <param name="name">Value name.</param>
      <returns>The value named <paramref name="name" />, or <c>null</c> if the
            current <see cref="T:PostSharp.Aspects.Serialization.StateBag" /> does not contain any value named <paramref name="name" />.</returns>
    </member>
    <member name="T:PostSharp.Aspects.Serialization.StateBagSerializer">
      <summary>
            Trivial serializer for use with light editions of the .NET Framework
            (Compact Framework, Silverlight). Aspects should implement the
            <see cref="T:PostSharp.Aspects.Serialization.IStateBagSerializable" /> interface and should have
            a parameterless constructor. This constructor is used during deserialization.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.Serialization.StateBagSerializer.Serialize(PostSharp.Aspects.IAspect[],System.IO.Stream)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.Serialization.StateBagSerializer.Deserialize(System.IO.Stream)">
      <inheritdoc />
    </member>
    <member name="T:PostSharp.Aspects.Serialization.StateBagSerializerException">
      <summary>
            Exception thrown by the <see cref="T:PostSharp.Aspects.Serialization.StateBagSerializer" />.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.Serialization.StateBagSerializerException.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Aspects.Serialization.StateBagSerializerException" /> with the default message.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.Serialization.StateBagSerializerException.#ctor(System.String)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Aspects.Serialization.StateBagSerializerException" /> with a given message.
            </summary>
      <param name="message">Error message.</param>
    </member>
    <member name="M:PostSharp.Aspects.Serialization.StateBagSerializerException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Aspects.Serialization.StateBagSerializerException" /> with a given message and an inner exception.
            </summary>
      <param name="message">Error message.</param>
      <param name="inner">Inner exception.</param>
    </member>
    <member name="M:PostSharp.Aspects.Serialization.StateBagSerializerException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Deserializes a <see cref="T:PostSharp.Aspects.Serialization.StateBagSerializerException" />.
            </summary>
      <param name="info">Serialization information.</param>
      <param name="context">Streaming context.</param>
    </member>
    <member name="T:PostSharp.Aspects.Serialization.XmlAspectSerializer">
      <summary>
            Implementation of <see cref="T:PostSharp.Aspects.Serialization.AspectSerializer" /> based on the <see cref="T:System.Xml.Serialization.XmlSerializer" /> provided by the
            .NET Framework.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.Serialization.XmlAspectSerializer.Serialize(PostSharp.Aspects.IAspect[],System.IO.Stream)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Aspects.Serialization.XmlAspectSerializer.Deserialize(System.IO.Stream)">
      <inheritdoc />
    </member>
    <member name="T:PostSharp.Aspects.TypeIdentity">
      <summary>
             Wraps a <see cref="P:PostSharp.Aspects.TypeIdentity.Type" /> or a type name.
            </summary>
    </member>
    <member name="M:PostSharp.Aspects.TypeIdentity.FromType(System.Type)">
      <summary>
            Wraps a <see cref="P:PostSharp.Aspects.TypeIdentity.Type" /> into a <see cref="T:PostSharp.Aspects.TypeIdentity" />.
            </summary>
      <param name="type">A <see cref="P:PostSharp.Aspects.TypeIdentity.Type" />.</param>
      <returns>A <see cref="T:PostSharp.Aspects.TypeIdentity" /> wrapping <paramref cref="F:PostSharp.Aspects.TypeIdentity.type" />.</returns>
    </member>
    <member name="M:PostSharp.Aspects.TypeIdentity.FromTypes(System.Type[])">
      <summary>
            Wraps an array of <see cref="P:PostSharp.Aspects.TypeIdentity.Type" /> into an array of <see cref="T:PostSharp.Aspects.TypeIdentity" />.
            </summary>
      <param name="types">An array of <see cref="P:PostSharp.Aspects.TypeIdentity.Type" />.</param>
      <returns>An array of <see cref="T:PostSharp.Aspects.TypeIdentity" /> wrapping <paramref name="types" />.</returns>
    </member>
    <member name="M:PostSharp.Aspects.TypeIdentity.ToType">
      <summary>
            Converts a <see cref="T:PostSharp.Aspects.TypeIdentity" /> into a <see cref="T:System.Type" />.
            </summary>
      <returns />
    </member>
    <member name="M:PostSharp.Aspects.TypeIdentity.FromTypeName(System.String)">
      <summary>
            Wraps a type name into a <see cref="T:PostSharp.Aspects.TypeIdentity" />.
            </summary>
      <param name="typeName">The type name.</param>
      <returns>A <see cref="T:PostSharp.Aspects.TypeIdentity" /> wrapping the type name.</returns>
    </member>
    <member name="M:PostSharp.Aspects.TypeIdentity.FromTypeNames(System.String[])">
      <summary>
            Wraps an array of type names into an array of <see cref="T:PostSharp.Aspects.TypeIdentity" />.
            </summary>
      <param name="typeNames">An array of type names.</param>
      <returns>An array of <see cref="T:PostSharp.Aspects.TypeIdentity" /> wrapping <paramref name="typeNames" />.</returns>
    </member>
    <member name="P:PostSharp.Aspects.TypeIdentity.Type">
      <summary>
            Gets the wrapped <see cref="P:PostSharp.Aspects.TypeIdentity.Type" />, or <c>null</c> it the <see cref="P:PostSharp.Aspects.TypeIdentity.TypeName" /> property is set.
            </summary>
    </member>
    <member name="P:PostSharp.Aspects.TypeIdentity.TypeName">
      <summary>
            Gets the wrapped type name, or <c>null</c> it the <see cref="P:PostSharp.Aspects.TypeIdentity.Type" /> property is set.
            </summary>
    </member>
    <member name="T:PostSharp.BoolWithDefault">
      <summary>
            Boolean with a "default" value. For use in design-time configurable boolean properties.
            </summary>
    </member>
    <member name="F:PostSharp.BoolWithDefault.Default">
      <summary>
            Indicates that the value has not been set.
            </summary>
    </member>
    <member name="F:PostSharp.BoolWithDefault.True">
      <summary>
            Indicates that the value has been set to <c>true</c>.
            </summary>
    </member>
    <member name="F:PostSharp.BoolWithDefault.False">
      <summary>
            Indicates that the value has been set to <c>false</c>.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.IAssemblyName">
      <summary>
            Defines the semantics of an assembly name.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.IAssemblyName.GetPublicKey">
      <summary>
            Gets the assemby public key.
            </summary>
      <value>
            An array of bytes containing the public key,
            or <c>null</c> if no public key is specified (for instance if
            only the public key token is given).
            </value>
      <returns>An array of bytes containing the public key,
            or <c>null</c> if no public key is specified.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.IAssemblyName.GetPublicKeyToken">
      <summary>
            Gets the assembly public key token.
            </summary>
      <returns>An array of bytes containing the public key token,
            or <c>null</c> if no public key is specified.</returns>
    </member>
    <member name="P:PostSharp.CodeModel.IAssemblyName.Name">
      <summary>
            Gets the assembly friendly name.
            </summary>
      <value>
            The assembly friendly name.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.IAssemblyName.Version">
      <summary>
            Gets the assembly version.
            </summary>
      <value>
            A <see cref="P:PostSharp.CodeModel.IAssemblyName.Version" />.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.IAssemblyName.Culture">
      <summary>
            Gets the assembly culture name.
            </summary>
      <value>
            The standard assembly culture name, or <c>null</c> if the assembly
            is culture-neutral.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.IAssemblyName.IsMscorlib">
      <summary>
            Determines whether the current assembly (or assembly reference) is <c>mscorlib</c>.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.IAssemblyName.IsStronglyNamed">
      <summary>
            Determines whether the current assembly (or assembly reference) contains a strong name signature.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.IAssemblyName.ProcessorArchitecture">
      <summary>
            Gets the processor architecture that the current assembly targets.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.ReflectionWrapper.IReflectionWrapper">
      <summary>
            Interface implemented by all reflection wrappers.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.ReflectionWrapper.IReflectionWrapper.UnderlyingSystemObject">
      <summary>
            Gets the system object (<see cref="T:System.Type" />, <see cref="T:System.Reflection.FieldInfo" />, <see cref="T:System.Reflection.MethodInfo" />,
            <see cref="T:System.Reflection.ConstructorInfo" />, <see cref="T:System.Reflection.ParameterInfo" />, ...) corresponding to the current wrapper.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.ReflectionWrapper.IReflectionWrapper.DeclaringAssemblyName">
      <summary>
            Gets the name of the assembly declaring the current element.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.SymbolSequencePoint">
      <summary>
            Maps a point in IL instructions to location in source code.
            </summary>
      <remarks>
            This class implements the <see cref="T:System.IComparable`1" /> interface.
            This allows sorting sequence points according to their IL offsets and performing
            binary searches in sorted arrays.
            </remarks>
    </member>
    <member name="F:PostSharp.CodeModel.SymbolSequencePoint.Hidden">
      <summary>
            Gets a symbol meaning that the associated instructions have no source code.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.SymbolSequencePoint.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Diagnostics.SymbolStore.ISymbolDocument)">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.SymbolSequencePoint" />.
            </summary>
      <param name="startLine">The start line in the source file.</param>
      <param name="startColumn">The start column in the source file.</param>
      <param name="endLine">The end line in the source file.</param>
      <param name="endColumn">The end column in the source file.</param>
      <param name="document">Source file</param>
    </member>
    <member name="M:PostSharp.CodeModel.SymbolSequencePoint.Equals(PostSharp.CodeModel.SymbolSequencePoint)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.CodeModel.SymbolSequencePoint.Equals(System.Object)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.CodeModel.SymbolSequencePoint.op_Equality(PostSharp.CodeModel.SymbolSequencePoint,PostSharp.CodeModel.SymbolSequencePoint)">
      <summary>
            Determines whether two sequence points are equal.
            </summary>
      <param name="left">A <see cref="T:PostSharp.CodeModel.SymbolSequencePoint" />.</param>
      <param name="right">A <see cref="T:PostSharp.CodeModel.SymbolSequencePoint" />.</param>
      <returns>
        <c>true</c> if both sequence points are equal, otherwise <c>false</c>.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.SymbolSequencePoint.op_Inequality(PostSharp.CodeModel.SymbolSequencePoint,PostSharp.CodeModel.SymbolSequencePoint)">
      <summary>
            Determines whether two sequence points are different.
            </summary>
      <param name="left">A <see cref="T:PostSharp.CodeModel.SymbolSequencePoint" />.</param>
      <param name="right">A <see cref="T:PostSharp.CodeModel.SymbolSequencePoint" />.</param>
      <returns>
        <c>true</c> if both sequence points are different, otherwise <c>false</c>.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.SymbolSequencePoint.GetHashCode">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.CodeModel.SymbolSequencePoint.ToString">
      <inheritdoc />
    </member>
    <member name="P:PostSharp.CodeModel.SymbolSequencePoint.IsHidden">
      <summary>
            Determines whether the current symbol means that the associated
            instructions have no source code..
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.SymbolSequencePoint.StartLine">
      <summary>
            Gets the start line in the source file.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.SymbolSequencePoint.EndLine">
      <summary>
            Gets the end line in the source file.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.SymbolSequencePoint.StartColumn">
      <summary>
            Gets the start column in the source file.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.SymbolSequencePoint.EndColumn">
      <summary>
            Gets the end column in the source file.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.SymbolSequencePoint.Document">
      <summary>
            Gets the document defining the next instructions.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.Visibility">
      <summary>
            Visibility of types and type members.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.Visibility.Public">
      <summary>
            Public.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.Visibility.Family">
      <summary>
            Family (protected).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.Visibility.Assembly">
      <summary>
            Assembly (internal).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.Visibility.FamilyOrAssembly">
      <summary>
            Family or assembly (protected internal).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.Visibility.FamilyAndAssembly">
      <summary>
            Family and assembly (no C# equivalent: protected types inside the current assembly).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.Visibility.Private">
      <summary>
            Private.
            </summary>
    </member>
    <member name="T:PostSharp.EnhancedByPostSharpAttribute">
      <summary>
            Custom attribute added to the assembly manifest of modules processed by PostSharp.
            </summary>
    </member>
    <member name="M:PostSharp.EnhancedByPostSharpAttribute.#ctor(System.Int32)">
      <summary>
            Instantiates a new <see cref="T:PostSharp.EnhancedByPostSharpAttribute" /> and specifies the license number
            (not the full license key).
            </summary>
      <param name="licenseId">License number.</param>
    </member>
    <member name="M:PostSharp.EnhancedByPostSharpAttribute.#ctor(System.String)">
      <summary>
            Instantiate a new <see cref="T:PostSharp.EnhancedByPostSharpAttribute" /> with a text message,
            typically used when PostSharp runs in evaluation mode.
            </summary>
      <param name="message">The watermark text.</param>
    </member>
    <member name="T:PostSharp.Extensibility.AssemblyIdAttribute">
      <summary>
            Assigns a unique identifier to an assembly. This assembly identifier is used
            to generate unique attribute identifiers. 
            </summary>
      <remarks>
            By default, the assembly identifier is computed from the module name
            (by using the first 4 bytes of the MD5 sum of the module name).
            </remarks>
    </member>
    <member name="M:PostSharp.Extensibility.AssemblyIdAttribute.#ctor(System.Int32)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.AssemblyIdAttribute" />.
            </summary>
      <param name="id">Assembly identifier.</param>
    </member>
    <member name="T:PostSharp.Extensibility.DisablePostSharpMessageAttribute">
      <summary>
            Custom attribute that, when applied on an assembly, means that a given message
            should be disabled during the current <c>PostSharp</c> session.
            </summary>
      <remarks>
            Errors and fatal errors cannot be disabled.
            </remarks>
    </member>
    <member name="M:PostSharp.Extensibility.DisablePostSharpMessageAttribute.#ctor(System.String)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.DisablePostSharpMessageAttribute" />.
            </summary>
      <param name="messageId">Identifier of the message to be disabled.</param>
    </member>
    <member name="P:PostSharp.Extensibility.DisablePostSharpMessageAttribute.MessageId">
      <summary>
            Gets the identifier of the message to be disabled.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.EscalatePostSharpMessageAttribute">
      <summary>
            Custom attribute that, when applied on an assembly, means that a given message
            should be escalated to an error during the current <c>PostSharp</c> session.
            </summary>
      <remarks>
            Errors and fatal errors cannot be disabled.
            </remarks>
    </member>
    <member name="M:PostSharp.Extensibility.EscalatePostSharpMessageAttribute.#ctor(System.String)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.EscalatePostSharpMessageAttribute" />.
            </summary>
      <param name="messageId">Identifier of the message to be disabled.</param>
    </member>
    <member name="P:PostSharp.Extensibility.EscalatePostSharpMessageAttribute.MessageId">
      <summary>
            Gets the identifier of the message to be disabled.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.FrameworkVariants">
      <summary>
            Defines constants identifying the different variants of the
            .NET Framework (<see cref="F:PostSharp.Extensibility.FrameworkVariants.Full" />, <see cref="F:PostSharp.Extensibility.FrameworkVariants.Compact" />, <see cref="F:PostSharp.Extensibility.FrameworkVariants.Silverlight" />).
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.FrameworkVariants.Full">
      <summary>
            Normal, full .NET Framework.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.FrameworkVariants.Compact">
      <summary>
            .NET Compact Framework.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.FrameworkVariants.Silverlight">
      <summary>
            Silverlight.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.FrameworkVariants.Micro">
      <summary>
            Micro Framework.
            </summary>
      <remarks>
            There is strong name in the Micro Framework.
            </remarks>
    </member>
    <member name="M:PostSharp.Extensibility.FrameworkVariants.FromBytes(System.Byte[])">
      <summary>
            Convert a byte array (typically containing the public key token of <b>mscorlib</b>)
            into a string that can be compared to one of the constants defined in this class.
            </summary>
      <param name="bytes">A byte array (typically containing the public key token of <b>mscorlib</b>)</param>
      <returns>A string that can be compared to one of the constants defined in this class</returns>
    </member>
    <member name="T:PostSharp.Extensibility.IMessageSink">
      <summary>
            Receives messages.
            </summary>
      <remarks>
            Use this interface instead of events for cross-domain communication.
            </remarks>
    </member>
    <member name="M:PostSharp.Extensibility.IMessageSink.Write(PostSharp.Extensibility.Message)">
      <summary>
            Writes a message to the sink.
            </summary>
      <param name="message">A message.</param>
    </member>
    <member name="T:PostSharp.Extensibility.ImplementationBoundAttributeAttribute">
      <summary>
            Custom attribute meaning that custom attributes of a given type are
            bound to the implementation, not to the semantics.
            </summary>
      <remarks>
        <para>This custom attribute influences whether instances of a given other
            custom attribute should be moved from the semantic to the implementation,
            when the semantic is detached from the implementation. This happens for instance
            when a property is generated from a field; the property become the semantic
            (and is made public) and the field the implementation (and is made private).
            Most custom attributes apply to semantics, so they are moved from the field
            to the property. If a custom attribute must not be moved, it should be
            marked with the <see cref="T:PostSharp.Extensibility.ImplementationBoundAttributeAttribute" />
            custom attribute.
            </para>
      </remarks>
    </member>
    <member name="M:PostSharp.Extensibility.ImplementationBoundAttributeAttribute.#ctor(System.Type)">
      <summary>
            Initializes the new <see cref="T:PostSharp.Extensibility.ImplementationBoundAttributeAttribute" />.
            </summary>
      <param name="attributeType">Type of the custom attribute that
            should not be moved from implementation to semantic.</param>
    </member>
    <member name="P:PostSharp.Extensibility.ImplementationBoundAttributeAttribute.AttributeType">
      <summary>
            Gets the type of the custom attribute that
            should not be moved from implementation to semantic
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.InvalidAnnotationException">
      <summary>
            Exception thrown at build time by implementation of <see cref="M:PostSharp.Extensibility.IValidableAnnotation.CompileTimeValidate(System.Object)" />
            when an annotation is invalid.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.InvalidAnnotationException.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.InvalidAnnotationException" /> with default message.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.InvalidAnnotationException.#ctor(System.String)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.InvalidAnnotationException" /> and with a specified exception message.
            </summary>
      <param name="message">Exception message</param>
    </member>
    <member name="M:PostSharp.Extensibility.InvalidAnnotationException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.InvalidAnnotationException" /> with a specified exception message
            and inner <see cref="T:System.Exception" />.
            </summary>
      <param name="message">Exception message.</param>
      <param name="inner">Inner exception.</param>
    </member>
    <member name="M:PostSharp.Extensibility.InvalidAnnotationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Deserialization constructor.
            </summary>
      <param name="info">Info.</param>
      <param name="context">Context.</param>
    </member>
    <member name="T:PostSharp.Extensibility.Message">
      <summary>
            Encapsulates a message (error, warning, info, ...).
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.Message.NotAvailable">
      <summary>
            When set to the <see cref="P:PostSharp.Extensibility.Message.LocationLine" /> or the
            <see cref="P:PostSharp.Extensibility.Message.LocationColumn" /> property, means that
            the value of this property is unknown.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Message.#ctor(PostSharp.Extensibility.SeverityType,System.String,System.String,System.String)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.Message" /> and specifies only required parameters.
            </summary>
      <param name="severity">Message severify (fatal error, error, info, debug).</param>
      <param name="messageId">Identifier of the message type.</param>
      <param name="source">Name of the component emitting the message.</param>
      <param name="messageText">Fully formatted message text.</param>
    </member>
    <member name="M:PostSharp.Extensibility.Message.#ctor(PostSharp.Extensibility.SeverityType,System.String,System.String,System.String,System.String,System.String,System.Int32,System.Int32,System.Exception)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.Message" /> and specifies all its properties.
            </summary>
      <param name="severity">Message severify (fatal error, error, info, debug).</param>
      <param name="messageId">Identifier of the message type.</param>
      <param name="locationFile">File that caused the error, or <c>null</c> if
            the file is unknown or does not apply.</param>
      <param name="locationLine"> Position (line) in the file that caused the error,
            or <see cref="F:PostSharp.Extensibility.Message.NotAvailable" /> if the line is 
            unknown or does not apply.</param>
      <param name="locationColumn">Position (column) in the file that caused the error,
            or <see cref="F:PostSharp.Extensibility.Message.NotAvailable" /> if the line is 
            unknown or does not apply.</param>
      <param name="innerException">The <see cref="T:System.Exception" /> that caused this message,
            or <c>null</c> if this message was not caused by an
            exception.</param>
      <param name="source">Name of the component emitting the message.</param>
      <param name="helpLink">Link to the help file page associated to this message.</param>
      <param name="messageText">Fully formatted message text.</param>
    </member>
    <member name="M:PostSharp.Extensibility.Message.GetExceptionStackMessage(System.Exception)">
      <summary>
            Returns a string composed of the messages of
            all inner exceptions.
            </summary>
      <param name="outerException">The outer exception.</param>
      <returns>A string composed of the mesages of all
            <paramref name="outerException" /> and all inner exceptions,
            concatenated by the string <c>--&gt;</c>.</returns>
    </member>
    <member name="M:PostSharp.Extensibility.Message.Write(PostSharp.Extensibility.Message)">
      <summary>
            Writes a message by providing a <see cref="T:PostSharp.Extensibility.Message" /> object.
            </summary>
      <param name="message">A <see cref="T:PostSharp.Extensibility.Message" />.</param>
    </member>
    <member name="M:PostSharp.Extensibility.Message.Write(PostSharp.Extensibility.SeverityType,System.String,System.String)">
      <summary>
            Writes a message by providing a severity, an error code, and an error message.
            </summary>
      <param name="severity">Severity.</param>
      <param name="errorCode">Error code.</param>
      <param name="message">Error message.</param>
    </member>
    <member name="M:PostSharp.Extensibility.Message.Write(PostSharp.Extensibility.SeverityType,System.String,System.String,System.Object[])">
      <summary>
            Writes a message by providing a severity, an error code, an error message formatting string,
            and arguments for this formatting string.
            </summary>
      <param name="severity">Severity.</param>
      <param name="errorCode">Error code.</param>
      <param name="format">Error message formatting string.</param>
      <param name="arguments">Formatting string arguments.</param>
    </member>
    <member name="P:PostSharp.Extensibility.Message.Severity">
      <summary>
            Gets the message severity.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Message.MessageId">
      <summary>
            Gets the message type identifier.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Message.LocationFile">
      <summary>
            Gets the name of the file that caused
            the message.
            </summary>
      <value>
            A full file name, or <c>null</c> if the file name
            is unknown or not applicable.
            </value>
    </member>
    <member name="P:PostSharp.Extensibility.Message.LocationLine">
      <summary>
            Gets the line in the file that caused the
            message.
            </summary>
      <summary>
            An integer greater or equal to 1, or <see cref="F:PostSharp.Extensibility.Message.NotAvailable" />
            if the line is unknown or does not apply.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Message.LocationColumn">
      <summary>
            Gets the column in the file that caused the
            message.
            </summary>
      <summary>
            An integer greater or equal to 1, or <see cref="F:PostSharp.Extensibility.Message.NotAvailable" />
            if the column is unknown or does not apply.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Message.InnerException">
      <summary>
            Gets the
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Message.Source">
      <summary>
            Gets or sets the name of the source component.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Message.MessageText">
      <summary>
            Gets the message formatted text.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Message.HelpLink">
      <summary>
            Gets the help link.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.SeverityType">
      <summary>
            Types of message severities.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.SeverityType.Debug">
      <summary>
            Debugging information (typically trace).
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.SeverityType.Verbose">
      <summary>
            Verbose (lowly important information).
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.SeverityType.Info">
      <summary>
            Information.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.SeverityType.ImportantInfo">
      <summary>
            Important information.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.SeverityType.CommandLine">
      <summary>
            Command line.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.SeverityType.Warning">
      <summary>
            Warning.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.SeverityType.Error">
      <summary>
            Error.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.SeverityType.Fatal">
      <summary>
            Fatal error.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.MessageException">
      <summary>
            Exception embedding a <see cref="T:PostSharp.Extensibility.Message" />.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.MessageException.#ctor(PostSharp.Extensibility.Message)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.MessageException" /> from
            an existing <see cref="T:PostSharp.Extensibility.Message" />.
            </summary>
      <param name="message">A <see cref="T:PostSharp.Extensibility.Message" />.</param>
    </member>
    <member name="M:PostSharp.Extensibility.MessageException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Serializes the current object.
            </summary>
      <param name="info">Serialization information.</param>
      <param name="context">Serialization context.</param>
    </member>
    <member name="P:PostSharp.Extensibility.MessageException.MessageObject">
      <summary>
            Gets the <see cref="T:PostSharp.Extensibility.Message" /> em
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.MessageSource">
      <summary>
            Provides commodity methods to work with an <see cref="T:PostSharp.Extensibility.IMessageSink" />.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.MessageSource.#ctor(System.String,System.Resources.ResourceManager)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.MessageSource" />.
            </summary>
      <param name="source">Name of the component emitting. the messages.</param>
      <param name="resourceManager">The <see cref="T:System.Resources.ResourceManager" /> that will be used to
            retrieve message texts.</param>
    </member>
    <member name="M:PostSharp.Extensibility.MessageSource.CreateMessage(PostSharp.Extensibility.SeverityType,System.String,System.Object[],System.String,System.Int32,System.Int32,System.Exception)">
      <summary>
            Creates a <see cref="T:PostSharp.Extensibility.Message" /> object.
            </summary>
      <param name="severity">Message severify (fatal error, error, info, debug).</param>
      <param name="messageId">Identifier of the message type.</param>
      <param name="arguments">Array of arguments used to format the message text,
            or <c>null</c> if this message has no argument.</param>
      <param name="locationFile">File that caused the error, or <c>null</c> if
            the file is unknown or does not apply.</param>
      <param name="locationLine"> Position (line) in the file that caused the error,
            or <see cref="F:PostSharp.Extensibility.Message.NotAvailable" /> if the line is 
            unknown or does not apply.</param>
      <param name="locationColumn">Position (column) in the file that caused the error,
            or <see cref="F:PostSharp.Extensibility.Message.NotAvailable" /> if the line is 
            unknown or does not apply.</param>
      <param name="innerException">The <see cref="T:System.Exception" /> that caused this message,
            or <c>null</c> if this message was not caused by an
            exception.</param>
      <returns>A <see cref="T:PostSharp.Extensibility.Message" /> object.</returns>
    </member>
    <member name="M:PostSharp.Extensibility.MessageSource.Write(PostSharp.Extensibility.SeverityType,System.String,System.Object[],System.String,System.Int32,System.Int32,System.Exception)">
      <summary>
            Emits a <see cref="T:PostSharp.Extensibility.Message" /> and specifies all its properties.
            </summary>
      <param name="severity">Message severify (fatal error, error, info, debug).</param>
      <param name="messageId">Identifier of the message type.</param>
      <param name="arguments">Array of arguments used to format the message text,
            or <c>null</c> if this message has no argument.</param>
      <param name="locationFile">File that caused the error, or <c>null</c> if
            the file is unknown or does not apply.</param>
      <param name="locationLine"> Position (line) in the file that caused the error,
            or <see cref="F:PostSharp.Extensibility.Message.NotAvailable" /> if the line is 
            unknown or does not apply.</param>
      <param name="locationColumn">Position (column) in the file that caused the error,
            or <see cref="F:PostSharp.Extensibility.Message.NotAvailable" /> if the line is 
            unknown or does not apply.</param>
      <param name="innerException">The <see cref="T:System.Exception" /> that caused this message,
            or <c>null</c> if this message was not caused by an
            exception.</param>
    </member>
    <member name="M:PostSharp.Extensibility.MessageSource.Write(PostSharp.Extensibility.SeverityType,System.String,System.Object[],System.String,System.Int32,System.Int32)">
      <summary>
            Emits a <see cref="T:PostSharp.Extensibility.Message" /> and specifies the source file name,
            line and column.
            </summary>
      <param name="severity">Message severify (fatal error, error, info, debug).</param>
      <param name="messageId">Identifier of the message type.</param>
      <param name="locationFile">File that caused the error, or <c>null</c> if
            the file is unknown or does not apply.</param>
      <param name="locationLine"> Position (line) in the file that caused the error,
            or <see cref="F:PostSharp.Extensibility.Message.NotAvailable" /> if the line is 
            unknown or does not apply.</param>
      <param name="locationColumn">Position (column) in the file that caused the error,
            or <see cref="F:PostSharp.Extensibility.Message.NotAvailable" /> if the line is 
            unknown or does not apply.</param>
      <param name="arguments">Message arguments.</param>
    </member>
    <member name="M:PostSharp.Extensibility.MessageSource.Write(PostSharp.Extensibility.SeverityType,System.String,System.Object[],System.String,System.Int32)">
      <summary>
            Emits a <see cref="T:PostSharp.Extensibility.Message" /> and specifies the source file name and
            line.
            </summary>
      <param name="severity">Message severify (fatal error, error, info, debug).</param>
      <param name="messageId">Identifier of the message type.</param>
      <param name="arguments">Array of arguments used to format the message text,
            or <c>null</c> if this message has no argument.</param>
      <param name="locationFile">File that caused the error, or <c>null</c> if
            the file is unknown or does not apply.</param>
      <param name="locationLine"> Position (line) in the file that caused the error,
            or <see cref="F:PostSharp.Extensibility.Message.NotAvailable" /> if the line is 
            unknown or does not apply.</param>
    </member>
    <member name="M:PostSharp.Extensibility.MessageSource.Write(PostSharp.Extensibility.SeverityType,System.String,System.Object[],System.String)">
      <summary>
            Emits a <see cref="T:PostSharp.Extensibility.Message" /> and specifies the source file name..
            </summary>
      <param name="severity">Message severify (fatal error, error, info, debug).</param>
      <param name="messageId">Identifier of the message type.</param>
      <param name="arguments">Array of arguments used to format the message text,
            or <c>null</c> if this message has no argument.</param>
      <param name="locationFile">File that caused the error, or <c>null</c> if
            the file is unknown or does not apply.</param>
    </member>
    <member name="M:PostSharp.Extensibility.MessageSource.Write(PostSharp.Extensibility.SeverityType,System.String,System.Object[])">
      <summary>
            Emits a <see cref="T:PostSharp.Extensibility.Message" /> without specifying the location of the error.
            </summary>
      <param name="severity">Message severify (fatal error, error, info, debug).</param>
      <param name="messageId">Identifier of the message type.</param>
      <param name="arguments">Array of arguments used to format the message text,
            or <c>null</c> if this message has no argument.</param>
    </member>
    <member name="M:PostSharp.Extensibility.MessageSource.Write(PostSharp.Extensibility.SeverityType,System.String,System.Object[],PostSharp.CodeModel.SymbolSequencePoint)">
      <summary>
            Emits a <see cref="T:PostSharp.Extensibility.Message" /> and specifies the error location using a <see cref="T:PostSharp.CodeModel.SymbolSequencePoint" />.
            </summary>
      <param name="severity">Message severify (fatal error, error, info, debug).</param>
      <param name="messageId">Identifier of the message type.</param>
      <param name="arguments">Array of arguments used to format the message text,
            or <c>null</c> if this message has no argument.</param>
      <param name="symbolSequencePoint">Location of the problem in source code..</param>
    </member>
    <member name="M:PostSharp.Extensibility.MessageSource.Write(PostSharp.Extensibility.Message)">
      <inheritdoc />
    </member>
    <member name="P:PostSharp.Extensibility.MessageSource.MessageSink">
      <summary>
            Gets the current message sink.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.MulticastAttributeUsageAttribute">
      <summary>
            Custom attribute that determines the usage of a <see cref="T:PostSharp.Extensibility.MulticastAttribute" />.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.MulticastAttributeUsageAttribute.#ctor(PostSharp.Extensibility.MulticastTargets)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.MulticastAttributeUsageAttribute" />.
            </summary>
      <param name="validOn">Kinds of targets that instances of the related <see cref="T:PostSharp.Extensibility.MulticastAttribute" />
            apply to.</param>
    </member>
    <member name="P:PostSharp.Extensibility.MulticastAttributeUsageAttribute.ValidOn">
      <summary>
            Gets the kinds of targets that instances of the related <see cref="T:PostSharp.Extensibility.MulticastAttribute" />
            apply to.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.MulticastAttributeUsageAttribute.AllowMultiple">
      <summary>
            Determines wether many instances of the custom attribute are allowed on a single declaration.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.MulticastAttributeUsageAttribute.Inheritance">
      <summary>
            Determines wether the custom attribute in inherited along the lines of inheritance
            of the target element.
            </summary>
      <seealso cref="P:PostSharp.Extensibility.MulticastAttribute.AttributeInheritance" />
    </member>
    <member name="P:PostSharp.Extensibility.MulticastAttributeUsageAttribute.AllowExternalAssemblies">
      <summary>
            Determines whether this attribute can be applied to declaration of external assemblies
            (i.e. to other assemblies than the one in which the custom attribute is instanciated).
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.MulticastAttributeUsageAttribute.PersistMetaData">
      <summary>
            Determines whether the custom attribute should be persisted in metadata, so that
            it would be available for <b>System.Reflection</b>.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.MulticastAttributeUsageAttribute.TargetMemberAttributes">
      <summary>
            Gets or sets the attributes of the members (fields or methods) to which
            the custom attribute can be applied.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.MulticastAttributeUsageAttribute.TargetParameterAttributes">
      <summary>
            Gets or sets the attributes of the parameter to which
            the custom attribute can be applied.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.MulticastAttributeUsageAttribute.TargetTypeAttributes">
      <summary>
            Gets or sets the attributes of the types to which
            the custom attribute can be applied. If the custom attribute relates to
            fields or methods, this property specifies which attributes
            of the declaring type are acceptable.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.MulticastTargets">
      <summary>
            Kinds of targets to which multicast custom attributes (<see cref="T:PostSharp.Extensibility.MulticastAttribute" />)
            can apply.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastTargets.Default">
      <summary>
            Specifies that the set of target elements is inherited from
            the parent custom attribute.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastTargets.Class">
      <summary>
            Class.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastTargets.Struct">
      <summary>
            Structure.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastTargets.Enum">
      <summary>
            Enumeration.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastTargets.Delegate">
      <summary>
            Delegate.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastTargets.Interface">
      <summary>
            Interface.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastTargets.AnyType">
      <summary>
            Any type (<see cref="F:PostSharp.Extensibility.MulticastTargets.Class" />, <see cref="F:PostSharp.Extensibility.MulticastTargets.Struct" />, <see cref="F:PostSharp.Extensibility.MulticastTargets.Enum" />,
            <see cref="F:PostSharp.Extensibility.MulticastTargets.Delegate" /> or <see cref="F:PostSharp.Extensibility.MulticastTargets.Interface" />).
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastTargets.Field">
      <summary>
            Field.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastTargets.Method">
      <summary>
            Method (but not constructor).
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastTargets.Constructor">
      <summary>
            Constructor.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastTargets.InstanceConstructor">
      <summary>
            Instance constructor.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastTargets.StaticConstructor">
      <summary>
            Static constructor.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastTargets.Property">
      <summary>
            Property (but not methods inside the property).
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastTargets.Event">
      <summary>
            Event (but not methods inside the event).
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastTargets.AnyMember">
      <summary>
            Any member (<see cref="F:PostSharp.Extensibility.MulticastTargets.Field" />, <see cref="F:PostSharp.Extensibility.MulticastTargets.Method" />, <see cref="F:PostSharp.Extensibility.MulticastTargets.InstanceConstructor" />,
            <see cref="F:PostSharp.Extensibility.MulticastTargets.StaticConstructor" />,
            <see cref="F:PostSharp.Extensibility.MulticastTargets.Property" />, <see cref="F:PostSharp.Extensibility.MulticastTargets.Event" />).
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastTargets.Assembly">
      <summary>
            Assembly.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastTargets.Parameter">
      <summary>
            Method or property parameter.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastTargets.ReturnValue">
      <summary>
            Method or property return value.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastTargets.All">
      <summary>
            All element kinds.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.MulticastAttributes">
      <summary>
            Attributes of elements to which multicast custom attributes (<see cref="T:PostSharp.Extensibility.MulticastAttribute" />)
            apply.
            </summary>
      <remarks>
            When specifying attributes of target members or types, do not forget to provide
            <i>all</i> categories of flags, not only the category on which you want to put
            a restriction. If you want to limit, for instance, a custom attribute to be
            applied on public members, a good pratice is to set 
            <c>TargetMemberAttributes = MulticastAttributes.Public | ~MulticastAttributes.AnyVisibility</c>,
            unless the parent is more restrictive, in which case you should specify attributes
            explicitely.
            </remarks>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastAttributes.Default">
      <summary>
            Specifies that the set of target attributes is inherited from
            the parent custom attribute.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastAttributes.Private">
      <summary>
            Private (visible inside the current type).
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastAttributes.Protected">
      <summary>
            Protected (visible inside derived types).
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastAttributes.Internal">
      <summary>
            Internal (visible inside the current assembly).
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastAttributes.InternalAndProtected">
      <summary>
            Internal <i>and</i> protected (visible inside derived types that are defined in the current assembly).
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastAttributes.InternalOrProtected">
      <summary>
            Internal <i>or</i> protected (visible inside all derived types and in the current assembly).
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastAttributes.Public">
      <summary>
            Public (visible everywhere).
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastAttributes.AnyVisibility">
      <summary>
            Any visibility.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastAttributes.Static">
      <summary>
            Static scope.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastAttributes.Instance">
      <summary>
            Instance scope.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastAttributes.AnyScope">
      <summary>
            Any scope (<see cref="F:PostSharp.Extensibility.MulticastAttributes.Static" /> | <see cref="F:PostSharp.Extensibility.MulticastAttributes.Instance" />).
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastAttributes.Abstract">
      <summary>
            Abstract methods.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastAttributes.NonAbstract">
      <summary>
            Concrete (non-abstract) methods. 
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastAttributes.AnyAbstraction">
      <summary>
            Any abstraction (<see cref="F:PostSharp.Extensibility.MulticastAttributes.Abstract" /> | <see cref="F:PostSharp.Extensibility.MulticastAttributes.NonAbstract" />).
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastAttributes.Virtual">
      <summary>
            Virtual methods. 
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastAttributes.NonVirtual">
      <summary>
            Non-virtual methods.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastAttributes.AnyVirtuality">
      <summary>
            Any virtuality (<see cref="F:PostSharp.Extensibility.MulticastAttributes.Virtual" /> | <see cref="F:PostSharp.Extensibility.MulticastAttributes.NonVirtual" />).
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastAttributes.Managed">
      <summary>
            Managed code implemetation.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastAttributes.NonManaged">
      <summary>
            Non-managed code implementation (external or system).
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastAttributes.AnyImplementation">
      <summary>
            Any implementation (<see cref="F:PostSharp.Extensibility.MulticastAttributes.Managed" /> | <see cref="F:PostSharp.Extensibility.MulticastAttributes.NonManaged" />).
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastAttributes.Literal">
      <summary>
            Literal fields.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastAttributes.NonLiteral">
      <summary>
            Non-literal fields.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastAttributes.AnyLiterality">
      <summary>
            Any field literality (<see cref="F:PostSharp.Extensibility.MulticastAttributes.Literal" /> | <see cref="F:PostSharp.Extensibility.MulticastAttributes.NonLiteral" />).
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastAttributes.InParameter">
      <summary>
            Input parameters.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastAttributes.CompilerGenerated">
      <summary>
            Compiler-generated code (for instance closure types of anonymous method, iterator type, ...).
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastAttributes.UserGenerated">
      <summary>
            User-generated code (anything expected <see cref="F:PostSharp.Extensibility.MulticastAttributes.CompilerGenerated" />).
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastAttributes.AnyGeneration">
      <summary>
            Any code generation (<see cref="F:PostSharp.Extensibility.MulticastAttributes.CompilerGenerated" /> | <see cref="F:PostSharp.Extensibility.MulticastAttributes.UserGenerated" />)l
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastAttributes.OutParameter">
      <summary>
            Output (<b>out</b> in C#) parameters.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastAttributes.RefParameter">
      <summary>
            Input/Output (<b>ref</b> in C#) parameters.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastAttributes.AnyParameter">
      <summary>
            Any kind of parameter passing (<see cref="F:PostSharp.Extensibility.MulticastAttributes.InParameter" /> | <see cref="F:PostSharp.Extensibility.MulticastAttributes.OutParameter" /> | <see cref="F:PostSharp.Extensibility.MulticastAttributes.RefParameter" />).
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastAttributes.All">
      <summary>
            All members.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.MulticastInheritance">
      <summary>
            Kind of inheritance of <see cref="T:PostSharp.Extensibility.MulticastAttribute" />.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastInheritance.None">
      <summary>
            No inheritance.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastInheritance.Strict">
      <summary>
            The instance is inherited to children of the original element,
            but multicasting is not applied to members of children.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.MulticastInheritance.Multicast">
      <summary>
            The instance is inherited to children of the original element
            and multicasting is applied to members of children.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.HasInheritedAttributeAttribute">
      <summary>
        <b>Internal Only.</b> Custom attribute used internally by <c>PostSharp</c> to mark
            elements having inherited custom attributes. This custom attribute should not
            be used in custom code, otherwise <c>PostSharp</c> may not work properly.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.HasInheritedAttributeAttribute.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.HasInheritedAttributeAttribute" />.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.HasInheritedAttributeAttribute.#ctor(System.Int64[])">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.HasInheritedAttributeAttribute" />.
            </summary>
      <param name="ids">List of pooled inherited instances present on the target element
            of the current <see cref="T:PostSharp.Extensibility.HasInheritedAttributeAttribute" /> instance.</param>
    </member>
    <member name="T:PostSharp.Extensibility.IProject">
      <summary>
            Provides information about the currently executing project.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.IProject.EvaluateExpression(System.String)">
      <summary>
            Evaluates an expression (that is, replace parameters by their actual value).
            </summary>
      <param name="expression">An expression.</param>
      <returns>The evaluated expression, or <c>null</c> if one parameter could not be
            resolved.</returns>
    </member>
    <member name="M:PostSharp.Extensibility.IProject.GetFrameworkVariant">
      <summary>
            Gets the variant of the .NET Framework against which the .NET assembly
            currently processed is linked.
            </summary>
      <returns>A string uniquely identifying the framework variant, to be compared
            to the constants defined in the <see cref="T:PostSharp.Extensibility.FrameworkVariants" /> class.
            Actually, the public key token of <b>mscorlib</b> is returned.</returns>
    </member>
    <member name="M:PostSharp.Extensibility.IProject.GetTargetAssembly(System.Boolean)">
      <summary>
            Gets the assembly that is being transformed by PostSharp.
            </summary>
      <param name="getWrapper">
        <c>false</c> if the system <see cref="T:System.Reflection.Assembly" /> has to be returned, <c>true</c> if a wrapper has to be returned.</param>
      <returns>The assembly being processed. If <paramref name="getWrapper" /> is <c>true</c>, this method returns an instance of a PostSharp internal
            type implementing the <see cref="T:System.Runtime.InteropServices._Assembly" /> interface. Otherwise, the reflection <see cref="T:System.Reflection.Assembly" /> is returned.</returns>
    </member>
    <member name="T:PostSharp.Extensibility.IPostSharpEnvironment">
      <summary>
            Provides information about the current <c>PostSharp</c> environment.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.IPostSharpEnvironment.CurrentProject">
      <summary>
            Gets the currently executing project.
            </summary>
      <value>
            The current project, or <c>null</c> if there is no current project.
            </value>
    </member>
    <member name="T:PostSharp.Extensibility.PostSharpEnvironment">
      <summary>
            Provides access to the current <c>PostSharp</c> environment (<see cref="T:PostSharp.Extensibility.IPostSharpEnvironment" />).
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.PostSharpEnvironment.Current">
      <summary>
            Gets the current <c>PostSharp</c> environment, or <c>null</c>
            if the <c>PostSharp</c> Platform is not loaded in the current
            context.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.PostSharpEnvironment.IsPostSharpRunning">
      <summary>
            Determines whether the <c>PostSharp</c> Platform is currently loaded.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.RequireReflectionWrapperAttribute">
      <summary>
            Custom attribute that, when applied on a type, specifies that all build-time semantics of this type
            require reflection wrappers to be passed instead of real reflection objects.
            </summary>
    </member>
    <member name="T:PostSharp.Post">
      <summary>
            Provides some methods that are transformed during post-compilation.
            </summary>
    </member>
    <member name="M:PostSharp.Post.Cast``2(``0)">
      <summary>
            At post-compile time, casts an instance of a type into another.
            A post-compile time error is reported if the source type cannot be
            assigned to the target type.
            </summary>
      <typeparam name="SourceType">Source type.</typeparam>
      <typeparam name="TargetType">Target type.</typeparam>
      <param name="o">Instance to be casted.</param>
      <returns>The object <paramref name="o" /> casted as <typeparamref name="TargetType" />.</returns>
      <remarks>
            The purpose of this method is to make a source code compilable even when
            an interface will be implemented at post-compile time.
            PostSharp ensures that <typeparamref name="TargetType" /> is assignable from
            <typeparamref name="SourceType" />. If yes, the call to this method is
            simply suppressed. If types are not assignable, a build error is issued.
            </remarks>
    </member>
    <member name="M:PostSharp.Post.GetValue``1(``0)">
      <summary>
            When used to retrieve the value of a field, forces the compiler to retrieve a copy
            of the field value instead of an address to this field. This allows to call
            instance methods of value-type fields without loading the field address.
            </summary>
      <typeparam name="T">Type of the value to retrieve (this type parameter can generally be omitted).</typeparam>
      <param name="value">Value.</param>
      <returns>
        <paramref name="value" />, exactly.</returns>
    </member>
    <member name="P:PostSharp.Post.IsTransformed">
      <summary>
            Determines whether the calling program has been transformed by PostSharp.
            </summary>
      <value>
        <c>true</c> if the calling program has been transformed by PostSharp, otherwise
            <c>false</c>.
            </value>
    </member>
    <member name="T:PostSharp.PostSharpTrace">
      <summary>
            Provides tracing functionality. An instance of the <see cref="T:PostSharp.PostSharpTrace" /> type
            implements a trace sink.
            </summary>
    </member>
    <member name="M:PostSharp.PostSharpTrace.#ctor(System.String)">
      <summary>
            Initialize a new <see cref="T:PostSharp.PostSharpTrace" /> sink.
            </summary>
      <param name="category">Category of messages.</param>
    </member>
    <member name="M:PostSharp.PostSharpTrace.Write(System.String,System.Object[])">
      <summary>
            Writes a message to the current sink with many formatting parameters.
            </summary>
      <param name="format">Message formatting string.</param>
      <param name="parameters">Formatting parameters.</param>
    </member>
    <member name="M:PostSharp.PostSharpTrace.Write(System.String,System.Object)">
      <summary>
            Writes a message to the current sink with a single formatting parameter.
            </summary>
      <param name="format">Message formatting string.</param>
      <param name="arg0">The first formatting parameter.</param>
    </member>
    <member name="M:PostSharp.PostSharpTrace.Write(System.String,System.Object,System.Object)">
      <summary>
            Writes a message to the current sink with two formatting parameters.
            </summary>
      <param name="format">Message formatting string.</param>
      <param name="arg0">The first formatting parameter.</param>
      <param name="arg1">The second formatting parameter.</param>
    </member>
    <member name="M:PostSharp.PostSharpTrace.Write(System.String,System.Object,System.Object,System.Object)">
      <summary>
            Writes a message to the current sink with three formatting parameters.
            </summary>
      <param name="format">Message formatting string.</param>
      <param name="arg0">The first formatting parameter.</param>
      <param name="arg1">The second formatting parameter.</param>
      <param name="arg2">The thirs formatting parameter.</param>
    </member>
    <member name="M:PostSharp.PostSharpTrace.Write(System.String)">
      <summary>
            Writes a message to the current sink without formatting parameter.
            </summary>
      <param name="message">Message.</param>
    </member>
    <member name="M:PostSharp.PostSharpTrace.WriteLine(System.String,System.Object[])">
      <summary>
            Writes a message to the current sink with many formatting parameters, and issues a line break.
            </summary>
      <param name="format">Message formatting string.</param>
      <param name="parameters">Formatting parameters.</param>
    </member>
    <member name="M:PostSharp.PostSharpTrace.WriteLine(System.String,System.Object)">
      <summary>
            Writes a message to the current sink with a single formatting parameter, 
            and issues a line break.
            </summary>
      <param name="format">Message formatting string.</param>
      <param name="arg0">The first formatting parameter.</param>
    </member>
    <member name="M:PostSharp.PostSharpTrace.WriteLine(System.String,System.Object,System.Object)">
      <summary>
            Writes a message to the current sink with two formatting parameters, 
            and issues a line break.
            </summary>
      <param name="format">Message formatting string.</param>
      <param name="arg0">The first formatting parameter.</param>
      <param name="arg1">The second formatting parameter.</param>
    </member>
    <member name="M:PostSharp.PostSharpTrace.WriteLine(System.String,System.Object,System.Object,System.Object)">
      <summary>
            Writes a message to the current sink with three formatting parameters, 
            and issues a line break.
            </summary>
      <param name="format">Message formatting string.</param>
      <param name="arg0">The first formatting parameter.</param>
      <param name="arg1">The second formatting parameter.</param>
      <param name="arg2">The thirs formatting parameter.</param>
    </member>
    <member name="M:PostSharp.PostSharpTrace.WriteLine(System.String)">
      <summary>
            Writes a message to the current sink without parameter, 
            and issues a line break.
            </summary>
      <param name="format">Message formatting string.</param>
    </member>
    <member name="M:PostSharp.PostSharpTrace.EnableCategory(PostSharp.PostSharpTrace)">
      <summary>
            Enables a trace category known by its object.
            </summary>
      <param name="category">A <see cref="T:PostSharp.PostSharpTrace" /> object.</param>
    </member>
    <member name="M:PostSharp.PostSharpTrace.EnableCategory(System.String)">
      <summary>
            Enables a trace category known by its name.
            </summary>
      <param name="category">The category name.</param>
    </member>
    <member name="P:PostSharp.PostSharpTrace.Enabled">
      <summary>
            Determines whether the current trace sink is enabled.
            </summary>
    </member>
    <member name="T:PostSharp.Reflection.CustomReflectionBinder">
      <summary>
            Custom implementation of a reflection <see cref="T:System.Reflection.Binder" /> that select
            methods based on exact matches using the <see cref="T:PostSharp.Reflection.ReflectionTypeComparer" />.
            </summary>
    </member>
    <member name="F:PostSharp.Reflection.CustomReflectionBinder.Instance">
      <summary>
            Singleton instance.
            </summary>
    </member>
    <member name="M:PostSharp.Reflection.CustomReflectionBinder.BindToField(System.Reflection.BindingFlags,System.Reflection.FieldInfo[],System.Object,System.Globalization.CultureInfo)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Reflection.CustomReflectionBinder.BindToMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Object[]@,System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[],System.Object@)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Reflection.CustomReflectionBinder.ChangeType(System.Object,System.Type,System.Globalization.CultureInfo)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Reflection.CustomReflectionBinder.ReorderArgumentArray(System.Object[]@,System.Object)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Reflection.CustomReflectionBinder.SelectMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Type[],System.Reflection.ParameterModifier[])">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Reflection.CustomReflectionBinder.SelectProperty(System.Reflection.BindingFlags,System.Reflection.PropertyInfo[],System.Type,System.Type[],System.Reflection.ParameterModifier[])">
      <inheritdoc />
    </member>
    <member name="T:PostSharp.Reflection.GenericArg">
      <summary>
            Classes derived from <see cref="T:PostSharp.Reflection.GenericArg" /> represent unbound generic arguments.
            It is a 'trick' to create unbound generic instances, because C# and <b>System.Reflection</b>
            does not make it possible. Use the <see cref="M:PostSharp.Reflection.GenericArg.Map(System.Type,System.Type[],System.Type[])" /> method to bind the unbound
            generic arguments to concrete types.
            </summary>
    </member>
    <member name="M:PostSharp.Reflection.GenericArg.Map(System.Type,System.Type[],System.Type[])">
      <summary>
            Binds unbound generic arguments to concrete types.
            </summary>
      <param name="type">A <see cref="T:System.Type" /> containing unbound generic arguments
            (derived from <see cref="T:PostSharp.Reflection.GenericArg" />).</param>
      <param name="genericTypeParameters">Array of types to which
            the unbound generic type arguments should be bound.</param>
      <param name="genericMethodParameters">Array of types to which
            the unbound generic method parameters should be bound.</param>
      <returns>A <see cref="T:System.Type" /> where unbound generic arguments have been replaced
            by <paramref name="genericTypeParameters" /> and <paramref name="genericMethodParameters" />.</returns>
    </member>
    <member name="T:PostSharp.Reflection.GenericTypeArg">
      <summary>
            Classes derived from <see cref="T:PostSharp.Reflection.GenericTypeArg" /> represent unbound generic type parameters.
            </summary>
      <seealso cref="T:PostSharp.Reflection.GenericArg" />
    </member>
    <member name="T:PostSharp.Reflection.GenericMethodArg">
      <summary>
            Classes derived from <see cref="T:PostSharp.Reflection.GenericMethodArg" /> represent unbound generic method parameters.
            </summary>
      <seealso cref="T:PostSharp.Reflection.GenericArg" />
    </member>
    <member name="T:PostSharp.Reflection.GenericTypeArg0">
      <summary>
            Unbound generic type argument. Reference to the 0-th generic type argument.
            </summary>
      <seealso cref="M:PostSharp.Reflection.GenericArg.Map(System.Type,System.Type[],System.Type[])" />
      <seealso cref="T:PostSharp.Reflection.GenericArg" />
    </member>
    <member name="T:PostSharp.Reflection.GenericTypeArg1">
      <summary>
            Unbound generic type argument. Reference to the 1-th generic type argument.
            </summary>
      <seealso cref="M:PostSharp.Reflection.GenericArg.Map(System.Type,System.Type[],System.Type[])" />
      <seealso cref="T:PostSharp.Reflection.GenericArg" />
    </member>
    <member name="T:PostSharp.Reflection.GenericTypeArg2">
      <summary>
            Unbound generic type argument. Reference to the 2-th generic type argument.
            </summary>
      <seealso cref="M:PostSharp.Reflection.GenericArg.Map(System.Type,System.Type[],System.Type[])" />
      <seealso cref="T:PostSharp.Reflection.GenericArg" />
    </member>
    <member name="T:PostSharp.Reflection.GenericTypeArg3">
      <summary>
            Unbound generic type argument. Reference to the 3-th generic type argument.
            </summary>
      <seealso cref="M:PostSharp.Reflection.GenericArg.Map(System.Type,System.Type[],System.Type[])" />
      <seealso cref="T:PostSharp.Reflection.GenericArg" />
    </member>
    <member name="T:PostSharp.Reflection.GenericTypeArg4">
      <summary>
            Unbound generic type argument. Reference to the 4-th generic type argument.
            </summary>
      <seealso cref="M:PostSharp.Reflection.GenericArg.Map(System.Type,System.Type[],System.Type[])" />
      <seealso cref="T:PostSharp.Reflection.GenericArg" />
    </member>
    <member name="T:PostSharp.Reflection.GenericTypeArg5">
      <summary>
            Unbound generic type argument. Reference to the 5-th generic type argument.
            </summary>
      <seealso cref="M:PostSharp.Reflection.GenericArg.Map(System.Type,System.Type[],System.Type[])" />
      <seealso cref="T:PostSharp.Reflection.GenericArg" />
    </member>
    <member name="T:PostSharp.Reflection.GenericTypeArg6">
      <summary>
            Unbound generic type argument. Reference to the 6-th generic type argument.
            </summary>
      <seealso cref="M:PostSharp.Reflection.GenericArg.Map(System.Type,System.Type[],System.Type[])" />
      <seealso cref="T:PostSharp.Reflection.GenericArg" />
    </member>
    <member name="T:PostSharp.Reflection.GenericTypeArg7">
      <summary>
            Unbound generic type argument. Reference to the 7-th generic type argument.
            </summary>
      <seealso cref="M:PostSharp.Reflection.GenericArg.Map(System.Type,System.Type[],System.Type[])" />
      <seealso cref="T:PostSharp.Reflection.GenericArg" />
    </member>
    <member name="T:PostSharp.Reflection.GenericTypeArg8">
      <summary>
            Unbound generic type argument. Reference to the 8-th generic type argument.
            </summary>
      <seealso cref="M:PostSharp.Reflection.GenericArg.Map(System.Type,System.Type[],System.Type[])" />
      <seealso cref="T:PostSharp.Reflection.GenericArg" />
    </member>
    <member name="T:PostSharp.Reflection.GenericTypeArg9">
      <summary>
            Unbound generic type argument. Reference to the 9-th generic type argument.
            </summary>
      <seealso cref="M:PostSharp.Reflection.GenericArg.Map(System.Type,System.Type[],System.Type[])" />
      <seealso cref="T:PostSharp.Reflection.GenericArg" />
    </member>
    <member name="T:PostSharp.Reflection.GenericMethodArg0">
      <summary>
            Unbound generic method argument. Reference to the 0-th generic method argument.
            </summary>
      <seealso cref="M:PostSharp.Reflection.GenericArg.Map(System.Type,System.Type[],System.Type[])" />
      <seealso cref="T:PostSharp.Reflection.GenericArg" />
    </member>
    <member name="T:PostSharp.Reflection.GenericMethodArg1">
      <summary>
            Unbound generic method argument. Reference to the 1-th generic method argument.
            </summary>
      <seealso cref="M:PostSharp.Reflection.GenericArg.Map(System.Type,System.Type[],System.Type[])" />
      <seealso cref="T:PostSharp.Reflection.GenericArg" />
    </member>
    <member name="T:PostSharp.Reflection.GenericMethodArg2">
      <summary>
            Unbound generic method argument. Reference to the 2-th generic method argument.
            </summary>
      <seealso cref="M:PostSharp.Reflection.GenericArg.Map(System.Type,System.Type[],System.Type[])" />
      <seealso cref="T:PostSharp.Reflection.GenericArg" />
    </member>
    <member name="T:PostSharp.Reflection.GenericMethodArg3">
      <summary>
            Unbound generic method argument. Reference to the 3-th generic method argument.
            </summary>
      <seealso cref="M:PostSharp.Reflection.GenericArg.Map(System.Type,System.Type[],System.Type[])" />
      <seealso cref="T:PostSharp.Reflection.GenericArg" />
    </member>
    <member name="T:PostSharp.Reflection.GenericMethodArg4">
      <summary>
            Unbound generic method argument. Reference to the 4-th generic method argument.
            </summary>
      <seealso cref="M:PostSharp.Reflection.GenericArg.Map(System.Type,System.Type[],System.Type[])" />
      <seealso cref="T:PostSharp.Reflection.GenericArg" />
    </member>
    <member name="T:PostSharp.Reflection.GenericMethodArg5">
      <summary>
            Unbound generic method argument. Reference to the 5-th generic method argument.
            </summary>
      <seealso cref="M:PostSharp.Reflection.GenericArg.Map(System.Type,System.Type[],System.Type[])" />
      <seealso cref="T:PostSharp.Reflection.GenericArg" />
    </member>
    <member name="T:PostSharp.Reflection.GenericMethodArg6">
      <summary>
            Unbound generic method argument. Reference to the 6-th generic method argument.
            </summary>
      <seealso cref="M:PostSharp.Reflection.GenericArg.Map(System.Type,System.Type[],System.Type[])" />
      <seealso cref="T:PostSharp.Reflection.GenericArg" />
    </member>
    <member name="T:PostSharp.Reflection.GenericMethodArg7">
      <summary>
            Unbound generic method argument. Reference to the 7-th generic method argument.
            </summary>
      <seealso cref="M:PostSharp.Reflection.GenericArg.Map(System.Type,System.Type[],System.Type[])" />
      <seealso cref="T:PostSharp.Reflection.GenericArg" />
    </member>
    <member name="T:PostSharp.Reflection.GenericMethodArg8">
      <summary>
            Unbound generic method argument. Reference to the 8-th generic method argument.
            </summary>
      <seealso cref="M:PostSharp.Reflection.GenericArg.Map(System.Type,System.Type[],System.Type[])" />
      <seealso cref="T:PostSharp.Reflection.GenericArg" />
    </member>
    <member name="T:PostSharp.Reflection.GenericMethodArg9">
      <summary>
            Unbound generic method argument. Reference to the 9-th generic method argument.
            </summary>
      <seealso cref="M:PostSharp.Reflection.GenericArg.Map(System.Type,System.Type[],System.Type[])" />
      <seealso cref="T:PostSharp.Reflection.GenericArg" />
    </member>
    <member name="T:PostSharp.CodeModel.ReflectionWrapper.IAssemblyWrapper">
      <summary>
            Represents an <see cref="T:System.Reflection.Assembly" /> without giving directly the <see cref="T:System.Reflection.Assembly" />
            object. The object allows browsing of contained types and of custom attributes.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.ReflectionWrapper.IAssemblyWrapper.GetTypes">
      <summary>
            Gets the list of types defined in this assembly.
            </summary>
      <returns>The list of types defined in this assembly.</returns>
      <remarks>
            This method does not return nested types.
            </remarks>
    </member>
    <member name="P:PostSharp.CodeModel.ReflectionWrapper.IAssemblyWrapper.UnderlyingSystemAssembly">
      <summary>
            Gets the system <see cref="T:System.Reflection.Assembly" /> corresponding to the current object.
            </summary>
    </member>
    <member name="T:PostSharp.Reflection.LocationInfo">
      <summary>
            Represents a <see cref="T:System.Reflection.FieldInfo" />, <see cref="T:System.Reflection.PropertyInfo" /> or
            <see cref="T:System.Reflection.ParameterInfo" />, which all have the semantics of a location (get value, set value).
            </summary>
    </member>
    <member name="M:PostSharp.Reflection.LocationInfo.#ctor(System.Reflection.FieldInfo)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Reflection.LocationInfo" /> from a <see cref="T:System.Reflection.FieldInfo" />.
            </summary>
      <param name="fieldInfo">The field represented by the <see cref="T:PostSharp.Reflection.LocationInfo" />.</param>
    </member>
    <member name="M:PostSharp.Reflection.LocationInfo.#ctor(System.Reflection.PropertyInfo)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Reflection.LocationInfo" /> from a <see cref="T:System.Reflection.PropertyInfo" />.
            </summary>
      <param name="propertyInfo">The property represented by the <see cref="T:PostSharp.Reflection.LocationInfo" />.</param>
    </member>
    <member name="M:PostSharp.Reflection.LocationInfo.#ctor(System.Reflection.ParameterInfo)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Reflection.LocationInfo" /> from a <see cref="T:System.Reflection.ParameterInfo" />.
            </summary>
      <param name="parameterInfo">The parameter represented by the <see cref="T:PostSharp.Reflection.LocationInfo" />.</param>
    </member>
    <member name="M:PostSharp.Reflection.LocationInfo.ToLocationInfo(System.Object)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Reflection.LocationInfo" /> from a
            <see cref="T:System.Reflection.FieldInfo" />, <see cref="T:System.Reflection.PropertyInfo" />, or <see cref="T:System.Reflection.ParameterInfo" />.
            </summary>
      <param name="reflectionInfo" />
      <returns />
    </member>
    <member name="M:PostSharp.Reflection.LocationInfo.ToLocationInfoArray(System.Collections.Generic.ICollection{System.Reflection.FieldInfo})">
      <summary>
            Converts a collection of <see cref="P:PostSharp.Reflection.LocationInfo.FieldInfo" /> into an array of <see cref="T:PostSharp.Reflection.LocationInfo" />.
            </summary>
      <param name="fields">A collection of <see cref="P:PostSharp.Reflection.LocationInfo.FieldInfo" />.</param>
      <returns>An array of <see cref="T:PostSharp.Reflection.LocationInfo" />.</returns>
    </member>
    <member name="M:PostSharp.Reflection.LocationInfo.ToLocationInfoArray(System.Collections.Generic.ICollection{System.Reflection.PropertyInfo})">
      <summary>
            Converts a collection of <see cref="P:PostSharp.Reflection.LocationInfo.PropertyInfo" /> into an array of <see cref="T:PostSharp.Reflection.LocationInfo" />.
            </summary>
      <param name="properties">A collection of <see cref="P:PostSharp.Reflection.LocationInfo.PropertyInfo" />.</param>
      <returns>An array of <see cref="T:PostSharp.Reflection.LocationInfo" />.</returns>
    </member>
    <member name="M:PostSharp.Reflection.LocationInfo.ToLocationInfoArray(System.Collections.Generic.ICollection{System.Reflection.ParameterInfo})">
      <summary>
            Converts a collection of <see cref="P:PostSharp.Reflection.LocationInfo.ParameterInfo" /> into an array of <see cref="T:PostSharp.Reflection.LocationInfo" />.
            </summary>
      <param name="parameters">A collection of <see cref="P:PostSharp.Reflection.LocationInfo.ParameterInfo" />.</param>
      <returns>An array of <see cref="T:PostSharp.Reflection.LocationInfo" />.</returns>
    </member>
    <member name="M:PostSharp.Reflection.LocationInfo.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Reflection.LocationInfo.ToString">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Reflection.LocationInfo.Equals(System.Object)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Reflection.LocationInfo.GetHashCode">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Reflection.LocationInfo.Equals(PostSharp.Reflection.LocationInfo)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Reflection.LocationInfo.op_Equality(PostSharp.Reflection.LocationInfo,PostSharp.Reflection.LocationInfo)">
      <summary>
            Determines whether two instances of <see cref="T:PostSharp.Reflection.LocationInfo" /> represent the same element of code.
            </summary>
      <param name="left">A <see cref="T:PostSharp.Reflection.LocationInfo" />.</param>
      <param name="right">A <see cref="T:PostSharp.Reflection.LocationInfo" />.</param>
      <returns>
        <c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal, otherwise <c>false</c>.</returns>
    </member>
    <member name="M:PostSharp.Reflection.LocationInfo.op_Inequality(PostSharp.Reflection.LocationInfo,PostSharp.Reflection.LocationInfo)">
      <summary>
            Determines whether two instances of <see cref="T:PostSharp.Reflection.LocationInfo" /> represent different elements of code.
            </summary>
      <param name="left">A <see cref="T:PostSharp.Reflection.LocationInfo" />.</param>
      <param name="right">A <see cref="T:PostSharp.Reflection.LocationInfo" />.</param>
      <returns>
        <c>true</c> if <paramref name="left" /> and <paramref name="right" /> are different, otherwise <c>false</c>.</returns>
    </member>
    <member name="P:PostSharp.Reflection.LocationInfo.LocationType">
      <summary>
            Gets the type of values that can be stored in the location.
            </summary>
    </member>
    <member name="P:PostSharp.Reflection.LocationInfo.LocationKind">
      <summary>
            Gets the location kind (<see cref="F:PostSharp.Reflection.LocationKind.Field" />,
            <see cref="F:PostSharp.Reflection.LocationKind.Property" />,
            <see cref="F:PostSharp.Reflection.LocationKind.Parameter" /> or
            <see cref="F:PostSharp.Reflection.LocationKind.ReturnValue" />).
            </summary>
    </member>
    <member name="P:PostSharp.Reflection.LocationInfo.PropertyInfo">
      <summary>
            Gets the underlying <see cref="T:System.Reflection.PropertyInfo" />,
            or <c>null</c> if the underlying code element is not a property.
            </summary>
    </member>
    <member name="P:PostSharp.Reflection.LocationInfo.FieldInfo">
      <summary>
            Gets the underlying <see cref="T:System.Reflection.FieldInfo" />,
            or <c>null</c> if the underlying code element is not a property.
            </summary>
    </member>
    <member name="P:PostSharp.Reflection.LocationInfo.ParameterInfo">
      <summary>
            Gets the underlying <see cref="T:System.Reflection.ParameterInfo" />,
            or <c>null</c> if the underlying code element is not a property.
            </summary>
    </member>
    <member name="P:PostSharp.Reflection.LocationInfo.DeclaringType">
      <summary>
            Gets the declaring type of the underlying field, property, parameter, or return value.
            </summary>
    </member>
    <member name="P:PostSharp.Reflection.LocationInfo.Name">
      <summary>
            Gets the name of the underlying field, property, parameter, or return value.
            </summary>
    </member>
    <member name="P:PostSharp.Reflection.LocationInfo.IsStatic">
      <summary>
            Determines wether the underlying field or property is static.
            </summary>
    </member>
    <member name="T:PostSharp.Reflection.LocationKind">
      <summary>
            Enumerates the kinds of code elements that can be encapsulated by a <see cref="T:PostSharp.Reflection.LocationInfo" />.
            </summary>
    </member>
    <member name="F:PostSharp.Reflection.LocationKind.Field">
      <summary>
        <see cref="T:System.Reflection.FieldInfo" />.
            </summary>
    </member>
    <member name="F:PostSharp.Reflection.LocationKind.Property">
      <summary>
        <see cref="T:System.Reflection.PropertyInfo" />.
            </summary>
    </member>
    <member name="F:PostSharp.Reflection.LocationKind.Parameter">
      <summary>
            A <see cref="T:System.Reflection.ParameterInfo" /> representing a parameter (not a <see cref="F:PostSharp.Reflection.LocationKind.ReturnValue" />).
            </summary>
    </member>
    <member name="F:PostSharp.Reflection.LocationKind.ReturnValue">
      <summary>
            A <see cref="T:System.Reflection.ParameterInfo" /> representing a return value.
            </summary>
    </member>
    <member name="T:PostSharp.Reflection.ObjectConstruction">
      <summary>
            Specifies how an object should be constructed, i.e. specifies the constructor to be
            used, the arguments to be passed to this constructor, and the fields or properties to
            be set.
            </summary>
    </member>
    <member name="M:PostSharp.Reflection.ObjectConstruction.#ctor(System.String,System.Object[])">
      <summary>
            Initializes a new type-unsafe <see cref="T:PostSharp.Reflection.ObjectConstruction" />.
            </summary>
      <param name="typeName">Name of the object type.</param>
      <param name="constructorArguments">Arguments passed to the constructor.</param>
    </member>
    <member name="M:PostSharp.Reflection.ObjectConstruction.#ctor(System.Reflection.ConstructorInfo,System.Object[])">
      <summary>
            Initializes a new type-safe <see cref="T:PostSharp.Reflection.ObjectConstruction" /> from a <see cref="T:System.Reflection.ConstructorInfo" />.
            </summary>
      <param name="constructor">Constructor.</param>
      <param name="constructorArguments">Arguments passed to the constructor.</param>
    </member>
    <member name="P:PostSharp.Reflection.ObjectConstruction.TypeName">
      <summary>
            Gets the assembly-qualified type name of the object.
            </summary>
    </member>
    <member name="P:PostSharp.Reflection.ObjectConstruction.Constructor">
      <summary>
            Gets the custom attribute constructor.
            </summary>
    </member>
    <member name="P:PostSharp.Reflection.ObjectConstruction.ConstructorArguments">
      <summary>
            Gets the arguments passed to the custom attribute constructor.
            </summary>
    </member>
    <member name="P:PostSharp.Reflection.ObjectConstruction.NamedArguments">
      <summary>
            Gets the collection of named arguments.
            </summary>
      <remarks>
            This collection is a dictionary associating the name of public a field or property of the
            custom attributes to the value that should be assigned to it.
            </remarks>
    </member>
    <member name="T:PostSharp.Reflection.ReflectionHelper">
      <summary>
            Provides helper methods for work with <see cref="N:System.Reflection" />.
            </summary>
    </member>
    <member name="M:PostSharp.Reflection.ReflectionHelper.GetProperty(System.Type,System.String,System.String)">
      <summary>
            Identifies and gets a property in a type given its complete string-serialized signature.
            </summary>
      <param name="type">Type declaring the property.</param>
      <param name="propertyName">Property name.</param>
      <param name="propertySignature">Property signature (from <c>PropertyInfo.ToString</c>).</param>
      <returns>The property, or <c>null</c> if the property was not found.</returns>
    </member>
    <member name="M:PostSharp.Reflection.ReflectionHelper.GetMethod(System.Type,System.String,System.String)">
      <summary>
            Identifies and gets a method in a type given its complete string-serialized signature.
            </summary>
      <param name="type">Type declaring the method.</param>
      <param name="methodName">Method name.</param>
      <param name="methodSignature">Method signature (from <c>MethodBase.ToString()</c>).</param>
      <returns>The method (or constructor) with signature <paramref name="methodSignature" />
            in <paramref name="type" />, or <c>null</c> if such method was not found.</returns>
    </member>
    <member name="T:PostSharp.Reflection.ReflectionTypeComparer">
      <summary>
            Comparer of reflection types (<see cref="T:System.Type" />) based on content, not reference.
            Supports the unbound generic parameters derived from the <see cref="T:PostSharp.Reflection.GenericArg" /> class. 
            </summary>
      <remarks>
            Used by the <see cref="T:PostSharp.Reflection.CustomReflectionBinder" /> class.
            </remarks>
    </member>
    <member name="M:PostSharp.Reflection.ReflectionTypeComparer.GetInstance">
      <summary>
            Gets an instance of <see cref="T:PostSharp.Reflection.ReflectionTypeComparer" /> that does not perform
            substitution of generic parameters.
            </summary>
      <returns>An instance of <see cref="T:PostSharp.Reflection.ReflectionTypeComparer" />.</returns>
    </member>
    <member name="M:PostSharp.Reflection.ReflectionTypeComparer.GetInstance(System.Type[],System.Type[],System.Type[],System.Type[])">
      <summary>
            Gets an instance of <see cref="T:PostSharp.Reflection.ReflectionTypeComparer" /> that performs
            substitution of generic parameters.
            </summary>
      <param name="leftGenericMethodParameters">Array of types to be substituded to the
            generic method parameters of the left member.</param>
      <param name="leftGenericTypeParameters">Array of types to be substituded to the
            generic type parameters of the left member.</param>
      <param name="rightGenericMethodParameters">Array of types to be substituded to the
            generic method parameters of the right member.</param>
      <param name="rightGenericTypeParameters">Array of types to be substituded to the
            generic type parameters of the right member.</param>
      <returns>An instance of <see cref="T:PostSharp.Reflection.ReflectionTypeComparer" />.</returns>
    </member>
    <member name="M:PostSharp.Reflection.ReflectionTypeComparer.Equals(System.Type,System.Type)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Reflection.ReflectionTypeComparer.GetHashCode(System.Type)">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Reflection.ReflectionTypeComparer.Equals(System.Type[],System.Type[])">
      <inheritdoc />
    </member>
    <member name="M:PostSharp.Reflection.ReflectionTypeComparer.GetHashCode(System.Type[])">
      <inheritdoc />
    </member>
    <member name="T:PostSharp.Extensibility.RequirePostSharpAttribute">
      <summary>
            Custom attribute that, when applied on another custom attribute (a class derived 
            from <see cref="T:System.Attribute" />), means that assemblies with elements
            annotated with that custom attribute should be processed by <c>PostSharp</c>.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.RequirePostSharpAttribute.#ctor(System.String,System.String)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.RequirePostSharpAttribute" />.
            </summary>
      <param name="plugIn">Name of the required plug-in (file name without extension).</param>
      <param name="task">Name of the required task (should be defined in <paramref name="plugIn" />).</param>
    </member>
    <member name="P:PostSharp.Extensibility.RequirePostSharpAttribute.PlugIn">
      <summary>
            Gets the name of the required plug-in (file name without the extension).
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.RequirePostSharpAttribute.Task">
      <summary>
            Gets the name of the required task (should be defined in <see cref="P:PostSharp.Extensibility.RequirePostSharpAttribute.PlugIn" />).
            </summary>
    </member>
  </members>
</doc>