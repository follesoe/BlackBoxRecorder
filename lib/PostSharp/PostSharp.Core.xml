<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>PostSharp.Core</name>
  </assembly>
  <members>
    <member name="T:PostSharp.ApplicationInfo">
      <summary>
            Provides information about PostSharp.
            </summary>
    </member>
    <member name="M:PostSharp.ApplicationInfo.GetSettingBoolean(System.String,System.Boolean)">
      <summary>
            Gets a setting whose value is <see cref="T:System.Boolean" />.
            </summary>
      <param name="key">Setting name.</param>
      <param name="defaultValue">Default value.</param>
      <returns>The setting value, or <paramref name="defaultValue" /> if the setting is not defined.</returns>
    </member>
    <member name="M:PostSharp.ApplicationInfo.SetSetting(System.String,System.String)">
      <summary>
            Change an application setting.
            </summary>
      <param name="name">Setting name.</param>
      <param name="value">Setting value.</param>
    </member>
    <member name="P:PostSharp.ApplicationInfo.BaseDirectory">
      <summary>
            Gets the application base installation directory.
            </summary>
    </member>
    <member name="P:PostSharp.ApplicationInfo.Version">
      <summary>
            Gets the version of the <b>PostSharp.Core</b> assembly.
            </summary>
    </member>
    <member name="P:PostSharp.ApplicationInfo.LocalMachineRegistryKeyName">
      <summary>
            Gets the registry key under PostSharp configuration is registered,
            under the LOCAL_MACHINE registry hive.
            </summary>
    </member>
    <member name="P:PostSharp.ApplicationInfo.UserRegistryKeyName">
      <summary>
            Gets the registry key under PostSharp configuration is registered,
            under the USER registry hive.
            </summary>
    </member>
    <member name="E:PostSharp.ApplicationInfo.SettingChanged">
      <summary>
            Event raised when a setting is changed after it is initially read from the configuration file.
            </summary>
    </member>
    <member name="T:PostSharp.AssertionFailedException">
      <summary>
            This exception is thrown when an internal assertion failed.
            </summary>
    </member>
    <member name="M:PostSharp.AssertionFailedException.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.AssertionFailedException" /> with no message.
            </summary>
    </member>
    <member name="M:PostSharp.AssertionFailedException.#ctor(System.String)">
      <summary>
            Initializes a new <see cref="T:PostSharp.AssertionFailedException" /> exception with a message.
            </summary>
      <param name="message">Exception message.</param>
    </member>
    <member name="M:PostSharp.AssertionFailedException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new <see cref="T:PostSharp.AssertionFailedException" /> exception with
            a message and an inner exception.
            </summary>
      <param name="message">Exception message.</param>
      <param name="inner">Inner exception.</param>
    </member>
    <member name="M:PostSharp.AssertionFailedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Deserialization constructor.
            </summary>
      <param name="info">Serialization information.</param>
      <param name="context">Context.</param>
    </member>
    <member name="T:PostSharp.CodeModel.AssemblyEnvelope">
      <summary>
            Represents an assembly understood basically, internally, as a collection 
            of modules (<see cref="T:PostSharp.CodeModel.ModuleDeclaration" />) and, externally, as a collection
            of exported types.
            </summary>
      <remarks>
            Do not mistake for <see cref="T:PostSharp.CodeModel.AssemblyManifestDeclaration" />, which is the assembly manifest and is contained
            in one of the module of the assembly.
            </remarks>
    </member>
    <member name="T:PostSharp.CodeModel.Element">
      <summary>Represents an element of a tree structure.</summary>
      <remarks>
        <para>
            The CLI module is basically represented as a tree of objects what are called
            <see cref="T:PostSharp.CodeModel.Declaration" /> in PostSharp. The root of the module tree is the
            <see cref="T:PostSharp.CodeModel.ModuleDeclaration" />. Modules are contained in assemblies (<see cref="T:PostSharp.CodeModel.AssemblyEnvelope" />)
            and assemblies are bounded in the scope of a specified <see cref="P:PostSharp.CodeModel.Element.Domain" />.
            </para>
        <para>
            All elements that are a part of a <see cref="P:PostSharp.CodeModel.Element.Domain" /> are represented by the <see cref="T:PostSharp.CodeModel.Element" /> type. 
            This class is basically a tree node.
            <see cref="T:PostSharp.CodeModel.Element" /> instances have two properties: <see cref="P:PostSharp.CodeModel.Element.Parent" />
            gives the direct parent, and <see cref="P:PostSharp.CodeModel.Element.Domain" /> gives the root
            <see cref="P:PostSharp.CodeModel.Element.Domain" />.
            </para>
        <para>
            The child-parent relationship is managed automatically when the child is related to the parent either adding it 
            into a collection of children, either setting it as the value of a property of the parent.
            </para>
      </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.Element.OnPropertyChanged(System.String,System.Object,System.Object)">
      <summary>
            Method invoked when a property of the current instance has been changed.
            </summary>
      <param name="property">Name of the changed property.</param>
      <param name="oldValue">Old value of the property.</param>
      <param name="newValue">New value of the property.</param>
    </member>
    <member name="M:PostSharp.CodeModel.Element.NotifyChildPropertyChanged(PostSharp.CodeModel.Element,System.String,System.Object,System.Object)">
      <summary>
            Method invoked when a property of a child has been changed.
            </summary>
      <param name="child">Child object that has been changed.</param>
      <param name="property">Name of the changed property.</param>
      <param name="oldValue">Old value of the property.</param>
      <param name="newValue">New value of the property.</param>
      <returns>
        <b>true</b> if the notification was processed by the current method, otherwise <b>false</b>.</returns>
      <remarks>Implementations of this method should first call the base implementation; if the base implementation
            returns <b>true</b>, the notification has been processed, so the current implementation can return 
            immediately <b>true</b>.</remarks>
    </member>
    <member name="M:PostSharp.CodeModel.Element.ClearCache">
      <summary>
            Clear the cache (typically mapping to <b>System.Reflection</b> or,
            if the current element is a reference, to the related definition) 
            of the current <see cref="T:PostSharp.CodeModel.Element" /> and all its children.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.Element.Parent">
      <summary>
            Gets the parent <see cref="T:PostSharp.CodeModel.Element" />.
            </summary>
      <value>
            A <see cref="T:PostSharp.CodeModel.Element" />, or <b>null</b> if the current element
            is a <see cref="P:PostSharp.CodeModel.Element.Domain" /> or is a stand-alone (detached) declaration.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.Element.Role">
      <summary>
            Gets the role of the current <see cref="T:PostSharp.CodeModel.Element" /> in its parent.
            </summary>
      <remarks>
            This property allows the parent to determine to which collection a child belong,
            and take appropriate actions in case of notification (as <see cref="M:PostSharp.CodeModel.Element.NotifyChildPropertyChanged(PostSharp.CodeModel.Element,System.String,System.Object,System.Object)" />).
            </remarks>
    </member>
    <member name="P:PostSharp.CodeModel.Element.Domain">
      <summary>
            Gets the <see cref="P:PostSharp.CodeModel.Element.Domain" /> to which the current element belong, or <b>null</b>
            if the current element is a stand-alone (detached) declaration.
            </summary>
      <remarks>
            This property is implemented recursively on the <see cref="P:PostSharp.CodeModel.Element.Parent" /> property.
            Since the cost may be non-trivial for some declaration, consider caching its
            result where appropriate.
            </remarks>
    </member>
    <member name="T:PostSharp.CodeModel.IAssembly">
      <summary>
            Defines the semantics of an assembly 
            (<see cref="T:PostSharp.CodeModel.AssemblyRefDeclaration" /><see cref="T:PostSharp.CodeModel.AssemblyEnvelope" />).
            </summary>
    </member>
    <member name="T:PostSharp.ITaggable">
      <summary>
            Defines the semantics of a taggable object. User code can add custom pieces of
            information to PostSharp objects using this mechanism. DomainTags are identified 
            by a <see cref="T:System.Guid" />. There is no difference between an absent tag and
            a <b>null</b> tag value.
            </summary>
    </member>
    <member name="M:PostSharp.ITaggable.GetTag(System.Guid)">
      <summary>
            Gets a tag associated with the current declaration.
            </summary>
      <param name="guid">Tag identifier.</param>
      <returns>An object, or <b>null</b> if no tag of type <paramref name="guid" />
            is associated to the current declaration.</returns>
    </member>
    <member name="M:PostSharp.ITaggable.SetTag(System.Guid,System.Object)">
      <summary>
            Set a tag to the current declaration.
            </summary>
      <param name="guid">Tag identifier.</param>
      <param name="value">Tag value.</param>
    </member>
    <member name="M:PostSharp.CodeModel.IAssembly.GetSystemAssembly">
      <summary>
            Gets the reflection <see cref="T:System.Reflection.Assembly" /> corresponding 
            to the current instance.
            </summary>
      <returns>The <see cref="T:System.Reflection.Assembly" /> corresponding to this
            instance, or <b>null</b> if the assembly could not be found.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.IAssembly.GetAssemblyEnvelope">
      <summary>
            Gets the <see cref="T:PostSharp.CodeModel.AssemblyEnvelope" /> corresponding to the current instance
            in the current domain.
            </summary>
      <returns>An <see cref="T:PostSharp.CodeModel.AssemblyEnvelope" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.IAssembly.MatchesReference(PostSharp.CodeModel.IAssemblyName)">
      <summary>
            Determines whether the current <see cref="T:PostSharp.CodeModel.AssemblyEnvelope" /> matches a given assembly reference.
            </summary>
      <param name="assemblyName">The assembly reference.</param>
      <returns>
        <b>true</b> if the current <see cref="T:PostSharp.CodeModel.AssemblyEnvelope" /> matches <paramref name="assemblyName" />,
            otherwise <b>false</b>.</returns>
      <remarks>Matching an assembly reference is a looser requirement than matching an assembly name exactly;
            an assembly reference may set no requirement on the public key token or the version, for instance.</remarks>
    </member>
    <member name="T:PostSharp.Collections.INamed">
      <summary>
            Exposes a <see cref="P:PostSharp.Collections.INamed.Name" /> property.
            </summary>
    </member>
    <member name="P:PostSharp.Collections.INamed.Name">
      <summary>
            Gets the name of the current object.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyEnvelope.GetTypeDefinition(System.String)">
      <summary>
            Gets a type defined in this assembly given its name.
            </summary>
      <param name="typeName">Type name (in Reflection format).</param>
      <returns>The <see cref="T:PostSharp.CodeModel.TypeDefDeclaration" /> named <paramref name="typeName" />,
            or <b>null</b> if there is no type named <paramref name="typeName" /> in this assembly.s</returns>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyEnvelope.GetTypeDefinition(System.String,PostSharp.CodeModel.BindingOptions)">
      <summary>
            Gets a type defined in this assembly given its name.
            </summary>
      <param name="typeName">Type name (in Reflection format).</param>
      <param name="bindingOptions">Binding options.</param>
      <returns>The <see cref="T:PostSharp.CodeModel.TypeDefDeclaration" /> named <paramref name="typeName" />,
            or <b>null</b> if there is no type named <paramref name="typeName" /> in this assembly.s</returns>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyEnvelope.MatchesReference(PostSharp.CodeModel.IAssemblyName)">
      <summary>
            Determines whether the current <see cref="T:PostSharp.CodeModel.AssemblyEnvelope" /> matches a given assembly reference.
            </summary>
      <param name="assemblyName">The assembly reference.</param>
      <returns>
        <b>true</b> if the current <see cref="T:PostSharp.CodeModel.AssemblyEnvelope" /> matches <paramref name="assemblyName" />,
            otherwise <b>false</b>.</returns>
      <remarks>Matching an assembly reference is a looser requirement than matching an assembly name exactly;
            an assembly reference may set no requirement on the public key token or the version, for instance.</remarks>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyEnvelope.GetPublicKey">
      <summary>
            Gets the assemby public key.
            </summary>
      <value>
            An array of bytes containing the public key,
            or <b>null</b> if no public key is specified (for instance if
            only the public key token is given).
            </value>
      <returns>An array of bytes containing the public key,
            or <b>null</b> if no public key is specified.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyEnvelope.GetPublicKeyToken">
      <summary>
            Gets the assembly public key token.
            </summary>
      <returns>An array of bytes containing the public key token,
            or <b>null</b> if no public key is specified.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyEnvelope.GetSystemAssembly">
      <summary>
            Gets the reflection <see cref="T:System.Reflection.Assembly" /> corresponding 
            to the current instance.
            </summary>
      <returns>The <see cref="T:System.Reflection.Assembly" /> corresponding to this
            instance, or <b>null</b> if the assembly could not be found.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyEnvelope.Equals(PostSharp.CodeModel.IAssembly)" />
    <member name="M:PostSharp.CodeModel.AssemblyEnvelope.ToString" />
    <member name="M:PostSharp.CodeModel.AssemblyEnvelope.GetTag(System.Guid)">
      <summary>
            Gets a tag associated with the current declaration.
            </summary>
      <param name="guid">Tag identifier.</param>
      <returns>An object, or <b>null</b> if no tag of type <paramref name="guid" />
            is associated to the current declaration.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyEnvelope.SetTag(System.Guid,System.Object)">
      <summary>
            Set a tag to the current declaration.
            </summary>
      <param name="guid">Tag identifier.</param>
      <param name="value">Tag value.</param>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyEnvelope.Dispose" />
    <member name="P:PostSharp.CodeModel.AssemblyEnvelope.Location">
      <summary>
            Gets the full path of the file from which the assembly has been loaded.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.AssemblyEnvelope.Modules">
      <summary>
            Gets the collection of modules contained in this assembly.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.AssemblyEnvelope.ManifestModule">
      <summary>
            Gets the module containing the assembly manifest (<see cref="T:PostSharp.CodeModel.AssemblyManifestDeclaration" />).
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.AssemblyEnvelope.Name">
      <summary>
            Gets the assembly friendly name.
            </summary>
      <value>
            The assembly friendly name.
            </value>
      <summary>
            Gets the name of the current object.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.AssemblyEnvelope.FullName">
      <summary>
            Gets the assembly full name.
            </summary>
      <value>
            The assembly full name including version number, culture name
            and public key token.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.AssemblyEnvelope.Version">
      <summary>
            Gets the assembly version.
            </summary>
      <value>
            A <see cref="P:PostSharp.CodeModel.IAssemblyName.Version" />.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.AssemblyEnvelope.Culture">
      <summary>
            Gets the assembly culture name.
            </summary>
      <value>
            The standard assembly culture name, or <b>null</b> if the assembly
            is culture-neutral.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.AssemblyEnvelope.IsMscorlib">
      <summary>
            Determines whether the current assembly is <b>mscorlib</b>.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.Collections.AssemblyEnvelopeCollection">
      <summary>
            Collection of assemblies (<see cref="T:PostSharp.CodeModel.AssemblyEnvelope" />).
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.Collections.NonUniquelyNamedElementCollection`1">
      <internal />
      <summary>
            Collection of elements indexed by name, supporting many elements
            of the same name.
            </summary>
      <typeparam name="ItemType" />
    </member>
    <member name="T:PostSharp.CodeModel.Collections.NamedElementCollection`1">
      <summary>
            Base class for collections of elements having a name, with an index on the <see cref="P:PostSharp.Collections.INamed.Name" /> property.
            </summary>
      <typeparam name="ItemType">Type of collection items.</typeparam>
    </member>
    <member name="T:PostSharp.CodeModel.Collections.ElementCollection`1">
      <internal />
      <summary>
            Collection of elements (<see cref="T:PostSharp.CodeModel.Element" />).
            </summary>
      <typeparam name="ItemType">A type derived from <see cref="T:PostSharp.CodeModel.Element" />.</typeparam>
      <remarks>
        <para>
            This collection should be owned by an <see cref="T:PostSharp.CodeModel.Element" />. The objective
            of the current class is to notify the owner element that a child was added or removed.
            In order for the owner element to know to which collection the child belongs,
            each collection has a <i>role</i> in the owner collection.
            </para>
        <para>
            This class maintains the parent-child relationship.
            </para>
        <para>
            In order to save memory, the underlying collection is created only on demand.
            Empty collections should not have underlying collection.
            </para>
      </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.ElementCollection`1.EnsureCapacity(System.Int32)">
      <summary>
            Allocates additional capacity in the collection.
            </summary>
      <param name="capacity">Additional capacity.</param>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.ElementCollection`1.Add(`0)" />
    <member name="M:PostSharp.CodeModel.Collections.ElementCollection`1.AddRange(System.Collections.Generic.ICollection{`0})">
      <summary>
            Adds a collection of items to the current collection.
            </summary>
      <param name="items">The collection of items to be added.</param>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.ElementCollection`1.AddCloneRange(System.Collections.Generic.ICollection{`0})">
      <summary>
            Adds <i>clones</i> of items of a given collection to the current collection.
            </summary>
      <param name="items">The collection of items to be added.</param>
      <remarks>
            This method requires <typeparamref name="ItemType" /> to implement the
            <see cref="T:System.ICloneable" /> interface. Clones should be themselves
            of the <typeparamref name="ItemType" /> type.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.ElementCollection`1.Clear" />
    <member name="M:PostSharp.CodeModel.Collections.ElementCollection`1.Contains(`0)" />
    <member name="M:PostSharp.CodeModel.Collections.ElementCollection`1.CopyTo(`0[],System.Int32)" />
    <member name="M:PostSharp.CodeModel.Collections.ElementCollection`1.Remove(`0)" />
    <member name="M:PostSharp.CodeModel.Collections.ElementCollection`1.GetEnumerator" />
    <member name="M:PostSharp.CodeModel.Collections.ElementCollection`1.DoLazyLoading">
      <summary>
            Loads the content of the collection.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.ElementCollection`1.Dispose">
      <summary>
            Disposes the resources held by the current instance.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.ElementCollection`1.ToArray">
      <summary>
            Converts the current collection into a typed array.
            </summary>
      <returns>An array containing all elements of the current collection.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.ElementCollection`1.ClearCache">
      <summary>
            Clear the cache (typically mapping to <b>System.Reflection</b> or,
            if the current element is a reference, to the related definition) 
            of all items of this collection.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.Collections.ElementCollection`1.Count" />
    <member name="P:PostSharp.CodeModel.Collections.ElementCollection`1.IsReadOnly" />
    <member name="P:PostSharp.CodeModel.Collections.ElementCollection`1.Owner">
      <summary>
            Gets the owner <see cref="T:PostSharp.CodeModel.Element" />.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.Collections.ElementCollection`1.Role">
      <summary>
            Gets the role of the current collection in the owner element.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.Collections.ElementCollection`1.IsDisposed">
      <summary>
            Determines whether the current collection has been disposed.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.Collections.ElementCollection`1.IsLazyLoadingSupported">
      <summary>
            Determines if the current collection supports lazy loading.
            </summary>
      <remarks>
        <para>
            If a collection supports lazy loading, the method <see cref="M:PostSharp.CodeModel.Collections.ElementCollection`1.DoLazyLoading" />
            should be implemented; it will be called before any access to the collection.
            </para>
        <para>
            This property is evaluated <i>before</i> the collection constructor is invoked.
            Therefore, it is considered as static for the collection class.
            </para>
      </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.NonUniquelyNamedElementCollection`1.GetByName(System.String)">
      <summary>
            Gets the collection of elements given a name.
            </summary>
      <param name="name">Name of the element.</param>
      <returns>A collection of element named <paramref name="name" />.
            If no element is found, an empty collection is returned.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.NonUniquelyNamedElementCollection`1.GetOneByName(System.String)">
      <summary>
            Gets arbitrarly one declaration among the ones having a given name.
            </summary>
      <param name="name">Name of the declaration.</param>
      <returns>A declaration named <paramref name="name" /> (arbitrarly any of all named
            <paramref name="name" /> if there are many), or <b>null</b> if no declaration
            is named <paramref name="name" />.</returns>
    </member>
    <member name="T:PostSharp.CodeModel.AssemblyLoadHelper">
      <summary>
            Helper class to load assemblies. Provides a "binding log" for our custom
            binder and appends this log in exception text.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyLoadHelper.ClearLog">
      <summary>
            Clears the log.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyLoadHelper.GetLog">
      <summary>
            Gets the current log content.
            </summary>
      <returns>The current log content.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyLoadHelper.LoadAssemblyFromName(System.String)">
      <summary>
            Loads an assembly given its name.
            </summary>
      <param name="assemblyName">The full assembly name.</param>
      <returns>The assembly whose name is <paramref name="assemblyName" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyLoadHelper.LoadAssemblyFromName(System.String,System.Security.Policy.Evidence)">
      <summary>
            Loads an assembly given its name, and passes an <see cref="T:System.Security.Policy.Evidence" />.
            </summary>
      <param name="assemblyName">The full assembly name.</param>
      <param name="assemblySecurity">Evidence with which the assembly should be loaded.</param>
      <returns>The assembly whose name is <paramref name="assemblyName" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyLoadHelper.LoadAssemblyFromFile(System.String)">
      <summary>
            Loads an assembly given its location full path.
            </summary>
      <param name="fileName">Full path of the assembly file.</param>
      <returns>The <see cref="T:System.Reflection.Assembly" /> located at <paramref name="fileName" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyLoadHelper.LoadAssemblyFromFile(System.String,System.Security.Policy.Evidence)">
      <summary>
            Loads an assembly given its location full path and passes an <see cref="T:System.Security.Policy.Evidence" />.
            </summary>
      <param name="fileName">Full path of the assembly file.</param>
      <param name="assemblySecurity">Evidence with which the assembly should be loaded.</param>
      <returns>The <see cref="T:System.Reflection.Assembly" /> located at <paramref name="fileName" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyLoadHelper.SplitTypeName(System.String,System.String@,System.String@)">
      <summary>
            Splits a assembly-qualified type name into a type name and an assembly name.
            </summary>
      <param name="qualifiedTypeName">Assembly-qualified type name.</param>
      <param name="typeName">Type name.</param>
      <param name="assemblyName">Assembly name.</param>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyLoadHelper.LoadType(System.String)">
      <summary>
            Loads a type given its fully qualified name.
            </summary>
      <param name="typeName">Fully qualified type name.</param>
      <returns>The type named <paramref name="typeName" />.</returns>
    </member>
    <member name="T:PostSharp.CodeModel.AssemblyLocator">
      <summary>
            Locates an assembly in the search path or in GAC.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyLocator.AddDirectory(System.String)">
      <summary>
            Add a directory to the search path.
            </summary>
      <param name="directory">A directory.</param>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyLocator.RemoveDirectory(System.String)">
      <summary>
            Removes a directory from the search path.
            </summary>
      <param name="directory">Directory to be removed.</param>
      <returns>
        <b>true</b> if the directory was previously present and removed, <b>false</b>
            if the directory was previously not in the search path.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyLocator.AddDirectories(System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Adds a set of directories to the search path.
            </summary>
      <param name="directories">A set of directories.</param>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyLocator.AddFile(System.String)">
      <summary>
            Add a file to the search path.
            </summary>
      <param name="fullPath">Full file path.</param>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyLocator.FindAssembly(PostSharp.CodeModel.IAssemblyName)">
      <summary>
            Finds an assembly.
            </summary>
      <param name="assemblyName">Assmebly name.</param>
      <returns>The full path of the assembly, or <b>null</b> if the assembly was not found.</returns>
    </member>
    <member name="P:PostSharp.CodeModel.AssemblyLocator.Domain">
      <summary>
            Gets the <see cref="P:PostSharp.CodeModel.AssemblyLocator.Domain" /> used by the <see cref="T:PostSharp.CodeModel.AssemblyLocator" /> to
            resolve assembly name redirection.
            </summary>
    </member>
    <member name="E:PostSharp.CodeModel.AssemblyLocator.LocatingAssembly">
      <summary>
            Event raised when an assembly reference is resolved.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.AssemblyLocateEventArgs">
      <summary>
            Arguments of the <see cref="E:PostSharp.CodeModel.AssemblyLocator.LocatingAssembly" /> event.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.AssemblyLocateEventArgs.AssemblyName">
      <summary>
            Gets the name of the assembly being resolved.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.AssemblyLocateEventArgs.AssemblyLocation">
      <summary>
            Gets or sets the assembly location on the filesystem.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.AssemblyRedirectionPolicyManager">
      <summary>
            Manages and resolves assembly redirection policies.
            </summary>
      <remarks>
        <para>Assembly redirection is the process of replacing an assembly reference
            by another reference, allowing to load another assembly than the one
            that is actually referenced.</para>
        <para>The resolved and redirected assembly name is here named the <i>canonical</i>
            assembly name.</para>
      </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyRedirectionPolicyManager.GetCanonicalAssemblyName(System.String)">
      <summary>
            Applies redirection policies on an assembly name given as a <see cref="T:System.String" />.
            </summary>
      <param name="assemblyName">Name of the referenced assembly.</param>
      <returns>Name of the resolved assembly reference, after application
            of redirection policies.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyRedirectionPolicyManager.GetCanonicalAssemblyName(System.Reflection.AssemblyName)">
      <summary>
            Applies redirection policies on an assembly name given as an <see cref="T:System.Reflection.AssemblyName" />.
            </summary>
      <param name="assemblyName">Name of the referenced assembly.</param>
      <returns>Name of the resolved assembly reference, after application
            of redirection policies.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyRedirectionPolicyManager.HasRedirectionPolicy(System.Reflection.AssemblyName)">
      <summary>
            Determines whether a redirection polity is defined for a given assembly name (<see cref="T:System.Reflection.AssemblyName" />).
            </summary>
      <param name="assemblyName">An assembly name.</param>
      <returns>
        <b>true</b> if some redirection policy is defined for <paramref name="assemblyName" />,
            otherwise <b>false</b>.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyRedirectionPolicyManager.HasRedirectionPolicy(PostSharp.CodeModel.IAssemblyName)">
      <summary>
            Determines whether a redirection polity is defined for a given assembly name (<see cref="T:PostSharp.CodeModel.IAssemblyName" />).
            </summary>
      <param name="assemblyName">An assembly name.</param>
      <returns>
        <b>true</b> if some redirection policy is defined for <paramref name="assemblyName" />,
            otherwise <b>false</b>.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyRedirectionPolicyManager.GetCanonicalAssemblyName(PostSharp.CodeModel.IAssemblyName)">
      <summary>
            Applies redirection policies on an assembly name given as a <see cref="T:PostSharp.CodeModel.IAssemblyName" />.
            </summary>
      <param name="assemblyName">Name of the referenced assembly.</param>
      <returns>Name of the resolved assembly reference, after application
            of redirection policies.</returns>
    </member>
    <member name="T:PostSharp.CodeModel.AssemblyRedirectionPolicy">
      <summary>
            Specifies a mapping between an assembly reference
            and the assembly to which the reference is actually resolve.
            Assembly redirection policies allow to substitute other
            assemblies to the ones that are actually requested, and therefore
            support newer versions of these assemblies, or even different
            variants of the .NET Framework.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyRedirectionPolicy.#ctor(System.String,System.Byte[],System.String,System.Version,System.Version,System.String,System.Byte[],System.Version)">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.AssemblyRedirectionPolicy" />.
            </summary>
      <param name="oldShortName">Short name of the assembly reference, or '*' to match any assembly name.</param>
      <param name="oldPublicKeyToken">Public key token of the assembly reference, or <b>null</b> to match
            any public key token.</param>
      <param name="culture">Culture of the assembly reference, or <b>null</b> to match any culture.</param>
      <param name="oldVersionLowerBound">Lower bound of the version of the assembly reference, <b>null</b> not to 
            specify any version lower bound.</param>
      <param name="oldVersionUpperBound">Upper bound of the version of the assembly reference, <b>null</b> not to 
            specify any version upper bound.</param>
      <param name="newName">New short name of the resolved assembly reference, or <b>null</b> to copy the reference name.</param>
      <param name="newPublicKeyToken">New public key token of the resolved assembly reference, or <b>null</b> to copy the
            public key token of the unresolved reference.</param>
      <param name="newVersion">New version of the resolved assembly reference, or <b>null</b> to copy the version
            of the unresolved reference.</param>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyRedirectionPolicy.Matches(PostSharp.CodeModel.IAssemblyName)">
      <summary>
            Determines whether the current policy applies to a given assembly name.
            </summary>
      <param name="assemblyName">An assembly name (typically an assembly reference).</param>
      <returns>
        <b>true</b> if the current policy applies to <paramref name="assemblyName" />,
            otherwise <b>false</b>.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyRedirectionPolicy.Apply(PostSharp.CodeModel.IAssemblyName)">
      <summary>
            Applies the current policy to an assembly reference and returns the
            transformed assembly reference.
            </summary>
      <param name="oldAssemblyName">Assembly name to be transformed.</param>
      <returns>The transformed, resolved assembly name, obtained by applying the current policy.</returns>
      <remarks>
            This method assumes that the current policy actually matches <paramref name="oldAssemblyName" />, which
            can be determined using the <see cref="M:PostSharp.CodeModel.AssemblyRedirectionPolicy.Matches(PostSharp.CodeModel.IAssemblyName)" /> method.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyRedirectionPolicy.ToString" />
    <member name="P:PostSharp.CodeModel.AssemblyRedirectionPolicy.OldName">
      <summary>
            Gets or sets the short name of the assembly reference.
            </summary>
      <value>
            The short name of the assembly reference, or '*' to match any assembly name.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.AssemblyRedirectionPolicy.OldPublicKeyToken">
      <summary>
            Gets or sets the public key token of the assembly reference.
            </summary>
      <value>
            The public key token of the assembly reference, or <b>null</b> to match
            any public key token.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.AssemblyRedirectionPolicy.Culture">
      <summary>
            Gets or sets the culture of the assembly reference.
            </summary>
      <value>
            Culture of the assembly reference, or <b>null</b> to match any culture.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.AssemblyRedirectionPolicy.OldVersionLowerBound">
      <summary>
            Gets or sets the lower bound of the version of the assembly reference.
            </summary>
      <value>
            Lower bound of the version of the assembly reference, <b>null</b> not to 
            specify any version lower bound.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.AssemblyRedirectionPolicy.OldVersionUpperBound">
      <summary>
            Gets or sets the upper bound of the version of the assembly reference.
            </summary>
      <value>
            Upper bound of the version of the assembly reference, <b>null</b> not to 
            specify any version upper bound.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.AssemblyRedirectionPolicy.NewPublicKeyToken">
      <summary>
            Gets or sets the new public key token of the resolved assembly reference.
            </summary>
      <value>
            The new public key token of the resolved assembly reference, or <b>null</b> to copy the
            public key token of the unresolved reference.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.AssemblyRedirectionPolicy.NewVersion">
      <summary>
            Gets or sets the new version of the resolved assembly reference.
            </summary>
      <value>
            New version of the resolved assembly reference, or <b>null</b> to copy the version
            of the unresolved reference.
            </value>
    </member>
    <member name="T:PostSharp.CodeModel.BindingException">
      <summary>
            Exception thrown when a binding exception occurs in PostSharp.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.BindingException.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.BindingException" />.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.BindingException.#ctor(System.String)">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.BindingException" /> and defines the message.
            </summary>
      <param name="message">Error message.</param>
    </member>
    <member name="M:PostSharp.CodeModel.BindingException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.BindingException" /> and defines the message and the inner exception.
            </summary>
      <param name="message">Error message.</param>
      <param name="inner">Inner exception.</param>
    </member>
    <member name="M:PostSharp.CodeModel.BindingException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Deserialization constructor.
            </summary>
      <param name="info">Serialization information.</param>
      <param name="context">Streaming context.</param>
    </member>
    <member name="T:PostSharp.CodeModel.Binding.AssemblyComparer">
      <summary>
            Compares two assemblies (<see cref="T:PostSharp.CodeModel.IAssembly" />).
            </summary>
      <remarks>
            The implementation of this class is preliminary. In the future, it should
            support cross-module comparison.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.Binding.AssemblyComparer.GetInstance">
      <summary>
            Gets a singleton instance of the <see cref="T:PostSharp.CodeModel.Binding.AssemblyComparer" /> class.
            </summary>
      <returns />
    </member>
    <member name="M:PostSharp.CodeModel.Binding.AssemblyComparer.Equals(PostSharp.CodeModel.IAssemblyName,PostSharp.CodeModel.IAssemblyName)" />
    <member name="M:PostSharp.CodeModel.Binding.AssemblyComparer.GetHashCode(PostSharp.CodeModel.IAssemblyName)" />
    <member name="T:PostSharp.CodeModel.BindingOptions">
      <summary>
            Determines how the binding methods behave when the requested object
            is not found.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.BindingOptions.Default">
      <summary>
            Default. The library shall create the object and assign it
            a <see cref="T:PostSharp.CodeModel.MetadataToken" /> if the requested object is not found.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.BindingOptions.OnlyExisting">
      <summary>
            Indicates that the methods shall return <b>null</b> if the requested
            object is not found.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.BindingOptions.WeakReference">
      <summary>
            Indicates that the methods shall create the object but shall not
            assign it a <see cref="T:PostSharp.CodeModel.MetadataToken" />. This option is typically used
            when the object should not be linked statically using the module
            metadata, but the full name of the object is included (for instance
            with permission sets and custom attributes).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.BindingOptions.ExistenceMask">
      <summary>
            Masks <see cref="F:PostSharp.CodeModel.BindingOptions.OnlyExisting" /> and <see cref="F:PostSharp.CodeModel.BindingOptions.WeakReference" />.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.BindingOptions.RequireGenericInstance">
      <summary>
            Indicates generic type or method <b>instances</b> are required (all generic parameters should be bound).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.BindingOptions.RequireGenericDefinition">
      <summary>
            Indicates that generic or method <b>definitions</b> are required (generic parameters should not
            be bound).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.BindingOptions.RequireGenericMask">
      <summary>
            Mask isolating the way how generic types or methods should be bound.
            <see cref="F:PostSharp.CodeModel.BindingOptions.RequireGenericInstance" />, <see cref="F:PostSharp.CodeModel.BindingOptions.RequireGenericDefinition" /> or
            <see cref="F:PostSharp.CodeModel.BindingOptions.Default" />.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.BindingOptions.DisallowIntrinsicSubstitution">
      <summary>
            Indicates that normal types (<see cref="T:System.Object" />, <see cref="T:System.Int32" />, ...)
            should be used instead of intrinsics (<c>object</c>, <c>int32</c>, ...).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.BindingOptions.DontThrowException">
      <summary>
            Returns a <b>null</b> pointer instead of throwing an exception if
            the declaration is not found.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.BindingOptions.OnlyDefinition">
      <summary>
            Indicates that only definitions (not references or constructions) are allowed.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.BindingOptions.RequireIType">
      <summary>
            Indicates that a only objects derived from <see cref="T:PostSharp.CodeModel.IType" /> should be returned;
            if the type appears to be a <see cref="T:PostSharp.CodeModel.TypeSignature" />, it will be wrapped into a
            <see cref="T:PostSharp.CodeModel.TypeSpecDeclaration" />.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.Binding.MethodComparer">
      <summary>
            Compares two methods (<see cref="T:PostSharp.CodeModel.IMethod" />).
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.Binding.MethodComparer.GetInstance">
      <summary>
            Gets a singleton instance of <see cref="T:PostSharp.CodeModel.Binding.MethodComparer" />.
            </summary>
      <returns />
    </member>
    <member name="M:PostSharp.CodeModel.Binding.MethodComparer.GetHashCode(PostSharp.CodeModel.IMethod)" />
    <member name="T:PostSharp.CodeModel.Binding.MethodSignatureComparer">
      <summary>
            Compares two method signatures (<see cref="T:PostSharp.CodeModel.IMethodSignature" />).
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.Binding.MethodSignatureComparer.GetInstance">
      <summary>
            Gets a singleton instance of <see cref="T:PostSharp.CodeModel.Binding.MethodSignatureComparer" />.
            </summary>
      <returns />
    </member>
    <member name="T:PostSharp.CodeModel.Binding.TypeComparer">
      <summary>
            Compares types (<see cref="T:PostSharp.CodeModel.IType" />) using equivalence rules.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.Binding.TypeComparer.GetInstance">
      <summary>
            Gets a singleton instance of <see cref="T:PostSharp.CodeModel.Binding.TypeComparer" />.
            </summary>
      <returns />
    </member>
    <member name="M:PostSharp.CodeModel.Binding.TypeComparer.Equals(System.Object,System.Object)" />
    <member name="M:PostSharp.CodeModel.Binding.TypeComparer.GetHashCode(System.Object)" />
    <member name="M:PostSharp.CodeModel.Binding.TypeComparer.Equals(PostSharp.CodeModel.ITypeSignature,PostSharp.CodeModel.ITypeSignature)" />
    <member name="M:PostSharp.CodeModel.Binding.TypeComparer.GetHashCode(PostSharp.CodeModel.ITypeSignature)" />
    <member name="M:PostSharp.CodeModel.Binding.TypeComparer.Equals(PostSharp.CodeModel.TypeSignature,PostSharp.CodeModel.TypeSignature)" />
    <member name="M:PostSharp.CodeModel.Binding.TypeComparer.GetHashCode(PostSharp.CodeModel.TypeSignature)" />
    <member name="T:PostSharp.CodeModel.Collections.SimpleElementCollection`1">
      <internal />
      <summary>
            Simple collection of elements without any indexing or ordering.
            </summary>
      <typeparam name="ItemType" />
    </member>
    <member name="P:PostSharp.CodeModel.Collections.SimpleElementCollection`1.Item(System.Int32)">
      <summary>
            Gets the item at a given index.
            </summary>
      <param name="index">Index</param>
      <returns>The item at position <paramref name="index" />.</returns>
    </member>
    <member name="T:PostSharp.CodeModel.Collections.UniquelyNamedElementCollection`1">
      <internal />
      <summary>
            Collection of declarations indexed by name, supporting only single declaration
            per name.
            </summary>
      <typeparam name="ItemType" />
    </member>
    <member name="M:PostSharp.CodeModel.Collections.UniquelyNamedElementCollection`1.GetByName(System.String)">
      <summary>
            Gets the element given its name.
            </summary>
      <param name="name">Name of the element.</param>
      <returns>The elementy named <paramref name="name" />, or
            <b>null</b> if no element matches the current name.</returns>
    </member>
    <member name="T:PostSharp.Collections.Index`2">
      <summary>
            Dictionary of objects indexed by a property of these objects. Objects
            are automatically reindexed when the key property changes.
            </summary>
      <typeparam name="TKey">Type of keys.</typeparam>
      <typeparam name="TValue">Type of values.</typeparam>
      <remarks>
            If a collection of items should have many indexes (many indexed properties),
            it is preferable to use the <see cref="T:PostSharp.Collections.IndexedCollection`1" /> class.
            </remarks>
    </member>
    <member name="T:PostSharp.Collections.IIndex`2">
      <summary>
            Specifies the interface of an index.
            </summary>
      <typeparam name="K">Type of keys.</typeparam>
      <typeparam name="V">Type of values.</typeparam>
      <remarks>
            This interface has the advantage to specify the index without having to put
            constraint on generic type parameters. This eliminates many casting problems,
            for instance when defining the <see cref="T:PostSharp.Collections.IndexedCollection`1" /> class.
            </remarks>
    </member>
    <member name="M:PostSharp.Collections.IIndex`2.GetFirstValueByKey(`0)">
      <summary>
            Gets the first value associated to a given key.
            </summary>
      <param name="key">The key.</param>
      <returns>The value associated to <paramref name="key" />,
            or the default value of <typeparamref name="V" /> if no value
            is associated to <paramref name="key" />.</returns>
    </member>
    <member name="M:PostSharp.Collections.IIndex`2.TryGetFirstValueByKey(`0,`1@)">
      <summary>
            Tries to gets the first value associated to a given key.
            </summary>
      <param name="key">The key.</param>
      <param name="value">The value associated to <paramref name="key" />,
            or the default value of <typeparamref name="V" /> if no value
            is associated to <paramref name="key" />.</param>
      <returns>
        <b>true</b> if some value was found, otherwise <b>false</b>.</returns>
    </member>
    <member name="M:PostSharp.Collections.IIndex`2.GetValuesByKey(`0)">
      <summary>
            Gets the collection of values associated to a given key.
            </summary>
      <param name="key">The key.</param>
      <returns>The collection of values associated to <paramref name="key" />.</returns>
    </member>
    <member name="M:PostSharp.Collections.IIndex`2.Remove(`1,`0)">
      <summary>
            Removes an item from the index after its key has changed, by providing its old key.
            </summary>
      <param name="item">The item to be removed.</param>
      <param name="oldKey">The old key, under which the item was previously registered.</param>
      <returns />
    </member>
    <member name="M:PostSharp.Collections.Index`2.#ctor(PostSharp.Collections.ICollectionFactory{System.Collections.Generic.KeyValuePair{`0,`1}})">
      <summary>
            Initializes a new <see cref="T:PostSharp.Collections.Index`2" />.
            </summary>
      <param name="collectionFactory">Factory of the underlying implentation of this index.</param>
    </member>
    <member name="M:PostSharp.Collections.Index`2.NotifyKeyChanged(`0,`0,`1)">
      <summary>
            Notifies the current <see cref="T:PostSharp.Collections.Index`2" /> that the key of an item contained
            in the index has changed.
            </summary>
      <param name="oldKey">Old key.</param>
      <param name="newKey">New key.</param>
      <param name="value">Item whose key has changed.</param>
    </member>
    <member name="M:PostSharp.Collections.Index`2.GetItemKey(`1)">
      <summary>
            Gets the key of an item.
            </summary>
      <param name="value">Item.</param>
      <returns>The key of <paramref name="value" />.</returns>
    </member>
    <member name="M:PostSharp.Collections.Index`2.Add(`1)" />
    <member name="M:PostSharp.Collections.Index`2.Clear" />
    <member name="M:PostSharp.Collections.Index`2.Contains(`1)" />
    <member name="M:PostSharp.Collections.Index`2.CopyTo(`1[],System.Int32)" />
    <member name="M:PostSharp.Collections.Index`2.Remove(`1)" />
    <member name="M:PostSharp.Collections.Index`2.GetEnumerator" />
    <member name="M:PostSharp.Collections.Index`2.GetValuesByKey(`0)">
      <summary>
            Gets the collection of values associated to a given key.
            </summary>
      <param name="key">The key.</param>
      <returns>The collection of values associated to <paramref name="key" />.</returns>
    </member>
    <member name="M:PostSharp.Collections.Index`2.Remove(`1,`0)" />
    <member name="M:PostSharp.Collections.Index`2.GetFirstValueByKey(`0)">
      <summary>
            Gets the first value associated to a given key.
            </summary>
      <param name="key">The key.</param>
      <returns>The value associated to <paramref name="key" />,
            or the default value of <typeparamref name="V" /> if no value
            is associated to <paramref name="key" />.</returns>
    </member>
    <member name="M:PostSharp.Collections.Index`2.TryGetFirstValueByKey(`0,`1@)">
      <summary>
            Tries to gets the first value associated to a given key.
            </summary>
      <param name="key">The key.</param>
      <param name="value">The value associated to <paramref name="key" />,
            or the default value of <typeparamref name="V" /> if no value
            is associated to <paramref name="key" />.</param>
      <returns>
        <b>true</b> if some value was found, otherwise <b>false</b>.</returns>
    </member>
    <member name="M:PostSharp.Collections.Index`2.Dispose(System.Boolean)">
      <summary>
            Disposes the current instance.
            </summary>
      <param name="disposing">
        <b>true</b> if the method is called because of
            an explicit call of <see cref="M:PostSharp.Collections.Index`2.Dispose" />, <b>false</b> if it is
            called inside the destructor.</param>
    </member>
    <member name="M:PostSharp.Collections.Index`2.AssertNotDisposed">
      <summary>
            Throws an exception if the current instance has been disposed.
            </summary>
    </member>
    <member name="M:PostSharp.Collections.Index`2.Dispose" />
    <member name="M:PostSharp.Collections.Index`2.Finalize">
      <summary>
            Destructor.
            </summary>
    </member>
    <member name="P:PostSharp.Collections.Index`2.Capacity">
      <summary>
            Gets or sets the index capacity.
            </summary>
    </member>
    <member name="P:PostSharp.Collections.Index`2.Count" />
    <member name="P:PostSharp.Collections.Index`2.IsReadOnly" />
    <member name="P:PostSharp.Collections.Index`2.IsDisposed">
      <summary>
            Determines whether the current instance has been disposed.
            </summary>
    </member>
    <member name="T:PostSharp.Collections.IndexFactory`2">
      <summary>
            Factory for <see cref="T:PostSharp.Collections.Index`2" />.
            </summary>
      <typeparam name="TKey">Type of keys.</typeparam>
      <typeparam name="TValue">Type of values.</typeparam>
    </member>
    <member name="T:PostSharp.Collections.ICollectionFactory`1">
      <summary>
            A collection factory creates instances of collections
            and allocates capacity.
            </summary>
      <typeparam name="T">Type of items in the collection.</typeparam>
    </member>
    <member name="M:PostSharp.Collections.ICollectionFactory`1.CreateCollection">
      <summary>
            Creates a collection with default capacity.
            </summary>
      <returns>A collection.</returns>
    </member>
    <member name="M:PostSharp.Collections.ICollectionFactory`1.CreateCollection(System.Int32)">
      <summary>
            Creates a collection with given capacity.
            </summary>
      <param name="capacity">Initial collection capacity.</param>
      <returns>A collection.</returns>
    </member>
    <member name="M:PostSharp.Collections.ICollectionFactory`1.EnsureCapacity(System.Collections.Generic.ICollection{`0},System.Int32)">
      <summary>
            Ensures that a collection has the given capacity.
            </summary>
      <param name="collection">A collection.</param>
      <param name="capacity">The required capacity.</param>
    </member>
    <member name="M:PostSharp.Collections.IndexFactory`2.CreateCollection" />
    <member name="M:PostSharp.Collections.IndexFactory`2.CreateCollection(System.Int32)" />
    <member name="M:PostSharp.Collections.IndexFactory`2.EnsureCapacity(System.Collections.Generic.ICollection{`1},System.Int32)" />
    <member name="T:PostSharp.CodeModel.Collections.OrderedEmitDeclarationCollection`1">
      <internal />
      <summary>
            Collection of elements order by emit order (i.e. by metadata token).
            </summary>
      <typeparam name="ItemType" />
    </member>
    <member name="M:PostSharp.CodeModel.Collections.OrderedEmitDeclarationCollection`1.GetByEmitOrder">
      <summary>
            Gets all declarations ordered by emit order (i.e. metadata token).
            </summary>
      <returns>All declarations ordered by emit order (i.e. metadata token).</returns>
    </member>
    <member name="P:PostSharp.CodeModel.Collections.OrderedEmitDeclarationCollection`1.RequiresEmitOrdering">
      <summary>
            Determines whether the current collection requires to be sorted by emission order, so
            the collection can be written in the original order.
            </summary>
      <remarks>
            Order of declaration emission is not important for most collections (expect <see cref="T:PostSharp.CodeModel.Collections.FieldDefDeclarationCollection" />
            and <see cref="T:PostSharp.CodeModel.MethodDefDeclaration" />) in P-Invoke scenarios). However, in debug builds, most collections
            respect the original emission order so that it is easier to compare the enhanced assembly with the
            original assembly. Debug and release builds typically returns a different value. For a given class,
            this property returns always the same value.
            </remarks>
    </member>
    <member name="T:PostSharp.Collections.IndexedCollection`1">
      <summary>
            Collection of objects indexed by many properties of these objects. Objects
            are automatically reindexed when the key property changes.
            </summary>
      <typeparam name="T">Type of indexed values.</typeparam>
    </member>
    <member name="M:PostSharp.Collections.IndexedCollection`1.#ctor(PostSharp.Collections.ICollectionFactory{`0}[],System.Int32)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Collections.IndexedCollection`1" /> with an initial capacity.
            </summary>
      <param name="indexFactories">Array of factories for individual indexes.</param>
      <param name="capacity">Initial capacity.</param>
    </member>
    <member name="M:PostSharp.Collections.IndexedCollection`1.Add(`0)" />
    <member name="M:PostSharp.Collections.IndexedCollection`1.Clear" />
    <member name="M:PostSharp.Collections.IndexedCollection`1.Contains(`0)" />
    <member name="M:PostSharp.Collections.IndexedCollection`1.CopyTo(`0[],System.Int32)" />
    <member name="M:PostSharp.Collections.IndexedCollection`1.Remove(`0)" />
    <member name="M:PostSharp.Collections.IndexedCollection`1.GetEnumerator" />
    <member name="M:PostSharp.Collections.IndexedCollection`1.GetOrderedValues(System.Int32)">
      <summary>
            Gets all values in the collection ordered by an index known by its ordinal.
            </summary>
      <param name="indexOrdinal">Index ordinal.</param>
      <returns>An ordered collection of items of type <typeparamref name="T" />.</returns>
      <remarks>
            This makes sense only if the implementation of the index of this property
            is an ordered dictionary.
            </remarks>
    </member>
    <member name="M:PostSharp.Collections.IndexedCollection`1.GetValuesByKey``1(System.Int32,``0)">
      <summary>
            Gets the collection of items whose a given property equals a given value. The
            property is known by the ordinal of its associated index.
            </summary>
      <typeparam name="K">Type of the indexed property.</typeparam>
      <param name="indexOrdinal">Ordinal of the index associated to this property.</param>
      <param name="key">Value of the indexed property for which items have to be returned.</param>
      <returns>The collection of items whose property at position <paramref name="indexOrdinal" />
            equals <paramref name="key" />.</returns>
    </member>
    <member name="M:PostSharp.Collections.IndexedCollection`1.TryGetFirstValueByKey``1(System.Int32,``0,`0@)">
      <summary>
            Tries to get the first item whose a given property equals a given value.
            The property is known by the ordinal of its associated index.
            </summary>
      <typeparam name="K">Type of the indexed property.</typeparam>
      <param name="indexOrdinal">Ordinal of the indexed property.</param>
      <param name="key">Value of the indexed property for which the first item to be returned.</param>
      <param name="value">Value of the first item whose property value is <paramref name="key" />.</param>
      <returns>
        <b>true</b> if at least one item corresponded to this criterion, otherwise <b>false</b>.</returns>
    </member>
    <member name="M:PostSharp.Collections.IndexedCollection`1.OnItemPropertyChanged``1(System.Int32,`0,``0)">
      <summary>
            Method invoked when an indexed property of an item of the current collection has changed.
            </summary>
      <typeparam name="K">Type of the indexed property.</typeparam>
      <param name="indexOrdinal">Ordinal of the index corresponding to the property.</param>
      <param name="item">Item.</param>
      <param name="oldKey">Value of the indexed property before the change.</param>
    </member>
    <member name="M:PostSharp.Collections.IndexedCollection`1.Dispose(System.Boolean)">
      <summary>
            Disposes the current instance.
            </summary>
      <param name="disposing">
        <b>true</b> if the method is called because of
            an explicit call of <see cref="M:PostSharp.Collections.IndexedCollection`1.Dispose" />, <b>false</b> if it is
            called inside the destructor.</param>
    </member>
    <member name="M:PostSharp.Collections.IndexedCollection`1.Dispose" />
    <member name="M:PostSharp.Collections.IndexedCollection`1.Finalize">
      <summary>
            Destructor.
            </summary>
    </member>
    <member name="P:PostSharp.Collections.IndexedCollection`1.Capacity">
      <summary>
            Gets or sets the index capacity.
            </summary>
    </member>
    <member name="P:PostSharp.Collections.IndexedCollection`1.Count" />
    <member name="P:PostSharp.Collections.IndexedCollection`1.IsReadOnly" />
    <member name="P:PostSharp.Collections.IndexedCollection`1.IsDisposed">
      <summary>
            Determines whether the collection has been disposed.
            </summary>
    </member>
    <member name="T:PostSharp.Collections.IndexedCollectionFactory`1">
      <summary>
            Factory for <see cref="T:PostSharp.Collections.IndexedCollection`1" />.
            </summary>
      <typeparam name="T">Type of items.</typeparam>
    </member>
    <member name="M:PostSharp.Collections.IndexedCollectionFactory`1.CreateCollection" />
    <member name="M:PostSharp.Collections.IndexedCollectionFactory`1.CreateCollection(System.Int32)">
      <summary>
            Creates an <see cref="T:PostSharp.Collections.IndexedCollection`1" />.
            </summary>
      <param name="capacity">Initial capacity of the collection.</param>
      <returns>A new <see cref="T:PostSharp.Collections.IndexedCollection`1" /> with the given initial capacity.</returns>
    </member>
    <member name="M:PostSharp.Collections.IndexedCollectionFactory`1.EnsureCapacity(System.Collections.Generic.ICollection{`0},System.Int32)">
      <summary>
            Ensures that a collection has the given capacity.
            </summary>
      <param name="collection">A collection.</param>
      <param name="capacity">The required capacity.</param>
    </member>
    <member name="T:PostSharp.CodeModel.Collections.OrderedEmitAndByNonUniqueNameDeclarationCollection`1">
      <internal />
      <summary>
            Collections of declarations with an index per emit order and a non-unique index
            on name.
            </summary>
      <typeparam name="ItemType" />
    </member>
    <member name="M:PostSharp.CodeModel.Collections.OrderedEmitAndByNonUniqueNameDeclarationCollection`1.GetByName(System.String)">
      <summary>
            Gets the collection of declarations given a name.
            </summary>
      <param name="name">Name of the declaration.</param>
      <returns>A collection of declaration named <paramref name="name" />.
            If no declaration is found, an empty collection is returned.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.OrderedEmitAndByNonUniqueNameDeclarationCollection`1.GetOneByName(System.String)">
      <summary>
            Gets arbitrarly one declaration among the ones having a given name.
            </summary>
      <param name="name">Name of the declaration.</param>
      <returns>A declaration named <paramref name="name" /> (arbitrarly any of all named
            <paramref name="name" /> if there are many), or <b>null</b> if no declaration
            is named <paramref name="name" />.</returns>
    </member>
    <member name="T:PostSharp.CodeModel.Collections.OrderedEmitAndByUniqueNameDeclarationCollection`1">
      <internal />
      <summary>
            Collections of declarations with an index per emit order and a non-unique index
            on name.
            </summary>
      <typeparam name="ItemType" />
    </member>
    <member name="M:PostSharp.CodeModel.Collections.OrderedEmitAndByUniqueNameDeclarationCollection`1.GetByName(System.String)">
      <summary>
            Gets the declaration given its name.
            </summary>
      <param name="name">Name of the declaration.</param>
      <returns>The declaration named <paramref name="name" />, or
            <b>null</b> if no declaration matches the current name.</returns>
    </member>
    <member name="T:PostSharp.CodeModel.Collections.OrdinalDeclarationCollection`1">
      <internal />
      <summary>
            Collection of declarations indexed by ordinal, implementing <see cref="T:System.Collections.Generic.IList`1" />.
            </summary>
      <typeparam name="ItemType" />
    </member>
    <member name="P:PostSharp.CodeModel.Collections.OrdinalDeclarationCollection`1.Item(System.Int32)">
      <summary>
            Gets the declaration given its ordinal.
            </summary>
      <param name="index">Declaration ordinal.</param>
      <returns>The declaration whose ordinal is <paramref name="index" />,
            or <b>null</b> the collection does not contain such declaration.</returns>
    </member>
    <member name="T:PostSharp.CodeModel.Collections.MetadataDeclarationDirectory`1">
      <summary>
            Dictionary where keys are declarations (<see cref="T:PostSharp.CodeModel.MetadataDeclaration" />).
            The implementation is partially thread-safe and is optimized to have 
            low lock contention.
            </summary>
      <typeparam name="T">Type of items stored in the dictionary.</typeparam>
      <remarks>
            This implementation does make the difference between an <i>absent</i>
            and a <i>null</i> item (or an item with default value, if <typeparamref name="T" />
            is a value type).
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.MetadataDeclarationDirectory`1.#ctor(PostSharp.CodeModel.ModuleDeclaration)">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.Collections.MetadataDeclarationDirectory`1" />.
            </summary>
      <param name="module">Module to which declarations should belong.</param>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.MetadataDeclarationDirectory`1.ContainsKey(PostSharp.CodeModel.MetadataDeclaration)" />
    <member name="M:PostSharp.CodeModel.Collections.MetadataDeclarationDirectory`1.Remove(PostSharp.CodeModel.MetadataDeclaration)" />
    <member name="M:PostSharp.CodeModel.Collections.MetadataDeclarationDirectory`1.Clear" />
    <member name="M:PostSharp.CodeModel.Collections.MetadataDeclarationDirectory`1.CopyTo(System.Collections.Generic.KeyValuePair{PostSharp.CodeModel.MetadataDeclaration,`0}[],System.Int32)" />
    <member name="M:PostSharp.CodeModel.Collections.MetadataDeclarationDirectory`1.Remove(System.Collections.Generic.KeyValuePair{PostSharp.CodeModel.MetadataDeclaration,`0})" />
    <member name="M:PostSharp.CodeModel.Collections.MetadataDeclarationDirectory`1.GetEnumerator" />
    <member name="P:PostSharp.CodeModel.Collections.MetadataDeclarationDirectory`1.Item(PostSharp.CodeModel.MetadataDeclaration)" />
    <member name="P:PostSharp.CodeModel.Collections.MetadataDeclarationDirectory`1.Count" />
    <member name="P:PostSharp.CodeModel.Collections.MetadataDeclarationDirectory`1.IsReadOnly" />
    <member name="T:PostSharp.CodeModel.CustomAttributeConstructorException">
      <summary>
            Wraps any exception thrown during the construction of a custom attribute
            runtime instance.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.CustomAttributeConstructorException.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.CustomAttributeConstructorException" /></summary>
    </member>
    <member name="M:PostSharp.CodeModel.CustomAttributeConstructorException.#ctor(System.String)">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.CustomAttributeConstructorException" /> and specifies the exception message.
            </summary>
      <param name="message">Exception message.</param>
    </member>
    <member name="M:PostSharp.CodeModel.CustomAttributeConstructorException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.CustomAttributeConstructorException" /> and specifies the error
            message and the inner exception.
            </summary>
      <param name="message">Exception message.</param>
      <param name="inner">Inner exception.</param>
    </member>
    <member name="M:PostSharp.CodeModel.CustomAttributeConstructorException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Deserialization constructor.
            </summary>
      <param name="info">Serialization information.</param>
      <param name="context">Streaming context.</param>
    </member>
    <member name="T:PostSharp.CodeModel.Domain">
      <summary>
            A domain is a scope, i.e. a context in which external references 
            are resolved. A domain cntains assemblies.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.Domain.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.Domain" />.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.Domain.#ctor(System.Boolean)">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.Domain" /> and specifies whether 
            assemblies are allowed to be loaded into the CLR.
            </summary>
      <param name="disableReflection">
        <b>true</b> if assemblies are loaded
            in the CLR, otherwise <b>false</b>.</param>
    </member>
    <member name="M:PostSharp.CodeModel.Domain.LoadAssembly(System.Reflection.Assembly)">
      <summary>
            Loads an assembly into the current domain (without lazy loaded).
            </summary>
      <param name="reflectionAssembly">A reflection <see cref="T:System.Reflection.Assembly" />.</param>
      <returns>The <see cref="T:PostSharp.CodeModel.AssemblyEnvelope" /> representing the loaded
            assembly.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.Domain.IsAssemblyLoaded(System.Reflection.Assembly)">
      <summary>
            Determines whether an assembly (given the reflection <see cref="T:System.Reflection.Assembly" />) has
            already been loaded in the current <see cref="T:PostSharp.CodeModel.Domain" />.
            </summary>
      <param name="reflectionAssembly">The <see cref="T:System.Reflection.Assembly" /> whose presence in the current
            <see cref="T:PostSharp.CodeModel.Domain" /> should be determined.</param>
      <returns>
        <b>true</b> if <paramref name="reflectionAssembly" /> has already, otherwise <b>false</b>.
            </returns>
    </member>
    <member name="M:PostSharp.CodeModel.Domain.GetAssembly(System.Reflection.Assembly)">
      <summary>
            Gets the <see cref="T:PostSharp.CodeModel.AssemblyEnvelope" /> of the current <see cref="T:PostSharp.CodeModel.Domain" />
            corresponding to a given <see cref="T:System.Reflection.Assembly" />, but does not load the assembly
            into the domain if it is not found.
            </summary>
      <param name="reflectionAssembly">The <see cref="T:System.Reflection.Assembly" /> to be located.</param>
      <returns>The <see cref="T:PostSharp.CodeModel.AssemblyEnvelope" /> corresponding to <paramref name="reflectionAssembly" />,
            or <b>null</b> if the current <see cref="T:PostSharp.CodeModel.Domain" /> does not contain <paramref name="reflectionAssembly" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.Domain.LoadAssembly(System.Reflection.Assembly,System.Boolean)">
      <summary>
            Loads an assembly (given as an <see cref="T:System.Reflection.Assembly" />) into the current domain and specifies whether the assembly should 
            be lazily loaded or not.
            </summary>
      <param name="reflectionAssembly">A reflection <see cref="T:System.Reflection.Assembly" />.</param>
      <param name="lazyLoading">Whether the assembly should be lazily loaded.</param>
      <returns>The <see cref="T:PostSharp.CodeModel.AssemblyEnvelope" /> representing the loaded
            assembly.</returns>
      <remarks>
            Typically, the principal assembly is loaded completely at first time and
            referenced assemblies are loaded lazily.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.Domain.LoadAssembly(System.String,System.Boolean)">
      <summary>
            Loads an assembly (given by file name) into the current domain and specifies whether the assembly should 
            be lazily loaded or not.
            </summary>
      <param name="assemblyLocation">Full path of the physical location of the assembly to be loaded.</param>
      <param name="lazyLoading">Whether the assembly should be lazily loaded.</param>
      <returns>The <see cref="T:PostSharp.CodeModel.AssemblyEnvelope" /> representing the loaded
            assembly.</returns>
      <remarks>
            Typically, the principal assembly is loaded completely at first time and
            referenced assemblies are loaded lazily.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.Domain.FindTypeDefinition(System.Type)">
      <summary>
            Find the <see cref="T:PostSharp.CodeModel.TypeDefDeclaration" /> of a given <see cref="T:System.Type" /> in the current <see cref="T:PostSharp.CodeModel.Domain" />
            with default binding options.
            </summary>
      <param name="type">The <see cref="T:System.Type" /> whose definition is requested.</param>
      <returns>The <see cref="T:PostSharp.CodeModel.TypeDefDeclaration" /> corresponding to <paramref name="type" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.Domain.FindTypeDefinition(System.Type,PostSharp.CodeModel.BindingOptions)">
      <summary>
            Find the <see cref="T:PostSharp.CodeModel.TypeDefDeclaration" /> of a given <see cref="T:System.Type" /> in the current <see cref="T:PostSharp.CodeModel.Domain" />
            and specifies binding options.
            </summary>
      <param name="type">The <see cref="T:System.Type" /> whose definition is requested.</param>
      <param name="bindingOptions">Binding options.</param>
      <returns>The <see cref="T:PostSharp.CodeModel.TypeDefDeclaration" /> corresponding to <paramref name="type" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.Domain.GetAssembly(System.String)">
      <summary>
            Gets an assembly given its name with default binding options.
            </summary>
      <param name="assemblyName">Assembly name.</param>
      <returns>The assembly named <paramref name="assemblyName" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.Domain.GetAssembly(System.String,PostSharp.CodeModel.BindingOptions)">
      <summary>
            Gets an assembly given its name and specifies binding options.
            </summary>
      <param name="assemblyName">Assembly name.</param>
      <param name="bindingOptions">Binding options.</param>
      <returns>The assembly named <paramref name="assemblyName" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.Domain.FindTypeDefinition(System.String,PostSharp.CodeModel.BindingOptions)">
      <summary>
            Find the <see cref="T:PostSharp.CodeModel.TypeDefDeclaration" /> of a type given its name in the current <see cref="T:PostSharp.CodeModel.Domain" />
            and specifies binding options.
            </summary>
      <param name="assemblyQualifiedTypeName">Assembly-qualified name of the type to be found.</param>
      <param name="bindingOptions">Binding options.</param>
      <returns>The <see cref="T:PostSharp.CodeModel.TypeDefDeclaration" /> corresponding to <paramref name="assemblyQualifiedTypeName" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.Domain.FindTypeDefinition(System.String)">
      <summary>
            Find the <see cref="T:PostSharp.CodeModel.TypeDefDeclaration" /> of a type given its name in the current <see cref="T:PostSharp.CodeModel.Domain" />
            with default binding options.
            </summary>
      <param name="assemblyQualifiedTypeName">Assembly-qualified name of the type to be found.</param>
      <returns>The <see cref="T:PostSharp.CodeModel.TypeDefDeclaration" /> corresponding to <paramref name="assemblyQualifiedTypeName" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.Domain.GetAssembly(PostSharp.CodeModel.IAssemblyName)">
      <summary>
            Gets an assembly from the current domain given its name or loads it
            into the domain if not yet present, with default binding options.
            </summary>
      <param name="assemblyName">Name of the assembly to load.</param>
      <returns>The <see cref="T:PostSharp.CodeModel.AssemblyEnvelope" /> corresponding to <paramref name="assemblyName" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.Domain.GetAssembly(PostSharp.CodeModel.IAssemblyName,PostSharp.CodeModel.BindingOptions)">
      <summary>
            Gets an assembly from the current domain given its name or loads it
            into the domain if not yet present, and specifies binding options.
            </summary>
      <param name="assemblyName">Name of the assembly to load.</param>
      <param name="bindingOptions">Binding options.</param>
      <returns>The <see cref="T:PostSharp.CodeModel.AssemblyEnvelope" /> corresponding to <paramref name="assemblyName" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.Domain.Dispose" />
    <member name="M:PostSharp.CodeModel.Domain.GetTag(System.Guid)">
      <summary>
            Gets a tag associated with the current declaration.
            </summary>
      <param name="guid">Tag identifier.</param>
      <returns>An object, or <b>null</b> if no tag of type <paramref name="guid" />
            is associated to the current declaration.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.Domain.SetTag(System.Guid,System.Object)">
      <summary>
            Set a tag to the current declaration.
            </summary>
      <param name="guid">Tag identifier.</param>
      <param name="value">Tag value.</param>
    </member>
    <member name="M:PostSharp.CodeModel.Domain.ToString" />
    <member name="P:PostSharp.CodeModel.Domain.AssemblyLocator">
      <summary>
            The <see cref="P:PostSharp.CodeModel.Domain.AssemblyLocator" /> for the current <see cref="T:PostSharp.CodeModel.Domain" />.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.Domain.ReflectionDisabled">
      <summary>
            Determines whether assemblies of the current <see cref="T:PostSharp.CodeModel.Domain" /> are loaded into the CLR.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.Domain.Guid">
      <summary>
            Gets the GUID of this domain.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.Domain.Assemblies">
      <summary>
            Gets the collection of assemblies loaded in the domain.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.Domain.AssemblyRedirectionPolicies">
      <summary>
            Gets the <see cref="T:PostSharp.CodeModel.AssemblyRedirectionPolicyManager" /> for the current domain.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.ExportedTypeDeclaration">
      <summary>
            Represents a type exported by the current assembly but not defined in the current
            module.
            </summary>
      <remarks>
            Exported types are owned by the assembly manifest (<see cref="T:PostSharp.CodeModel.AssemblyManifestDeclaration" />.
            </remarks>
    </member>
    <member name="T:PostSharp.CodeModel.NamedDeclaration">
      <summary>
            Extends the <see cref="T:PostSharp.CodeModel.MetadataDeclaration" /> class with a <b>Name</b> property.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.MetadataDeclaration">
      <summary>
            Base class for all declarations represented in the metadata tables.
            Metadata declarations have a token (<see cref="P:PostSharp.CodeModel.MetadataDeclaration.MetadataToken" />) and may have 
            custom attributes (<see cref="T:PostSharp.CodeModel.CustomAttributeDeclaration" />).
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.Declaration">
      <summary>
            Base type for all declarations of a module. 
            </summary>
      <remarks>
            A <see cref="T:PostSharp.CodeModel.Declaration" /> is basically an <see cref="T:PostSharp.CodeModel.Element" />
            that has a <see cref="T:PostSharp.CodeModel.ModuleDeclaration" /> in its ancestor axis.
            It is exposed in the <see cref="P:PostSharp.CodeModel.Declaration.Module" /> property.
            </remarks>
    </member>
    <member name="T:PostSharp.CodeModel.IDeclaration">
      <summary>
            Exposes the semantics of a declaration, which is basically a module-scoped domain element.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.IElement">
      <summary>
            Defines the semantics of a domain element, which is basically a domain-rooted tree node.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.IElement.Domain">
      <summary>
            Gets the <see cref="P:PostSharp.CodeModel.IElement.Domain" /> to which the current element belongs.
            </summary>
      <value>
            A <see cref="P:PostSharp.CodeModel.IElement.Domain" />, or <b>null</b> if the element is detached.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.IElement.Parent">
      <summary>
            Gets the direct parent of the current element.
            </summary>
      <value>
            An <see cref="T:PostSharp.CodeModel.Element" />, or <b>null</b> if the element is detached.
            </value>
    </member>
    <member name="T:PostSharp.CodeModel.IModuleScoped">
      <summary>
            Defines a <b>Module</b> property.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.IModuleScoped.Module">
      <summary>
            Gets the declaring module.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.IModuleScoped.DeclaringAssembly">
      <summary>
            Gets the declaring assembly.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.Declaration.Module">
      <summary>
            Gets the declaring module.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.Declaration.DeclaringAssembly">
      <summary>
            Gets the declaring assembly.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.IMetadataDeclaration">
      <summary>
            Defines the semantics of a metadata declaration, i.e. a declaration with
            a token.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.IDeclarationWithCustomAttributes">
      <summary>
            Defines the semantics of a declaration with custom attributes.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.IDeclarationWithCustomAttributes.CustomAttributes">
      <summary>
            Gets the collection of custom attributes.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.IMetadataDeclaration.GetTokenType">
      <summary>
            Gets the metadata token type of the current declaration.
            </summary>
      <returns>A <see cref="T:PostSharp.CodeModel.TokenType" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.IMetadataDeclaration.GetReflectionWrapperObject(System.Type[],System.Type[])">
      <summary>
            Gets a reflection object (<see cref="T:System.Type" />, <see cref="T:System.Reflection.FieldInfo" />, <see cref="T:System.Reflection.MethodInfo" />,
            <see cref="T:System.Reflection.ParameterInfo" />, ...) that wraps the current declaration.
            </summary>
      <param name="genericTypeArguments">Array of generic type arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <param name="genericMethodArguments">Array of generic method arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <returns>A <b>System.Reflection</b> object wrapping current declaration. If the
            current declaration is an assembly (<see cref="T:PostSharp.CodeModel.IAssembly" />), an <see cref="T:PostSharp.CodeModel.ReflectionWrapper.IAssemblyWrapper" />
            object is returned.
            </returns>
      <remarks>
            This method returns an object that is different from the system
            runtime type that is retrieved by <see cref="M:PostSharp.CodeModel.IMetadataDeclaration.GetReflectionSystemObject(System.Type[],System.Type[])" />. This allows
            a have a <b>System.Reflection</b> representation of the current declaration even
            when it cannot be loaded in the Virtual Runtime Engine.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.IMetadataDeclaration.GetReflectionSystemObject(System.Type[],System.Type[])">
      <summary>
            Gets the system, runtime object (<see cref="T:System.Type" />, <see cref="T:System.Reflection.FieldInfo" />, <see cref="T:System.Reflection.MethodInfo" />,
            <see cref="T:System.Reflection.ParameterInfo" />, ...) corresponding to the current declaration.
            </summary>
      <param name="genericTypeArguments">Array of generic type arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <param name="genericMethodArguments">Array of generic method arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <returns>The system object associated the current type in the
            given generic context.</returns>
    </member>
    <member name="P:PostSharp.CodeModel.IMetadataDeclaration.MetadataToken">
      <summary>
            Gets the metadata token of the current declaration.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.MetadataDeclaration.GetTokenType">
      <summary>
            Gets the <see cref="T:PostSharp.CodeModel.TokenType" /> of the derived declaration.
            </summary>
      <returns>A <see cref="T:PostSharp.CodeModel.TokenType" />.</returns>
      <remarks>
            This allows to determines to which metadata table the declaration
            belongs.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.MetadataDeclaration.GetTag(System.Guid)">
      <summary>
            Gets a tag associated with the current declaration.
            </summary>
      <param name="guid">Tag identifier.</param>
      <returns>An object, or <b>null</b> if no tag of type <paramref name="guid" />
            is associated to the current declaration.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.MetadataDeclaration.SetTag(System.Guid,System.Object)">
      <summary>
            Set a tag to the current declaration.
            </summary>
      <param name="guid">Tag identifier.</param>
      <param name="value">Tag value.</param>
    </member>
    <member name="M:PostSharp.CodeModel.MetadataDeclaration.Dispose" />
    <member name="P:PostSharp.CodeModel.MetadataDeclaration.MetadataToken">
      <summary>
            Gets or sets the token of the current declaration.
            </summary>
      <value>
            A <see cref="P:PostSharp.CodeModel.MetadataDeclaration.MetadataToken" />.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.MetadataDeclaration.CustomAttributes">
      <summary>
            Gets the collection of custom attributes.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MetadataDeclaration.IsDisposed">
      <summary>
            Determines whether the current instance is disposed.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.NamedDeclaration.ToString" />
    <member name="P:PostSharp.CodeModel.NamedDeclaration.Name">
      <summary>
            Gets or sets the name of the current declaration.
            </summary>
    </member>
    <member name="T:PostSharp.ModuleWriter.IWriteILDefinition">
      <summary>
            Exposes a method that writes the IL definition of the current instance
            to an <see cref="T:PostSharp.ModuleWriter.ILWriter" />.
            </summary>
    </member>
    <member name="M:PostSharp.ModuleWriter.IWriteILDefinition.WriteILDefinition(PostSharp.ModuleWriter.ILWriter)">
      <summary>
            Writes the IL definition of the current instance.
            </summary>
      <param name="writer">An <see cref="T:PostSharp.ModuleWriter.ILWriter" />.</param>
    </member>
    <member name="T:PostSharp.CodeModel.IManifestResourceImplementation">
      <summary>
            Defines the semantics that are common to all physical locations
            that can contain resources (<see cref="T:PostSharp.CodeModel.ManifestResourceDeclaration" />).
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.ExportedTypeDeclaration.GetTokenType" />
    <member name="M:PostSharp.CodeModel.ExportedTypeDeclaration.WriteILDefinition(PostSharp.ModuleWriter.ILWriter)">
      <summary>
            Writes the IL definition of the current instance.
            </summary>
      <param name="writer">An <see cref="T:PostSharp.ModuleWriter.ILWriter" />.</param>
    </member>
    <member name="P:PostSharp.CodeModel.ExportedTypeDeclaration.Attributes">
      <summary>
            Gets or sets the type attributes.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.ExportedTypeDeclaration.TypeDefId">
      <summary>
            Gets or sets the identifier of the type definition.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.ExportedTypeDeclaration.Implementation">
      <summary>
            Gets or sets the external class or the external file implementing
            this type.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.ExportedTypeDeclaration.DeclaringExportedType">
      <summary>
            Gets the parent exported type, if the current type is a nested one.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.Collections.ExportedTypeDeclarationCollection">
      <summary>
            Collection of exported types (<see cref="T:PostSharp.CodeModel.ExportedTypeDeclaration" />).
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.FieldDefDeclaration">
      <summary>
            Represents a field definition (<see cref="F:PostSharp.CodeModel.TokenType.FieldDef" />). 
            </summary>
      <remarks>
            Fieds are owned by a types (<see cref="T:PostSharp.CodeModel.TypeDefDeclaration" />) on the
             <see cref="P:PostSharp.CodeModel.TypeDefDeclaration.Fields" /> property.
            </remarks>
    </member>
    <member name="T:PostSharp.CodeModel.IField">
      <summary>
            Defines the semantics of a field
            (<see cref="T:PostSharp.CodeModel.FieldDefDeclaration" />, <see cref="T:PostSharp.CodeModel.FieldRefDeclaration" />).
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.IMember">
      <summary>
            Defines the semantics of a type member (<see cref="P:PostSharp.CodeModel.IMember.DeclaringType" />
            and <see cref="P:PostSharp.CodeModel.IMember.Name" /> properties).
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.IMember.DeclaringType">
      <summary>
            Gets the declaring type.
            </summary>
      <value>
            The declaring type (<see cref="T:PostSharp.CodeModel.IType" />), or <b>null</b> if the 
            member is contained by the module.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.IMember.Name">
      <summary>
            Gets the method name.
            </summary>
      <value>
            The method name.
            </value>
    </member>
    <member name="M:PostSharp.CodeModel.IField.GetGenericContext(PostSharp.CodeModel.GenericContextOptions)">
      <summary>
            Gets the generic context of the declaring type, or 
            an empty context if the member is contained by the module.
            </summary>
      <returns />
    </member>
    <member name="M:PostSharp.CodeModel.IField.GetSystemField(System.Type[],System.Type[])">
      <summary>
            Gets the system runtime field corresponding to the current field.
            </summary>
      <param name="genericTypeArguments">Array of generic type arguments valid in the current context.</param>
      <param name="genericMethodArguments">Array of generic method arguments valid in the current context.</param>
      <returns>The system runtime <see cref="T:System.Reflection.FieldInfo" />, or <b>null</b> if
            the current field could not be bound.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.IField.GetReflectionWrapper(System.Type[],System.Type[])">
      <summary>
            Gets a reflection <see cref="T:System.Reflection.FieldInfo" /> that wraps the current field.
            </summary>
      <param name="genericTypeArguments">Array of generic type arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <param name="genericMethodArguments">Array of generic method arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <returns>A <see cref="T:System.Reflection.FieldInfo" /> wrapping current field in the
            given generic context.</returns>
      <remarks>
            This method returns a <see cref="T:System.Reflection.FieldInfo" /> that is different from the system
            runtime field that is retrieved by <see cref="M:PostSharp.CodeModel.IField.GetSystemField(System.Type[],System.Type[])" />. This allows
            a have a <b>System.Reflection</b> representation of the current field even
            when the declaring type it cannot be loaded in the Virtual Runtime Engine.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.IField.GetFieldDefinition">
      <summary>
            Finds in the current domain the <see cref="T:PostSharp.CodeModel.FieldDefDeclaration" /> corresponding
            to the current field with default <see cref="T:PostSharp.CodeModel.BindingOptions" />.
            </summary>
      <returns>The <see cref="T:PostSharp.CodeModel.FieldDefDeclaration" /> corresponding to the current 
            instance in the current domain.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.IField.GetFieldDefinition(PostSharp.CodeModel.BindingOptions)">
      <summary>
            Finds in the current domain the <see cref="T:PostSharp.CodeModel.FieldDefDeclaration" /> corresponding
            to the current field and specifies <see cref="T:PostSharp.CodeModel.BindingOptions" />.
            </summary>
      <param name="bindingOptions">Binding options.</param>
      <returns>The <see cref="T:PostSharp.CodeModel.FieldDefDeclaration" /> corresponding to the current 
            instance in the current domain.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.IField.Translate(PostSharp.CodeModel.ModuleDeclaration)">
      <summary>
            Translates the current field so that it is meaningful in another
            module than the one to which it primarly belong.
            </summary>
      <param name="targetModule">Module into which the type signature should be
            translated.</param>
      <returns>A field meaningful in the <paramref name="targetModule" />
            module.</returns>
    </member>
    <member name="P:PostSharp.CodeModel.IField.FieldType">
      <summary>
            Gets the field type.
            </summary>
      <value>
            A <see cref="T:PostSharp.CodeModel.TypeSignature" />.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.IField.Attributes">
      <summary>
            Gets the field attributes.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.IField.IsStatic">
      <summary>
            Determines whether the field is static.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.IField.IsReadOnly">
      <summary>
            Determines whether the field is read-only (i.e. init only).
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.IField.IsConst">
      <summary>
            Determines whether the field is constant (i.e. literal).
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.IRemoveable">
      <summary>
            Defines the semantics of a declaration that can be removed from its parent.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.IRemoveable.Remove">
      <summary>
            Remove the current declaration from its parent.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.FieldDefDeclaration.AutoOffset">
      <summary>
            When applied to the <see cref="P:PostSharp.CodeModel.FieldDefDeclaration.Offset" /> value,
            indicates that the offset is determined by the runtime
            automatically.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.FieldDefDeclaration.GetTokenType">
      <summary>
            Gets the metadata token type of the current declaration.
            </summary>
      <returns>A <see cref="T:PostSharp.CodeModel.TokenType" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.FieldDefDeclaration.GetGenericContext(PostSharp.CodeModel.GenericContextOptions)">
      <summary>
            Gets the generic context of the declaring type.
            </summary>
      <returns>The generic context of the declaring type, or an empty context
            if the current field is declared at module level.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.FieldDefDeclaration.GetReflectionWrapper(System.Type[],System.Type[])">
      <summary>
            Gets a reflection <see cref="T:System.Reflection.FieldInfo" /> that wraps the current field.
            </summary>
      <param name="genericTypeArguments">Array of generic type arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <param name="genericMethodArguments">Array of generic method arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <returns>A <see cref="T:System.Reflection.FieldInfo" /> wrapping current field in the
            given generic context.</returns>
      <remarks>
            This method returns a <see cref="T:System.Reflection.FieldInfo" /> that is different from the system
            runtime field that is retrieved by <see cref="M:PostSharp.CodeModel.IField.GetSystemField(System.Type[],System.Type[])" />. This allows
            a have a <b>System.Reflection</b> representation of the current field even
            when the declaring type it cannot be loaded in the Virtual Runtime Engine.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.FieldDefDeclaration.GetSystemField(System.Type[],System.Type[])">
      <summary>
            Gets the system runtime field corresponding to the current field.
            </summary>
      <param name="genericTypeArguments">Array of generic type arguments valid in the current context.</param>
      <param name="genericMethodArguments">Array of generic method arguments valid in the current context.</param>
      <returns>The system runtime <see cref="T:System.Reflection.FieldInfo" />, or <b>null</b> if
            the current field could not be bound.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.FieldDefDeclaration.Translate(PostSharp.CodeModel.ModuleDeclaration)">
      <summary>
            Translates the current field so that it is meaningful in another
            module than the one to which it primarly belong.
            </summary>
      <param name="targetModule">Module into which the type signature should be
            translated.</param>
      <returns>A field meaningful in the <paramref name="targetModule" />
            module.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.FieldDefDeclaration.Remove">
      <summary>
            Remove the current declaration from its parent.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.FieldDefDeclaration.WriteILDefinition(PostSharp.ModuleWriter.ILWriter)">
      <summary>
            Writes the IL definition of the current instance.
            </summary>
      <param name="writer">An <see cref="T:PostSharp.ModuleWriter.ILWriter" />.</param>
    </member>
    <member name="M:PostSharp.CodeModel.FieldDefDeclaration.ToString" />
    <member name="P:PostSharp.CodeModel.FieldDefDeclaration.DeclaringType">
      <summary>
            Gets the type declaring the current field.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.FieldDefDeclaration.Visibility">
      <summary>
            Gets the field visibility.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.FieldDefDeclaration.FieldType">
      <summary>
            Gets or set the field type.
            </summary>
      <value>
            A <see cref="T:PostSharp.CodeModel.TypeSignature" />.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.FieldDefDeclaration.LiteralValue">
      <summary>
            Gets the value of the literal field.
            </summary>
      <value>
            A <see cref="T:PostSharp.CodeModel.SerializedValue" />, or <b>null</b> if the field is not literal.
            </value>
      <remarks>
            The value of the current property determines the value of a literal field,
            i.e. a field whose <see cref="P:PostSharp.CodeModel.FieldDefDeclaration.Attributes" /> includes
            <see cref="F:System.Reflection.FieldAttributes.Literal" />. Some rules apply to literal fields.
            They are not enforced by the Code Object Model.
            </remarks>
    </member>
    <member name="P:PostSharp.CodeModel.FieldDefDeclaration.InitialValue">
      <summary>
            Gets or sets the <see cref="T:PostSharp.CodeModel.DataSectionDeclaration" /> used to initialize
            the field.
            </summary>
      <value>
            A <see cref="T:PostSharp.CodeModel.DataSectionDeclaration" />, or <b>null</b> if the field should be
            initialized with its default (zero) value.
            </value>
      <remarks>
            This field should be set if and only if
            the field <see cref="P:PostSharp.CodeModel.FieldDefDeclaration.Attributes" /> includes
            <see cref="F:System.Reflection.FieldAttributes.HasFieldRVA" />. Some rules apply
            to initialized fields. They are not enforced by the
            Code Object Model.
            </remarks>
    </member>
    <member name="P:PostSharp.CodeModel.FieldDefDeclaration.MarshalType">
      <summary>
            Gets or sets the <see cref="P:PostSharp.CodeModel.FieldDefDeclaration.MarshalType" /> of the field.
            </summary>
      <value>
            A <see cref="P:PostSharp.CodeModel.FieldDefDeclaration.MarshalType" />, or <b>null</b> if default
            marshalling should be performed.
            </value>
      <remarks>
            This field should be set if and only if
            the field <see cref="P:PostSharp.CodeModel.FieldDefDeclaration.Attributes" /> includes
            <see cref="F:System.Reflection.FieldAttributes.HasFieldMarshal" />. This rule
            is not enforced by the Code Object Model.
            </remarks>
    </member>
    <member name="P:PostSharp.CodeModel.FieldDefDeclaration.Offset">
      <summary>
            Gets or sets the offset of the current field in the type layout.
            </summary>
      <value>
            The offset of the current field in the type layout,
            or <see cref="F:PostSharp.CodeModel.FieldDefDeclaration.AutoOffset" /> if the field
            offset is computed by the runtime.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.FieldDefDeclaration.Attributes">
      <summary>
            Gets or sets the field attributes.
            </summary>
      <value>
            A combination of <see cref="T:System.Reflection.FieldAttributes" />.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.FieldDefDeclaration.IsStatic">
      <summary>
            Determines whether the field is static.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.FieldDefDeclaration.IsReadOnly">
      <summary>
            Determines whether the field is read-only (i.e. init only).
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.FieldDefDeclaration.IsConst">
      <summary>
            Determines whether the field is constant (i.e. literal).
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.Collections.FieldDefDeclarationCollection">
      <summary>
            Collection of <see cref="T:PostSharp.CodeModel.FieldDefDeclaration" /> objects.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.Collections.IFieldCollection">
      <summary>
            Semantics of collections of fields as required by <see cref="T:PostSharp.CodeModel.IType" />.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.IFieldCollection.GetField(System.String,PostSharp.CodeModel.ITypeSignature,PostSharp.CodeModel.BindingOptions)">
      <summary>
            Finds a field in the type given its name and type.
            </summary>
      <param name="name">Field name.</param>
      <param name="type">Field type.</param>
      <param name="bindingOptions">Determines the behavior in case the field is not
            found.</param>
      <returns>The field, or <b>null</b> if the method could not be found.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.IFieldCollection.GetByName(System.String)">
      <summary>
            Gets a field given its name.
            </summary>
      <param name="name">Field name.</param>
      <returns>The field named <paramref name="name" />, or <b>null</b> if no such
            field exist in the collection.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.FieldDefDeclarationCollection.GetField(System.String,PostSharp.CodeModel.ITypeSignature,PostSharp.CodeModel.BindingOptions)">
      <summary>
            Finds a field in the type given its name and type.
            </summary>
      <param name="name">Field name.</param>
      <param name="type">Field type.</param>
      <param name="bindingOptions">Determines the behavior in case the field is not
            found.</param>
      <returns>The field, or <b>null</b> if the method could not be found.</returns>
    </member>
    <member name="T:PostSharp.CodeModel.GenericMap">
      <summary>
            Map generic arguments to their value.
            </summary>
      <remarks>
        <para>
            Generic arguments are always given by ordinal. The current object stores
            a map between ordinals and a type signature to which the ordinal is
            mapped.
            </para>
        <para>Do not rely on the <see cref="M:System.Object.Equals(System.Object)" /> method to test for equality.</para>
      </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.GenericMap.#ctor(System.Collections.Generic.IList{PostSharp.CodeModel.ITypeSignature},System.Collections.Generic.IList{PostSharp.CodeModel.ITypeSignature})">
      <summary>
            Initializes a new instance of the <see cref="T:PostSharp.CodeModel.GenericMap" /> type with
            explicit values.
            </summary>
      <param name="genericTypeParameters">Generic type parameters, or <b>null</b>.</param>
      <param name="genericMethodParameters">Generic method parameters, or <b>null</b>.</param>
    </member>
    <member name="M:PostSharp.CodeModel.GenericMap.#ctor(PostSharp.CodeModel.GenericMap,System.Collections.Generic.IList{PostSharp.CodeModel.ITypeSignature})">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.GenericMap" /> and copies the type parameters
            of another <see cref="T:PostSharp.CodeModel.GenericMap" />.
            </summary>
      <param name="typeGenericMap">
        <see cref="T:PostSharp.CodeModel.GenericMap" /> from which type
            parameters have to be copied.</param>
      <param name="genericMethodParameters">Generic method parameters, or <b>null</b>.</param>
      <remarks>
            This is typically used to complete a type-level context with generic
            method parameters.
            </remarks>
    </member>
    <member name="F:PostSharp.CodeModel.GenericMap.Empty">
      <summary>
            Gets an empty <see cref="T:PostSharp.CodeModel.GenericMap" /> (a context without generic parameters).
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.GenericMap.GetGenericTypeParameter(System.Int32)">
      <summary>
            Gets the type mapped to a given type generic parameter.
            </summary>
      <param name="ordinal">The parameter position.</param>
      <returns>The <see cref="T:PostSharp.CodeModel.ITypeSignature" /> mapped to this generic parameter.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.GenericMap.GetGenericTypeParameters">
      <summary>
            Gets the array of type generic arguments in the current <see cref="T:PostSharp.CodeModel.GenericMap" />.
            </summary>
      <returns>An array of <see cref="T:PostSharp.CodeModel.ITypeSignature" />, or <b>null</b> if the current
            <see cref="T:PostSharp.CodeModel.GenericMap" /> has no type generic argument.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.GenericMap.GetGenericMethodParameters">
      <summary>
            Gets the array of method generic arguments in the current <see cref="T:PostSharp.CodeModel.GenericMap" />.
            </summary>
      <returns>An array of <see cref="T:PostSharp.CodeModel.ITypeSignature" />, or <b>null</b> if the current
            <see cref="T:PostSharp.CodeModel.GenericMap" /> has no method generic argument.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.GenericMap.GetGenericMethodParameter(System.Int32)">
      <summary>
             Gets the type mapped to a given method generic parameter.
            </summary>
      <param name="ordinal">The parameter position.</param>
      <returns>The <see cref="T:PostSharp.CodeModel.ITypeSignature" /> mapped to this generic parameter.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.GenericMap.GetGenericParameter(PostSharp.CodeModel.GenericParameterKind,System.Int32)">
      <summary>
            Gets the type mapped to a generic parameter given its kind and ordinal.
            </summary>
      <param name="kind">The kind of generic parameter (type or method).</param>
      <param name="ordinal">The ordinal.</param>
      <returns>The <see cref="T:PostSharp.CodeModel.ITypeSignature" /> mapped to this generic parameter.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.GenericMap.ContainsGenericParameter(PostSharp.CodeModel.GenericParameterKind,System.Int32)">
      <summary>
            Determines whether the current <see cref="T:PostSharp.CodeModel.GenericMap" /> contains a mapping for
            a given generic parameter.
            </summary>
      <param name="kind">Kind of generic parameter.</param>
      <param name="ordinal">Ordinal of the generic parameter.</param>
      <returns>
        <b>true</b> if the current <see cref="T:PostSharp.CodeModel.GenericMap" /> contains a mapping for
            the generic parameter of kind <paramref name="kind" /> and ordinal <paramref name="ordinal" />,
            otherwise <b>false</b>.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.GenericMap.GetGenericParameter(PostSharp.CodeModel.IGenericParameter)">
      <summary>
            Gets the type mapped to a given generic parameter given an <see cref="T:PostSharp.CodeModel.IGenericParameter" />.
            </summary>
      <param name="genericParameter">A generic parameter.</param>
      <returns>The <see cref="T:PostSharp.CodeModel.ITypeSignature" /> mapped to this generic parameter.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.GenericMap.GetTypeContext">
      <summary>
            Gets a <see cref="T:PostSharp.CodeModel.GenericMap" /> based on the current context,
            but remove method generic parameters.
            </summary>
      <returns>A <see cref="T:PostSharp.CodeModel.GenericMap" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.GenericMap.Apply(PostSharp.CodeModel.GenericMap)">
      <summary>
            Transform the current <see cref="T:PostSharp.CodeModel.GenericMap" /> using a second <see cref="T:PostSharp.CodeModel.GenericMap" />.
            </summary>
      <param name="map">The <see cref="T:PostSharp.CodeModel.GenericMap" /> that should be applied on the
            current map.</param>
      <returns>A <see cref="T:PostSharp.CodeModel.GenericMap" /> where all generic arguments where mapped
            by <paramref name="map" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.GenericMap.ToString" />
    <member name="P:PostSharp.CodeModel.GenericMap.IsEmpty">
      <summary>
            Determines whether the current generic context is empty, i.e. has no generic argument
            or parameter at all.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.GenericMap.GenericTypeParameterCount">
      <summary>
            Gets the number of generic type parameters.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.GenericMap.GenericMethodParameterCount">
      <summary>
            Gets the number of generic method parameters.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.GenericParameterConstraintDeclaration">
      <summary>
            Represents a constraint of a generic parameter (<see cref="F:PostSharp.CodeModel.TokenType.GenericParamConstraint" />).
            </summary>
      <remarks>
            Generic paraeter constraints are owner by generic parameters (<see cref="T:PostSharp.CodeModel.GenericParameterDeclaration" />).
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.GenericParameterConstraintDeclaration.GetTokenType" />
    <member name="P:PostSharp.CodeModel.GenericParameterConstraintDeclaration.ConstraintType">
      <summary>
            Gets or sets the constraint type.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.Collections.GenericParameterConstraintDeclarationCollection">
      <summary>
            Collection of <see cref="T:PostSharp.CodeModel.GenericParameterConstraintDeclaration" />.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.GenericParameterConstraintDeclarationCollection.Add(PostSharp.CodeModel.ITypeSignature)">
      <summary>
            Adds a constraint to the current collection by specifying its type (<see cref="T:PostSharp.CodeModel.ITypeSignature" />).
            </summary>
      <param name="type">Constraint type.</param>
      <returns>The <see cref="T:PostSharp.CodeModel.GenericParameterConstraintDeclaration" /> representing the
            new constraint.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.GenericParameterConstraintDeclarationCollection.AddRangeClone(System.Collections.Generic.IEnumerable{PostSharp.CodeModel.GenericParameterConstraintDeclaration},PostSharp.CodeModel.GenericMap)">
      <summary>
            Clone a set of constraints and add them to the current collection after having mapped their
            generic arguments.
            </summary>
      <param name="constraints">The set of constraints to be cloned and added to the current collection.</param>
      <param name="genericMap">Generic map with which generic arguments in contraint types have to be mapped.</param>
    </member>
    <member name="T:PostSharp.CodeModel.GenericParameterKind">
      <summary>
            Enumerates the kind of classes accepting generic parameters.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.GenericParameterKind.Type">
      <summary>
            Type.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.GenericParameterKind.Method">
      <summary>
            Method.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.Helpers.AssemblyNameHelper">
      <summary>
            Provides helper methods to work with assembly names.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.Helpers.AssemblyNameHelper.ParseBytes(System.String)">
      <summary>
            Parses an hexadecimal string into an array of bytes.
            </summary>
      <param name="str">A string containing hexadecimal characters. Should contain a peer number of characters.</param>
      <returns>The bytes represented by <paramref name="str" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.Helpers.AssemblyNameHelper.FormatBytes(System.Byte[],System.Text.StringBuilder)">
      <summary>
            Formats an array of bytes into an hexadecimal string, using a <see cref="T:System.Text.StringBuilder" />.
            </summary>
      <param name="bytes">An array of bytes.</param>
      <param name="builder">The <see cref="T:System.Text.StringBuilder" /> into which the string has to be written.</param>
    </member>
    <member name="M:PostSharp.CodeModel.Helpers.AssemblyNameHelper.FormatBytes(System.Byte[])">
      <summary>
            Formats an array of bytes into a hexadecimal string.
            </summary>
      <param name="bytes">An array of bytes.</param>
      <returns>The hexadecimal string corresponding to <paramref name="bytes" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.Helpers.AssemblyNameHelper.FormatAssemblyFullName(System.String,System.Version,System.String,System.Byte[])">
      <summary>
            Composes a full assembly name.
            </summary>
      <param name="name">Friendly name.</param>
      <param name="version">Version (or <b>null</b>).</param>
      <param name="culture">Culture (or <b>null</b>).</param>
      <param name="publicKeyToken">Public key token (or <b>null</b>).</param>
      <returns>The full assembly name corresponding to parameters.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.Helpers.AssemblyNameHelper.ComputeKeyToken(System.Byte[])">
      <summary>
            Compute the token of a public key.
            </summary>
      <param name="publicKey">The public key.</param>
      <returns>The token (i.e. the first 8 bytes of the SHA1 hash) of <paramref name="publicKey" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.Helpers.AssemblyNameHelper.Convert(System.Reflection.AssemblyName)">
      <summary>
            Converts an <see cref="T:System.Reflection.AssemblyName" /> into an <see cref="T:PostSharp.CodeModel.IAssemblyName" />.
            </summary>
      <param name="assemblyName">An <see cref="T:System.Reflection.AssemblyName" />.</param>
      <returns>An <see cref="T:PostSharp.CodeModel.IAssemblyName" /> corresponding to <paramref name="assemblyName" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.Helpers.AssemblyNameHelper.Convert(PostSharp.CodeModel.IAssemblyName)">
      <summary>
            Converts an <see cref="T:PostSharp.CodeModel.IAssemblyName" /> into an <see cref="T:System.Reflection.AssemblyName" />.
            </summary>
      <param name="assemblyName">An <see cref="T:PostSharp.CodeModel.IAssemblyName" />.</param>
      <returns>An <see cref="T:System.Reflection.AssemblyName" /> corresponding to <paramref name="assemblyName" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.Helpers.AssemblyNameHelper.GetAssemblyName(System.Type)">
      <summary>
            Gets the assembly name of a <see cref="T:System.Type" /> (works also with type wrappers).
            </summary>
      <param name="type">A <see cref="T:System.Type" /> (eventually a type wrapper).</param>
      <returns>The name of the assembly declaring <paramref name="type" />.</returns>
    </member>
    <member name="T:PostSharp.CodeModel.Helpers.AssemblyNameWrapper">
      <summary>
            Wraps an <see cref="T:System.Reflection.AssemblyName" /> into an <see cref="T:PostSharp.CodeModel.IAssemblyName" />.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.Helpers.AssemblyNameWrapper.GetWrapper(System.String)">
      <summary>
            Gets an <see cref="T:System.Reflection.AssemblyName" /> for an assembly given as a <see cref="T:System.String" /> containing its full name.
            </summary>
      <param name="assemblyFullName">Full name of the assembly.</param>
      <returns>An <see cref="T:PostSharp.CodeModel.Helpers.AssemblyNameWrapper" /> instance (eventually cached) correspondig
            to <paramref name="assemblyFullName" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.Helpers.AssemblyNameWrapper.GetWrapper(System.Reflection.AssemblyName)">
      <summary>
            Gets an <see cref="T:System.Reflection.AssemblyName" /> for an assembly given as an <see cref="T:System.Reflection.AssemblyName" />.
            </summary>
      <param name="assemblyName">Assembly name.</param>
      <returns>An <see cref="T:PostSharp.CodeModel.Helpers.AssemblyNameWrapper" /> instance (eventually cached) correspondig
            to <paramref name="assemblyName" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.Helpers.AssemblyNameWrapper.GetWrapper(System.Reflection.Assembly)">
      <summary>
            Gets an <see cref="T:System.Reflection.AssemblyName" /> for an <see cref="T:System.Reflection.Assembly" />.
            </summary>
      <param name="assembly">Assembly.</param>
      <returns>An <see cref="T:PostSharp.CodeModel.Helpers.AssemblyNameWrapper" /> instance (eventually cached) correspondig
            to <paramref name="assembly" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.Helpers.AssemblyNameWrapper.GetPublicKey">
      <summary>
            Gets the assemby public key.
            </summary>
      <value>
            An array of bytes containing the public key,
            or <b>null</b> if no public key is specified (for instance if
            only the public key token is given).
            </value>
      <returns>An array of bytes containing the public key,
            or <b>null</b> if no public key is specified.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.Helpers.AssemblyNameWrapper.GetPublicKeyToken">
      <summary>
            Gets the assembly public key token.
            </summary>
      <returns>An array of bytes containing the public key token,
            or <b>null</b> if no public key is specified.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.Helpers.AssemblyNameWrapper.ToString" />
    <member name="P:PostSharp.CodeModel.Helpers.AssemblyNameWrapper.Name">
      <summary>
            Gets the assembly friendly name.
            </summary>
      <value>
            The assembly friendly name.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.Helpers.AssemblyNameWrapper.FullName">
      <summary>
            Gets the assembly full name.
            </summary>
      <value>
            The assembly full name including version number, culture name
            and public key token.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.Helpers.AssemblyNameWrapper.Version">
      <summary>
            Gets the assembly version.
            </summary>
      <value>
            A <see cref="P:PostSharp.CodeModel.IAssemblyName.Version" />.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.Helpers.AssemblyNameWrapper.Culture">
      <summary>
            Gets the assembly culture name.
            </summary>
      <value>
            The standard assembly culture name, or <b>null</b> if the assembly
            is culture-neutral.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.Helpers.AssemblyNameWrapper.IsMscorlib">
      <summary>
            Determines whether the current assembly is <b>mscorlib</b>.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.Helpers.CustomAttributeHelper">
      <summary>
            Provides utility methods for working with custom attributes, for instance constructing
            a runtime object or rendering it to a string.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.Helpers.CustomAttributeHelper.ConstructRuntimeObject(PostSharp.CodeModel.IAnnotationValue,PostSharp.CodeModel.ModuleDeclaration)">
      <summary>
            Construct the instance (typically an object derived from <see cref="T:System.Attribute" />)
            represented by the current <see cref="T:PostSharp.CodeModel.CustomAttributeDeclaration" />.
            </summary>
      <returns>A new instance (typically derived from <see cref="T:System.Attribute" />) constructed 
            on by the constructor
            represented by the <see cref="P:PostSharp.CodeModel.IAnnotationValue.Constructor" /> property and based
            on the values given in <see cref="P:PostSharp.CodeModel.IAnnotationValue.ConstructorArguments" />
            and <see cref="P:PostSharp.CodeModel.IAnnotationValue.NamedArguments" />.</returns>
      <exception cref="T:PostSharp.CodeModel.CustomAttributeConstructorException">The constructor or a property setter
            threw an exception.</exception>
    </member>
    <member name="M:PostSharp.CodeModel.Helpers.CustomAttributeHelper.Render(PostSharp.CodeModel.IAnnotationValue,System.Text.StringBuilder)">
      <summary>
            Renders a custom attribute value to an existing <see cref="T:System.Text.StringBuilder" />.
            </summary>
      <param name="attribute">A custom attribute.</param>
      <param name="target">A <see cref="T:System.Text.StringBuilder" /> where to writer the attribute.</param>
    </member>
    <member name="M:PostSharp.CodeModel.Helpers.CustomAttributeHelper.Render(PostSharp.CodeModel.IAnnotationValue)">
      <summary>
            Renders a custom attribute value to a string.
            </summary>
      <param name="attribute">A custom attribute value.</param>
      <returns>A string representing <paramref name="attribute" />.</returns>
    </member>
    <member name="T:PostSharp.CodeModel.DeclarationCache">
      <summary>
            Caches some frequently-used declarations or constructions with lazy loading.
            </summary>
      <remarks>
        <para>This cache can serve three types of content: types, intrinsic types
            and arbitrary content served by providers. The last mechanism is used
            to cache methods (which are difficult to reference otherwise).
            </para>
        <para>
            The current class provides itself the contents whose key is declared here
            (see static fields of this class).
            </para>
      </remarks>
    </member>
    <member name="F:PostSharp.CodeModel.DeclarationCache.TaggedObjectSerializationType">
      <summary>
            Gets an instance of <see cref="F:PostSharp.CodeModel.DeclarationCache.TaggedObjectSerializationType" /> that is valid for the current module.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.DeclarationCache.TypeSerializationType">
      <summary>
            Gets an instance of <see cref="F:PostSharp.CodeModel.DeclarationCache.TypeSerializationType" /> that is valid for the current module.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.DeclarationCache.IdentityGenericMap">
      <summary>
            Gets a <see cref="T:PostSharp.CodeModel.GenericMap" /> mapping generic parameters on themselves, valid for the
            current module.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.DeclarationCache.GetGenericParameter(System.Int32,PostSharp.CodeModel.GenericParameterKind)">
      <summary>
            Gets a <see cref="T:PostSharp.CodeModel.TypeSignatures.GenericParameterTypeSignature" />.
            </summary>
      <param name="ordinal">Ordinal (index) of the generic parameter.</param>
      <param name="kind">Kind (<see cref="F:PostSharp.CodeModel.GenericParameterKind.Type" /> or <see cref="F:PostSharp.CodeModel.GenericParameterKind.Method" />
            of this generic parameter.</param>
      <returns>A <see cref="T:PostSharp.CodeModel.TypeSignatures.GenericParameterTypeSignature" /> with the given <paramref name="ordinal" />
            and <paramref name="kind" />, valid in the current module.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.DeclarationCache.GetGenericParameterArray(System.Int32,PostSharp.CodeModel.GenericParameterKind)">
      <summary>
            Creates an array of <see cref="T:PostSharp.CodeModel.TypeSignatures.GenericParameterTypeSignature" /> with incremental
            ordinals.
            </summary>
      <param name="length">Array lenght.</param>
      <param name="kind">Kind of generic parameter.</param>
      <returns>An array of <see cref="T:PostSharp.CodeModel.ITypeSignature" /> that can be used to construct
            a generic type or method instance with generic parameters like 
            <c>&lt;!0, !1, ..., !<paramref name="length" />&gt;</c>
            or <c>&lt;!!0, !!1, ..., !!<paramref name="length" />&gt;</c></returns>
    </member>
    <member name="M:PostSharp.CodeModel.DeclarationCache.GetType(System.Type)">
      <summary>
            Gets a type (<see cref="T:PostSharp.CodeModel.ITypeSignature" />) given a reflection type 
            (<see cref="T:System.Type" />), with default binding options.
            </summary>
      <param name="type">The reflection type.</param>
      <returns>An <see cref="T:PostSharp.CodeModel.ITypeSignature" />.</returns>
      <remarks>
        <para>
            You are required to use the second overload and to specify <see cref="T:PostSharp.CodeModel.BindingOptions" />
            when you require a generic type.
            </para>
        <para>If <paramref name="type" /> is a primitive type, the method returns
            the class representing it, i.e. it does <i>not</i> return the intrinsic
            type. Intrinsic type substitution is allowed for type constructions.
            </para>
      </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.DeclarationCache.GetType(System.Type,PostSharp.CodeModel.BindingOptions)">
      <summary>
            Gets a type (<see cref="T:PostSharp.CodeModel.ITypeSignature" />) given a reflection type 
            (<see cref="T:System.Type" />), but specifies <see cref="T:PostSharp.CodeModel.BindingOptions" />.
            </summary>
      <param name="type">The reflection type.</param>
      <param name="bindingOptions">Binding options. Specify <see cref="F:PostSharp.CodeModel.BindingOptions.RequireGenericInstance" />
            or <see cref="F:PostSharp.CodeModel.BindingOptions.RequireGenericDefinition" /> when requesting a generic type.</param>
      <returns>An <see cref="T:PostSharp.CodeModel.ITypeSignature" />.</returns>
      <remarks>
            If <paramref name="type" /> is a primitive type, the method returns
            the class representing it, i.e. it does <i>not</i> return the intrinsic
            type. Intrinsic type substitution is allowed for type constructions.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.DeclarationCache.GetType(System.String)">
      <summary>
            Gets a type (<see cref="T:PostSharp.CodeModel.ITypeSignature" />) given its name.
            </summary>
      <param name="typeName">The reflection type.</param>
      <returns>An <see cref="T:PostSharp.CodeModel.ITypeSignature" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.DeclarationCache.Clear">
      <summary>
            Clear the cache content.
            </summary>
      <remarks>
            This obviously does not clear the list of providers.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.DeclarationCache.GetItem``1(PostSharp.Utilities.Function{``0})">
      <summary>
            Gets a declaration served by a provider.
            </summary>
      <param name="getter">Method providing the cached item</param>
      <returns>The cached item.</returns>
      <remarks>
            The <paramref name="getter" /> parameter is used both as the item key
            (identification of the requested item) and in order to get the value in
            case it is not yet in cache. The item cache is not strictly the passed
            delegate, but only its <i>method</i>, i.e. the object instance is ignored.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.DeclarationCache.GetIntrinsic(PostSharp.CodeModel.IntrinsicType)">
      <summary>
            Gets an <see cref="T:PostSharp.CodeModel.TypeSignatures.IntrinsicTypeSignature" />, given an <see cref="T:PostSharp.CodeModel.IntrinsicType" />.
            </summary>
      <param name="intrinsic">An intrinsic.</param>
      <returns>The <see cref="T:PostSharp.CodeModel.TypeSignatures.IntrinsicTypeSignature" /> corresponding to <paramref name="intrinsic" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.DeclarationCache.GetIntrinsic(System.Type)">
      <summary>
            Gets an <see cref="T:PostSharp.CodeModel.TypeSignatures.IntrinsicTypeSignature" />, given a reflection <see cref="T:System.Type" />.
            </summary>
      <param name="reflectionType">A reflection <see cref="T:System.Type" /> corresponding to an intrinsic.</param>
      <returns>The <see cref="T:PostSharp.CodeModel.TypeSignatures.IntrinsicTypeSignature" /> corresponding to <paramref name="reflectionType" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.DeclarationCache.GetIntrinsicSerializationType(PostSharp.CodeModel.IntrinsicType)">
      <summary>
            Gets an <see cref="T:PostSharp.CodeModel.SerializationTypes.IntrinsicSerializationType" />, given an <see cref="T:PostSharp.CodeModel.IntrinsicType" />.
            </summary>
      <param name="intrinsic">An intrinsic.</param>
      <returns>The <see cref="T:PostSharp.CodeModel.SerializationTypes.IntrinsicSerializationType" /> corresponding to <paramref name="intrinsic" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.DeclarationCache.GetIntrinsicBoxedType(PostSharp.CodeModel.IntrinsicType)">
      <summary>
            Gets the boxed type of an intrinsic.
            </summary>
      <param name="type">The instrinsic type.</param>
      <returns>The boxed type corresponding to the intrinsic type.</returns>
      <example>
        <c>GetIntrinsicBoxedType(IntrinsicType.Object)</c> returns <see cref="T:System.Object" />.</example>
    </member>
    <member name="F:PostSharp.CodeModel.DeclarationCache.TypeGetTypeFromHandle">
      <summary>
            Callback method for the <see cref="M:PostSharp.CodeModel.DeclarationCache.GetItem``1(PostSharp.Utilities.Function{``0})" /> method, retrieving the
            <see cref="T:System.Type" />.<see cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" /> method.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.DeclarationCache.MethodBaseGetMethodFromHandle">
      <summary>
            Callback method for the <see cref="M:PostSharp.CodeModel.DeclarationCache.GetItem``1(PostSharp.Utilities.Function{``0})" /> method, retrieving the
            <see cref="T:System.Reflection.MethodBase" />.<see cref="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)" /> method.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.DeclarationCache.MethodBaseGetMethodFromHandle2">
      <summary>
            Callback method for the <see cref="M:PostSharp.CodeModel.DeclarationCache.GetItem``1(PostSharp.Utilities.Function{``0})" /> method, retrieving the
            <see cref="T:System.Type" />.<see cref="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)" /> method.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.DeclarationCache.FieldInfoGetFieldFromHandle">
      <summary>
            Callback method for the <see cref="M:PostSharp.CodeModel.DeclarationCache.GetItem``1(PostSharp.Utilities.Function{``0})" /> method, retrieving the
            <see cref="T:System.Reflection.FieldInfo" />.<see cref="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle)" /> method.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.DeclarationCache.FieldInfoGetFieldFromHandle2">
      <summary>
            Callback method for the <see cref="M:PostSharp.CodeModel.DeclarationCache.GetItem``1(PostSharp.Utilities.Function{``0})" /> method, retrieving the
            <see cref="T:System.Reflection.FieldInfo" />.<see cref="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle,System.RuntimeTypeHandle)" /> method.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.Helpers.DelegateBuilder">
      <summary>
            Helps to build a <see cref="T:PostSharp.CodeModel.TypeDefDeclaration" /> implementing
            a delegate.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.Helpers.DelegateBuilder.BuildDelegate(PostSharp.CodeModel.ITypeContainer,System.String,PostSharp.CodeModel.Helpers.DelegateSignature)">
      <summary>
            Builds a <see cref="T:PostSharp.CodeModel.TypeDefDeclaration" /> implementing
            a delegate.
            </summary>
      <param name="typeContainer">Declaration to which the <see cref="T:PostSharp.CodeModel.TypeDefDeclaration" /> should be added.</param>
      <param name="name">Type name.</param>
      <param name="delegateSignature">Delegate signature.</param>
      <returns>A <see cref="T:PostSharp.CodeModel.TypeDefDeclaration" /> implementing the delegate.</returns>
      <remarks>
            It seems that Microsoft's runtime engine requires delegates to be derived
            from <see cref="T:System.MulticastDelegate" />.
            </remarks>
    </member>
    <member name="T:PostSharp.CodeModel.Helpers.DelegateSignature">
      <summary>
            Represents a delegate signature.
            </summary>
      <remarks>
            The types used to define a signature can be valid inside a different
            module than the one into which the delegate shall be generated. The
            <see cref="T:PostSharp.CodeModel.Helpers.DelegateBuilder" /> utility translates types automatically.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.Helpers.DelegateSignature.#ctor(PostSharp.CodeModel.ModuleDeclaration)">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.Helpers.DelegateSignature" />.
            </summary>
      <param name="module">Module in which the signature should be valid.</param>
    </member>
    <member name="M:PostSharp.CodeModel.Helpers.DelegateSignature.GetHashCode" />
    <member name="M:PostSharp.CodeModel.Helpers.DelegateSignature.Equals(System.Object)" />
    <member name="M:PostSharp.CodeModel.Helpers.DelegateSignature.Equals(PostSharp.CodeModel.Helpers.DelegateSignature)" />
    <member name="P:PostSharp.CodeModel.Helpers.DelegateSignature.ReturnType">
      <summary>
            Gets or sets the delegate return type.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.Helpers.DelegateSignature.Parameters">
      <summary>
            Gets the list of parameters.
            </summary>
      <remarks>
            Parameters present in this list may be owned by other entities.
            It is not necessary to clone them before adding it to this collection.
            </remarks>
    </member>
    <member name="P:PostSharp.CodeModel.Helpers.DelegateSignature.GenericParameters">
      <summary>
            Gets the list of generic parameters.
            </summary>
      <remarks>
            Generic parameters present in this list may be owned by other entities.
            It is not necessary to clone them before adding it to this collection.
            </remarks>
    </member>
    <member name="T:PostSharp.CodeModel.Helpers.EnumHelper">
      <summary>
            Helps to work with enumerations.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.Helpers.EnumHelper.GetUnderlyingType(PostSharp.CodeModel.IType)">
      <summary>
            Gets the underlying type of an enumeration.
            </summary>
      <param name="type">A type derived from <see cref="T:System.Enum" />.</param>
      <returns>The underlying type of the enumeration.</returns>
    </member>
    <member name="T:PostSharp.CodeModel.Helpers.GenericHelper">
      <summary>
            Provides helper methods to work with generic declarations.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.Helpers.GenericHelper.GetTypeCanonicalGenericInstance(PostSharp.CodeModel.TypeDefDeclaration)">
      <summary>
            Gets the canonical generic instance of a generic type.
            </summary>
      <param name="type">Type whose canonical generic instance is requested.</param>
      <returns>The canonical generic instance of <paramref name="type" />, or
            the unmodified <paramref name="type" /> if <paramref name="type" /> is not a generic
            type definition.</returns>
      <remarks>
            The canonical generic instance of a type is a generic instance where the n-th formal generic
            type argument is mapped to the n-th concrete generic type parameter. For instance, the canonical 
            generic instance of the type MyType`3 is MyType`3&lt;!0,!1,!2&gt;.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.Helpers.GenericHelper.GetTypeCanonicalGenericInstance(PostSharp.CodeModel.TypeDefDeclaration,PostSharp.CodeModel.ModuleDeclaration)">
      <summary>
            Gets the canonical generic instance of a generic type
            and express it for a different module than the one of the generic type definition.
            </summary>
      <param name="type">Type whose canonical generic instance is requested.</param>
      <param name="targetModule">Module in which declarations have to be expressed.</param>
      <returns>The canonical generic instance of <paramref name="type" />, or
            the unmodified <paramref name="type" /> if <paramref name="type" /> is not a generic
            type definition.</returns>
      <remarks>
            The canonical generic instance of a type is a generic instance where the n-th formal generic
            type argument is mapped to the n-th concrete generic type parameter. For instance, the canonical 
            generic instance of the type MyType`3 is MyType`3&lt;!0,!1,!2&gt;.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.Helpers.GenericHelper.GetMethodCanonicalGenericInstance(PostSharp.CodeModel.MethodDefDeclaration)">
      <summary>
            Gets the canonical generic instance of a generic method. 
            </summary>
      <param name="method">Method whose canonical generic instance is requested.</param>
      <returns>The canonical generic instance of <paramref name="method" />, or
            the unmodified <paramref name="method" /> if <paramref name="method" /> is not a generic
            method definition.</returns>
      <remarks>
        <para>
            The canonical generic instance of a method is a generic instance where the n-th formal generic
            method argument is mapped to the n-th concrete generic method parameter. If the declaring type
            is a generic type definition, the canonical generic instance of the method is defined on
            the canonical generic instance of the declaring type (see <see cref="M:PostSharp.CodeModel.Helpers.GenericHelper.GetTypeCanonicalGenericInstance(PostSharp.CodeModel.TypeDefDeclaration)" />).
            </para>
        <para>
            For instance, the canonical 
            generic instance of the type MyType`3::MyMethod is MyType`3&lt;!0,!1,!2&gt;::MyMethod&lt;!0,!1&gt;.
            if MyMethod has two generic arguments.
            </para>
      </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.Helpers.GenericHelper.GetMethodCanonicalGenericInstance(PostSharp.CodeModel.MethodDefDeclaration,PostSharp.CodeModel.ModuleDeclaration)">
      <summary>
            Gets the canonical generic instance of a generic method and express it for a different
            module than the one of the generic method definition.
            </summary>
      <param name="method">Method whose canonical generic instance is requested.</param>
      <param name="targetModule">Module for which the generic instance has to be expressed.</param>
      <returns>The canonical generic instance of <paramref name="method" />, or
            the unmodified <paramref name="method" /> if <paramref name="method" /> is not a generic
            method definition.</returns>
      <remarks>
        <para>
            The canonical generic instance of a method is a generic instance where the n-th formal generic
            method argument is mapped to the n-th concrete generic method parameter. If the declaring type
            is a generic type definition, the canonical generic instance of the method is defined on
            the canonical generic instance of the declaring type (see <see cref="M:PostSharp.CodeModel.Helpers.GenericHelper.GetTypeCanonicalGenericInstance(PostSharp.CodeModel.TypeDefDeclaration,PostSharp.CodeModel.ModuleDeclaration)" />).
            </para>
        <para>
            For instance, the canonical 
            generic instance of the type MyType`3::MyMethod is MyType`3&lt;!0,!1,!2&gt;::MyMethod&lt;!0,!1&gt;.
            if MyMethod has two generic arguments.
            </para>
      </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.Helpers.GenericHelper.GetFieldCanonicalGenericInstance(PostSharp.CodeModel.FieldDefDeclaration)">
      <summary>
            Gets the canonical generic instance of a field. 
            </summary>
      <param name="field">field whose canonical generic instance is requested.</param>
      <returns>The canonical generic instance of <paramref name="field" />, or
            the unmodified <paramref name="field" /> if the declaring type of <paramref name="field" /> 
            is not a generic type definition.</returns>
      <remarks>
            The canonical generic instance of a field is the field defined on the canonical generic
            instance of the declaring type. For instance, the canonical 
            generic instance of the type MyType`3::myField is MyType`3&lt;!0,!1,!2&gt;::myField.
            </remarks>
    </member>
    <member name="T:PostSharp.CodeModel.Helpers.GenericParameterReferenceFinder">
      <summary>
            Provides a method that enumerates generic arguments (i.e. references to generic parameters)
            in type of method signatures.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.Helpers.GenericParameterReferenceFinder.GetGenericParameterReferenceEnumerator(PostSharp.Collections.IVisitable{PostSharp.CodeModel.ITypeSignature})">
      <summary>
            Enumerates generic arguments (i.e. references to generic parameters)
            in type of method signatures.
            </summary>
      <param name="visitable">The signature to traverse.</param>
      <returns>An enumerator over <see cref="T:PostSharp.CodeModel.TypeSignatures.GenericParameterTypeSignature" /> occurrences in <paramref name="visitable" />.</returns>
    </member>
    <member name="T:PostSharp.CodeModel.Helpers.TypeClassificationHelper">
      <summary>
            Helps to work with type classifications (<see cref="T:PostSharp.CodeModel.TypeClassifications" />).
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.Helpers.TypeClassificationHelper.BelongsToClassification(PostSharp.CodeModel.TypeClassifications,PostSharp.CodeModel.TypeClassifications)">
      <summary>
            Determines how two type classifications intersect.
            </summary>
      <param name="actualTypeClassification">Actual classification.</param>
      <param name="requestedTypeSpecification">Requested classification.</param>
      <returns>
        <see cref="F:PostSharp.NullableBool.True" /> if actual classifications are <i>included</i> in requested classification,
            <see cref="F:PostSharp.NullableBool.False" /> if both are <i>disjoint</i> and <see cref="F:PostSharp.NullableBool.Null" /> otherwise.</returns>
    </member>
    <member name="T:PostSharp.CodeModel.Helpers.VisibilityHelper">
      <summary>
            Provides methods that determines the visibility of classes, fields and methods.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.Helpers.VisibilityHelper.IsPublic(PostSharp.CodeModel.TypeDefDeclaration)">
      <summary>
            Determines whether a type is visible outside its assembly.
            </summary>
      <param name="typeDef">A type.</param>
      <returns>
        <b>true</b> if <paramref name="typeDef" /> is visible outside its
            assembly, otherwise <b>false</b>.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.Helpers.VisibilityHelper.IsPublic(PostSharp.CodeModel.FieldDefDeclaration)">
      <summary>
            Determines whether a field is visible outside its assembly.
            </summary>
      <param name="fieldDef">A field.</param>
      <returns>
        <b>true</b> if <paramref name="fieldDef" /> is visible outside its
            assembly, otherwise <b>false</b>.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.Helpers.VisibilityHelper.IsPublic(PostSharp.CodeModel.MethodDefDeclaration)">
      <summary>
            Determines whether a method is visible outside its assembly.
            </summary>
      <param name="methodDef">A method.</param>
      <returns>
        <b>true</b> if <paramref name="methodDef" /> is visible outside its
            assembly, otherwise <b>false</b>.</returns>
    </member>
    <member name="T:PostSharp.CodeModel.IAnnotationValue">
      <summary>
            Defines the semantics of a custom attribute value,
            i.e. basically a constructor, its arguments and other named arguments.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.IAnnotationValue.Translate(PostSharp.CodeModel.ModuleDeclaration)">
      <summary>
            Translates the current annotation so that it is valid in another module.
            </summary>
      <param name="module">The module into which the current <see cref="T:PostSharp.CodeModel.IAnnotationValue" />
            should be translated.</param>
      <returns>An <see cref="T:PostSharp.CodeModel.IAnnotationValue" /> valid in <paramref name="module" />.</returns>
    </member>
    <member name="P:PostSharp.CodeModel.IAnnotationValue.Constructor">
      <summary>
            Gets the custom attribute constructor.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.IAnnotationValue.NamedArguments">
      <summary>
            Gets the set of named arguments.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.IAnnotationValue.ConstructorArguments">
      <summary>
            Gets the set of constructor arguments.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.IAnnotationInstance">
      <summary>
            Exposes the fact that a custom attribute (<see cref="T:PostSharp.CodeModel.IAnnotationValue" />)
            is applied to an element (<see cref="T:PostSharp.CodeModel.MetadataDeclaration" />).
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.IAnnotationInstance.Value">
      <summary>
            Custom attribute value.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.IAnnotationInstance.TargetElement">
      <summary>
            Element on which the custom attribute value is applied.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.IGenericMethodDefinition">
      <summary>
            Declares the semantics of a generic method definition, i.e. a method
            that <i>may</i> have unbound generic parameter and method constructions
            (<see cref="T:PostSharp.CodeModel.MethodSpecDeclaration" />).
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.IMethod">
      <summary>
            Defines the functionalities that are common to all representations
            of a method (<see cref="T:PostSharp.CodeModel.MethodDefDeclaration" />, <see cref="T:PostSharp.CodeModel.MethodRefDeclaration" />,
            <see cref="T:PostSharp.CodeModel.MethodSpecDeclaration" />).
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.IMethodSignature">
      <summary>
            Exposes the semantics of a method signature.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.IMethodSignature.GetParameterType(System.Int32)">
      <summary>
            Gets the type of a parameter given its position.
            </summary>
      <param name="index">The parameter position.</param>
      <returns>The type (<see cref="T:PostSharp.CodeModel.TypeSignature" />) of the parameter.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.IMethodSignature.ReferencesAnyGenericArgument">
      <summary>
            Determines whether generic arguments are used in the current signature.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.IMethodSignature.MapGenericArguments(PostSharp.CodeModel.GenericMap)">
      <summary>
            Resolves all generic arguments in the current method signature.
            </summary>
      <param name="genericMap">Generic context in which generic arguments have to be resolved.</param>
      <returns>A method signature resolved against <paramref name="genericMap" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.IMethodSignature.Translate(PostSharp.CodeModel.ModuleDeclaration)">
      <summary>
            Translates the current method signature so that it is meaningful in another
            module than the one to which it primarly belong.
            </summary>
      <param name="targetModule">Module into which the type signature should be
            translated.</param>
      <returns>A method signature meaningful in the <paramref name="targetModule" />
            module.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.IMethodSignature.MatchesReference(PostSharp.CodeModel.IMethodSignature)">
      <summary>
            Determines whether the current method signature matches a given method signature reference.
            </summary>
      <param name="reference">The method signature reference.</param>
      <returns>
        <b>true</b> if the current method signature matches <paramref name="reference" />,
            otherwise <b>false</b>.</returns>
      <remarks>A method signature reference can use an incomplete assembly reference. Therefore, the matching
            is performed using <see cref="M:PostSharp.CodeModel.IAssembly.MatchesReference(PostSharp.CodeModel.IAssemblyName)" />.
            Matching an assembly reference is a looser requirement than matching an assembly name exactly;
            an assembly reference may set no requirement on the public key token or the version, for instance.</remarks>
    </member>
    <member name="P:PostSharp.CodeModel.IMethodSignature.CallingConvention">
      <summary>
            Gets the method calling convention.
            </summary>
      <value>
            The calling convention.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.IMethodSignature.ParameterCount">
      <summary>
            Gets the number of parameters.
            </summary>
      <value>
            The number of parameters.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.IMethodSignature.ReturnType">
      <summary>
            Gets the return type.
            </summary>
      <value>
            The return type.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.IMethodSignature.GenericParameterCount">
      <summary>
            Gets the number of generic parameters or arguments (i.e. the <i>arity</i>).
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.IGeneric">
      <summary>
            Exposes the common semantics to generic instances and generic definitions.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.IGeneric.GetGenericContext(PostSharp.CodeModel.GenericContextOptions)">
      <summary>
            Gets the generic context inside the scope of the generic instance.
            </summary>
      <returns>A <see cref="T:PostSharp.CodeModel.GenericMap" /> mapping ordinals either
            to <see cref="T:PostSharp.CodeModel.GenericParameterDeclaration" /> (in case of
            generic definition), either of the type signature associated
            to this ordinal (in the case of generic instance).</returns>
    </member>
    <member name="P:PostSharp.CodeModel.IGeneric.IsGenericDefinition">
      <summary>
            Determines whether the current instance is a generic definition, i.e. whether it can
            be used to construct generic instances.
            </summary>
      <remarks>
            If the current property returns <b>true</b>, the semantics of <see cref="T:PostSharp.CodeModel.IGenericDefinition" />
            are meaningfull for the current intance.
            </remarks>
    </member>
    <member name="P:PostSharp.CodeModel.IGeneric.IsGenericInstance">
      <summary>
            Determines whether the current instance is a generic instance, i.e. whether it has
            been constructed from a generic definition.
            </summary>
      <remarks>
            If the current property returns <b>true</b>, the semantics of <see cref="T:PostSharp.CodeModel.IGenericInstance" />
            are meaningfull for the current intance.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.IMethod.GetSystemMethod(System.Type[],System.Type[],PostSharp.CodeModel.BindingOptions)">
      <summary>
            Gets the system runtime method corresponding to the current method.
            </summary>
      <param name="genericTypeArguments">Array of generic type arguments valid in the current context.</param>
      <param name="genericMethodArguments">Array of generic method arguments valid in the current context.</param>
      <param name="bindingOptions">Binding options.</param>
      <returns>The system runtime <see cref="T:System.Reflection.MethodBase" />, or <b>null</b> if
            the current method could not be bound.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.IMethod.GetReflectionWrapper(System.Type[],System.Type[])">
      <summary>
            Gets a reflection <see cref="T:System.Reflection.MethodInfo" /> that wraps the current method.
            </summary>
      <param name="genericTypeArguments">Array of generic type arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <param name="genericMethodArguments">Array of generic method arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <returns>A <see cref="T:System.Reflection.MethodInfo" /> wrapping current method in the
            given generic context.</returns>
      <remarks>
            This method returns a <see cref="T:System.Reflection.MethodInfo" /> that is different from the system
            runtime method that is retrieved by <see cref="M:PostSharp.CodeModel.IMethod.GetSystemMethod(System.Type[],System.Type[],PostSharp.CodeModel.BindingOptions)" />. This allows
            a have a <b>System.Reflection</b> representation of the current method even
            when the declaring type it cannot be loaded in the Virtual Runtime Engine.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.IMethod.WriteReflectionMethodName(System.Text.StringBuilder,PostSharp.CodeModel.ReflectionNameOptions)">
      <summary>
            Writes to a <see cref="T:System.Text.StringBuilder" /> the full method signature as it would
            be output by <see cref="N:System.Reflection" />. It tries more specifically to produce
            the same result as <b>MethodBase.ToString()</b>.
            </summary>
      <param name="stringBuilder">The <see cref="T:System.Text.StringBuilder" /> to which the signature
            should be written.</param>
      <param name="options">Options.</param>
    </member>
    <member name="M:PostSharp.CodeModel.IMethod.GetMethodDefinition">
      <summary>
            Finds in the current domain the <see cref="T:PostSharp.CodeModel.MethodDefDeclaration" /> corresponding
            to the current method with default <see cref="T:PostSharp.CodeModel.BindingOptions" />.
            </summary>
      <returns>The <see cref="T:PostSharp.CodeModel.MethodDefDeclaration" /> corresponding to the current 
            instance in the current domain.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.IMethod.GetMethodDefinition(PostSharp.CodeModel.BindingOptions)">
      <summary>
            Finds in the current domain the <see cref="T:PostSharp.CodeModel.MethodDefDeclaration" /> corresponding
            to the current method and specifies <see cref="T:PostSharp.CodeModel.BindingOptions" />.
            </summary>
      <param name="bindingOptions">Binding options.</param>
      <returns>The <see cref="T:PostSharp.CodeModel.MethodDefDeclaration" /> corresponding to the current 
            instance in the current domain.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.IMethod.MatchesReference(PostSharp.CodeModel.IMethod)">
      <summary>
            Determines whether the current method matches a given method reference.
            </summary>
      <param name="reference">The method reference.</param>
      <returns>
        <b>true</b> if the current method matches <paramref name="reference" />,
            otherwise <b>false</b>.</returns>
      <remarks>A method reference can use an incomplete assembly reference. Therefore, the matching
            is performed using <see cref="M:PostSharp.CodeModel.IAssembly.MatchesReference(PostSharp.CodeModel.IAssemblyName)" />.
            Matching an assembly reference is a looser requirement than matching an assembly name exactly;
            an assembly reference may set no requirement on the public key token or the version, for instance.</remarks>
    </member>
    <member name="P:PostSharp.CodeModel.IMethod.Attributes">
      <summary>
            Gets the attributes of the method.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.IMethod.Visibility">
      <summary>
            Gets the visibility of the current method.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.IMethod.IsVirtual">
      <summary>
            Determines whether the method is virtual.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.IMethod.IsAbstract">
      <summary>
            Determines whether the method is abstract.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.IMethod.IsSealed">
      <summary>
            Determines whether the method is sealed.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.IMethod.IsNew">
      <summary>
            Determines whether the method takes a new slot.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.IGenericDefinition">
      <summary>
            Exposes the semantics of a generic definition (i.e. a type 
            or method having (unbound) generic parameters). Classes implementing
            <see cref="T:PostSharp.CodeModel.IGenericDefinition" /> can also represent references to generic definitions.
            </summary>
      <remarks>
            The fact that an object can be casted to <see cref="T:PostSharp.CodeModel.IGenericDefinition" /> does not
            automatically mean that it is actually a generic definition. It is always necessary
            to check the <see cref="P:PostSharp.CodeModel.IGeneric.IsGenericDefinition" /> property.
            </remarks>
      <see cref="T:PostSharp.CodeModel.IGenericDefinitionDefinition" />
    </member>
    <member name="M:PostSharp.CodeModel.IGenericDefinition.GetGenericParameter(System.Int32)">
      <summary>
            Gets a generic (formal, unbound) parameter given its ordinal.
            </summary>
      <param name="ordinal">The generic parameter ordinal (position).</param>
      <returns>A <see cref="T:PostSharp.CodeModel.GenericParameterDeclaration" />, or <b>null</b>
            if the current generic parameter does not exist.</returns>
      <remarks>If the current instance is a defined in the current module
            (<see cref="T:PostSharp.CodeModel.MethodDefDeclaration" />, <see cref="T:PostSharp.CodeModel.TypeDefDeclaration" />),
            this method returns a <see cref="T:PostSharp.CodeModel.GenericParameterDeclaration" />.
            Otherwise, it returns a reference to a generic parameter, i.e.
            a <see cref="T:PostSharp.CodeModel.TypeSignatures.GenericParameterTypeSignature" />.</remarks>
    </member>
    <member name="P:PostSharp.CodeModel.IGenericDefinition.GenericParameterCount">
      <summary>
            Gets the number of (formal, unbound) generic parameters.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.IGenericMethodDefinition.FindGenericInstance(System.Collections.Generic.IList{PostSharp.CodeModel.ITypeSignature},PostSharp.CodeModel.BindingOptions)">
      <summary>
            Finds or construct a specific generic instance of the current generic method definition.
            </summary>
      <param name="genericArguments">Generic arguments.</param>
      <param name="bindingOptions">Binding options.</param>
      <returns>The generic instance, or <b>null</b> if it was not found and was not
            requested to be created.</returns>
    </member>
    <member name="P:PostSharp.CodeModel.IGenericMethodDefinition.MethodSpecs">
      <summary>
            Gets the collection of method specifications (<see cref="T:PostSharp.CodeModel.MethodSpecDeclaration" />).
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.InterfaceImplementationDeclaration">
      <summary>
            Represents an interface implementation (<see cref="F:PostSharp.CodeModel.TokenType.InterfaceImpl" />) of a <see cref="T:PostSharp.CodeModel.TypeDefDeclaration" />.
            </summary>
      <remarks>
            Interface implementations are owned by type definitions (<see cref="T:PostSharp.CodeModel.TypeDefDeclaration" />).
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.InterfaceImplementationDeclaration.GetTokenType">
      <summary>
            Gets the metadata token type of the current declaration.
            </summary>
      <returns>A <see cref="T:PostSharp.CodeModel.TokenType" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.InterfaceImplementationDeclaration.Remove">
      <summary>
            Remove the current declaration from its parent.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.InterfaceImplementationDeclaration.ImplementedInterface">
      <summary>
            Gets or sets the implemented interface.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.Collections.InterfaceImplementationDeclarationCollection">
      <summary>
            Collection of <see cref="T:PostSharp.CodeModel.InterfaceImplementationDeclaration" />.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.InterfaceImplementationDeclarationCollection.Add(PostSharp.CodeModel.ITypeSignature)">
      <summary>
            Adds a new interface implementation to the current collection by only specifying the
            interfafce type.
            </summary>
      <param name="type">Interface type.</param>
      <returns>The <see cref="T:PostSharp.CodeModel.InterfaceImplementationDeclaration" /> that has been created
            to encapsulate <paramref name="type" />.</returns>
    </member>
    <member name="T:PostSharp.CodeModel.MethodImplementationDeclaration">
      <summary>
            Represents a method implementation (<see cref="F:PostSharp.CodeModel.TokenType.MethodImpl" />), i.e. an indication of
            the interface method being implemented by the current <see cref="T:PostSharp.CodeModel.MethodDefDeclaration" />.
            </summary>
      <remarks>
            Method implementations are owned by method definitions (<see cref="T:PostSharp.CodeModel.MethodDefDeclaration" />).
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.MethodImplementationDeclaration.GetTokenType" />
    <member name="P:PostSharp.CodeModel.MethodImplementationDeclaration.ImplementedMethod">
      <summary>
            Gets or sets the implemented method (an interface method).
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.Collections.MethodImplementationDeclarationCollection">
      <summary>
            Collection of <see cref="T:PostSharp.CodeModel.MethodImplementationDeclaration" />.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.MethodImplementationDeclarationCollection.Add(PostSharp.CodeModel.IMethod)">
      <summary>
            Adds a new method implementation to the current collection by specifying only the method.
            </summary>
      <param name="method">The implemented method.</param>
      <returns>The <see cref="T:PostSharp.CodeModel.MethodImplementationDeclaration" /> that has been created to
            encapsulate <paramref name="method" /> and added to the current collection.</returns>
    </member>
    <member name="T:PostSharp.Collections.IPositioned">
      <summary>
            Exposes the <see cref="P:PostSharp.Collections.IPositioned.Ordinal" /> property.
            </summary>
    </member>
    <member name="P:PostSharp.Collections.IPositioned.Ordinal">
      <summary>
            Position of the current item in its parent collection.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.IMemberRefResolutionScope">
      <summary>
            Defines semantics of all classes declaring external fields or methods.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.IMemberRefResolutionScope.FieldRefs">
      <summary>
            Gets the collection of fields (<see cref="T:PostSharp.CodeModel.FieldRefDeclaration" />) 
            defined on the current object.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.IMemberRefResolutionScope.MethodRefs">
      <summary>
            Gets the collection of methods (<see cref="T:PostSharp.CodeModel.MethodRefDeclaration" />)
            defined on the current object.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.Instruction">
      <summary>
            Gives read-only access to the current instruction of an <see cref="T:PostSharp.CodeModel.InstructionReader" />.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.Instruction.GetSwitchTargetsOperand">
      <exception cref="T:System.InvalidOperationException">
            	The current instruction has a different operand type.
            </exception>
    </member>
    <member name="M:PostSharp.CodeModel.Instruction.GetSwitchOperandTarget(System.Int32)">
      <summary>
            Gets a target of a <b>switch</b> operand given its index.
            </summary>
      <param name="index">Index of the required target.</param>
      <returns>
            The target <see cref="T:System.InvalidOperationException" /> whose position
            in the <b>switch</b> statement is <paramref name="index" />.
            </returns>
      <exception cref="T:System.InvalidOperationException">
            	The current instruction has a different operand type.
            </exception>
    </member>
    <member name="M:PostSharp.CodeModel.Instruction.GetOperand">
      <summary>
            Gets the typed (and eventually boxed) operand.
            </summary>
      <returns>The typed operand of the current instruction, 
            or <b>null</b> if the current instruction has no operand.
            </returns>
    </member>
    <member name="M:PostSharp.CodeModel.Instruction.GetParameter(System.Int32)">
      <summary>
            Gets a <see cref="T:PostSharp.CodeModel.ParameterDeclaration" /> given the index of the <b>ldarg</b>
            intruction.
            </summary>
      <param name="index">Parameter index. 0-based in static methods, 1-based
            in instant methods</param>
      <returns>The <see cref="T:PostSharp.CodeModel.ParameterDeclaration" /> corresponding to <paramref name="index" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.Instruction.GetLocalVariableSymbol(System.Int32)">
      <summary>
            Gets the <see cref="T:PostSharp.CodeModel.LocalVariableSymbol" /> corresponding to a given ordinal
            in the current context.
            </summary>
      <param name="ordinal">Ordinal.</param>
      <returns>The <see cref="T:PostSharp.CodeModel.LocalVariableSymbol" /> corresponding to <paramref name="ordinal" />
            in the current context.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.Instruction.Write(PostSharp.ModuleWriter.InstructionEmitter)">
      <summary>
            Writes the current <see cref="T:PostSharp.CodeModel.Instruction" /> an an <see cref="T:PostSharp.ModuleWriter.InstructionEmitter" />.
            </summary>
      <param name="writer">An <see cref="T:PostSharp.ModuleWriter.InstructionEmitter" />.</param>
    </member>
    <member name="M:PostSharp.CodeModel.Instruction.ToString" />
    <member name="P:PostSharp.CodeModel.Instruction.MethodBody">
      <summary>
            Gets the <see cref="T:PostSharp.CodeModel.MethodBodyDeclaration" /> to which the current instruction
            belong.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.Instruction.Module">
      <summary>
            Gets the <see cref="T:PostSharp.CodeModel.ModuleDeclaration" /> to which the current instruction
            belong.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.Instruction.InstructionPrefixes">
      <summary>
            Gets the combination of prefixes modifying the current instruction.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.Instruction.UnalignedPrefix">
      <summary>
            Gets the value of the <b>unaligned</b> prefix.
            </summary>
      <value>
            The value <b>1</b>, <b>2</b> or <b>4</b> if there is an <b>unaligned</b>
            prefix for the current instruction, otherwise <b>0</b>.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.Instruction.OperandType">
      <summary>
            Gets the <see cref="P:PostSharp.CodeModel.Instruction.OperandType" /> of the current instruction.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.Instruction.OpCodeNumber">
      <summary>
            Gets the <see cref="P:PostSharp.CodeModel.Instruction.OpCodeNumber" /> of the current instruction.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.Instruction.ByteOperand">
      <summary>
            Gets the <see cref="T:System.Byte" /> operand of the current instruction.
            </summary>
      <exception cref="T:System.InvalidOperationException">
            	The current instruction has a different operand type.
            </exception>
    </member>
    <member name="P:PostSharp.CodeModel.Instruction.Int16Operand">
      <summary>
            Gets the <see cref="T:System.Int16" /> operand of the current instruction.
            </summary>
      <exception cref="T:System.InvalidOperationException">
            	The current instruction has a different operand type.
            </exception>
    </member>
    <member name="P:PostSharp.CodeModel.Instruction.Int32Operand">
      <summary>
            Gets the <see cref="T:System.Int32" /> operand of the current instruction.
            </summary>
      <exception cref="T:System.InvalidOperationException">
            	The current instruction has a different operand type.
            </exception>
    </member>
    <member name="P:PostSharp.CodeModel.Instruction.DeclarationOperand">
      <summary>
            Gets the <see cref="T:PostSharp.CodeModel.MetadataDeclaration" /> operand for the current instruction.
            </summary>
      <exception cref="T:System.InvalidOperationException">
            	The current instruction has a different operand type.
            </exception>
    </member>
    <member name="P:PostSharp.CodeModel.Instruction.Int64Operand">
      <summary>
            Gets the <see cref="T:System.Int64" /> operand of the current instruction.
            </summary>
      <exception cref="T:System.InvalidOperationException">
            	The current instruction has a different operand type.
            </exception>
    </member>
    <member name="P:PostSharp.CodeModel.Instruction.SingleOperand">
      <summary>
            Gets the <see cref="T:System.Single" /> operand of the current instruction.
            </summary>
      <exception cref="T:System.InvalidOperationException">
            	The current instruction has a different operand type.
            </exception>
    </member>
    <member name="P:PostSharp.CodeModel.Instruction.DoubleOperand">
      <summary>
            Gets the <see cref="T:System.Double" /> operand of the current instruction.
            </summary>
      <exception cref="T:System.InvalidOperationException">
            	The current instruction has a different operand type.
            </exception>
    </member>
    <member name="P:PostSharp.CodeModel.Instruction.BranchTargetOperand">
      <summary>
            Gets the <see cref="T:PostSharp.CodeModel.InstructionSequence" /> operand of the current instruction.
            </summary>
      <exception cref="T:System.InvalidOperationException">
            	The current instruction has a different operand type.
            </exception>
    </member>
    <member name="P:PostSharp.CodeModel.Instruction.ParameterOperand">
      <summary>
            Gets the <see cref="T:PostSharp.CodeModel.ParameterDeclaration" /> operand of the current instruction.
            </summary>
      <exception cref="T:System.InvalidOperationException">
            	The current instruction has a different operand type.
            </exception>
    </member>
    <member name="P:PostSharp.CodeModel.Instruction.LocalVariableOperand">
      <summary>
            Gets the <see cref="T:PostSharp.CodeModel.LocalVariableSymbol" /> operand of the current instruction.
            </summary>
      <exception cref="T:System.InvalidOperationException">
            	The current instruction has a different operand type.
            </exception>
    </member>
    <member name="P:PostSharp.CodeModel.Instruction.TypeOperand">
      <summary>
            Gets the <see cref="T:PostSharp.CodeModel.IType" /> operand of the current instruction.
            </summary>
      <exception cref="T:System.InvalidOperationException">
            	The current instruction has a different operand type.
            </exception>
    </member>
    <member name="P:PostSharp.CodeModel.Instruction.MethodOperand">
      <summary>
            Gets the <see cref="T:PostSharp.CodeModel.IMethod" /> operand of the current instruction.
            </summary>
      <exception cref="T:System.InvalidOperationException">
            	The current instruction has a different operand type.
            </exception>
    </member>
    <member name="P:PostSharp.CodeModel.Instruction.FieldOperand">
      <summary>
            Gets the <see cref="T:PostSharp.CodeModel.IField" /> operand of the current instruction.
            </summary>
      <exception cref="T:System.InvalidOperationException">
            	The current instruction has a different operand type.
            </exception>
    </member>
    <member name="P:PostSharp.CodeModel.Instruction.StringOperand">
      <summary>
            Gets the <see cref="P:PostSharp.CodeModel.Instruction.StringOperand" /> operand of the current instruction.
            </summary>
      <exception cref="T:System.InvalidOperationException">
            	The current instruction has a different operand type.
            </exception>
    </member>
    <member name="P:PostSharp.CodeModel.Instruction.MemberRefOperand">
      <summary>
            Gets the <see cref="T:PostSharp.CodeModel.MemberRefDeclaration" /> operand of the current instruction.
            </summary>
      <exception cref="T:System.InvalidOperationException">
            	The current instruction has a different operand type.
            </exception>
    </member>
    <member name="P:PostSharp.CodeModel.Instruction.SwitchOperandTargetCount">
      <summary>
            Gets the number of targets in the <b>switch</b> operand.
            </summary>
      <exception cref="T:System.InvalidOperationException">
            	The current instruction has a different operand type.
            </exception>
    </member>
    <member name="P:PostSharp.CodeModel.Instruction.SignatureOperand">
      <summary>
            Gets the <see cref="P:PostSharp.CodeModel.Instruction.StringOperand" /> operand of the current instruction.
            </summary>
      <exception cref="T:System.InvalidOperationException">
            	The current instruction has a different operand type.
            </exception>
    </member>
    <member name="P:PostSharp.CodeModel.Instruction.ConstrainedType">
      <summary>
            Gets the operand of the <b>constrained</b> prefix of the current instruction.
            </summary>
      <exception cref="T:System.InvalidOperationException">
            	The current instruction has no 
            	<see cref="F:PostSharp.CodeModel.InstructionPrefixes.Constrained" />
            	prefix.
            </exception>
    </member>
    <member name="P:PostSharp.CodeModel.Instruction.HasSymbolSequencePoint">
      <summary>
            Determines whether there is a <see cref="P:PostSharp.CodeModel.Instruction.SymbolSequencePoint" /> before the current instruction.
            </summary>
      <value>
        <b>true</b> if there is a <see cref="P:PostSharp.CodeModel.Instruction.SymbolSequencePoint" /> before the current instruction,
            otherwise <b>false</b>.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.Instruction.SymbolSequencePoint">
      <summary>
            Gets the <see cref="P:PostSharp.CodeModel.Instruction.SymbolSequencePoint" /> before the current instruction.
            </summary>
      <value>
            A <see cref="P:PostSharp.CodeModel.Instruction.SymbolSequencePoint" />, or a null <see cref="P:PostSharp.CodeModel.Instruction.SymbolSequencePoint" />
            if there is no symbol sequence point at the current instruction.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.Instruction.LastSymbolSequencePoint">
      <summary>
            Gets the last symbol sequence point, which covers the current
            instruction.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.InstructionReaderBookmark">
      <summary>
            Bookmark for the <see cref="T:PostSharp.CodeModel.InstructionReader" /> class.
            </summary>
      <seealso cref="M:PostSharp.CodeModel.InstructionReader.CreateBookmark" />
      <seealso cref="M:PostSharp.CodeModel.InstructionReader.GoToBookmark(PostSharp.CodeModel.InstructionReaderBookmark)" />
    </member>
    <member name="T:PostSharp.CodeModel.ISecurable">
      <summary>
            Defines semantics of declarations that can be secured by
            permission sets
            (<see cref="T:PostSharp.CodeModel.TypeDefDeclaration" />, <see cref="T:PostSharp.CodeModel.MethodDefDeclaration" />,
            <see cref="T:PostSharp.CodeModel.AssemblyManifestDeclaration" />).
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.ISecurable.PermissionSets">
      <summary>
            Gets the collection of permission sets (<see cref="T:PostSharp.CodeModel.PermissionSetDeclaration" />).
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.IType">
      <summary>
            Defines the semantics of a type.
            </summary>
      <remarks>
            A type has all the semantics of a type signature (<see cref="T:PostSharp.CodeModel.ITypeSignature" />) and exposes additionally
            methods and fields.
            </remarks>
    </member>
    <member name="T:PostSharp.CodeModel.ITypeSignature">
      <summary>
            Defines the functionalities that are common to all representations
            of a type (<see cref="T:PostSharp.CodeModel.TypeDefDeclaration" />, <see cref="T:PostSharp.CodeModel.TypeRefDeclaration" />,
            <see cref="T:PostSharp.CodeModel.TypeSpecDeclaration" />, <see cref="T:PostSharp.CodeModel.TypeSignature" />).
            </summary>
    </member>
    <member name="T:PostSharp.Collections.IVisitable`1">
      <summary>
            Defines the semantics of an object that can be <i>visited</i>.
            </summary>
      <typeparam name="T">Type of items that should be visited.</typeparam>
    </member>
    <member name="M:PostSharp.Collections.IVisitable`1.Visit(System.String,PostSharp.Collections.Visitor{`0})">
      <summary>
            Requires a callback method (named <i>visitor</i>) to be called
            for each item of a given role in the current object, recursively.
            </summary>
      <param name="role">Role of items to be visited, or <b>null</b> if all items
            of type <typeparamref name="T" /> should be visited.</param>
      <param name="visitor">Delegate that should be called when an
            item in the given role is found.</param>
    </member>
    <member name="M:PostSharp.CodeModel.ITypeSignature.BelongsToClassification(PostSharp.CodeModel.TypeClassifications)">
      <summary>
            Determines whether the type signature belongs to a given classification,
            i.e. whether it fulfills a given predicate.
            </summary>
      <param name="typeClassification">The classification (or predicate) 
            (combination of bits are not allowed).</param>
      <returns>
        <see cref="F:PostSharp.NullableBool.True" /> if the predicate is true, 
            <see cref="F:PostSharp.NullableBool.False" /> if the predicate is false or
            <see cref="F:PostSharp.NullableBool.Null" /> if it cannot be determined. </returns>
    </member>
    <member name="M:PostSharp.CodeModel.ITypeSignature.GetValueSize(PostSharp.CodeModel.PlatformInfo)">
      <summary>
            Gets the size of the value type.
            </summary>
      <param name="platform">Information about the target platform.</param>
      <returns>The size of the value type in bytes, or -1 if the
            type is not a value type or has no fixed size.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.ITypeSignature.GetSystemType(System.Type[],System.Type[])">
      <summary>
            Gets the system, runtime <see cref="T:System.Type" /> corresponding to the current type.
            </summary>
      <param name="genericTypeArguments">Array of generic type arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <param name="genericMethodArguments">Array of generic method arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <returns>The system <see cref="T:System.Type" /> associated the current type in the
            given generic context.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.ITypeSignature.GetReflectionWrapper(System.Type[],System.Type[])">
      <summary>
            Gets a reflection <see cref="T:System.Type" /> that wraps the current type.
            </summary>
      <param name="genericTypeArguments">Array of generic type arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <param name="genericMethodArguments">Array of generic method arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <returns>A <see cref="T:System.Type" /> wrapping current type in the
            given generic context.</returns>
      <remarks>
            This method returns a <see cref="T:System.Type" /> that is different from the system
            runtime type that is retrieved by <see cref="M:PostSharp.CodeModel.ITypeSignature.GetSystemType(System.Type[],System.Type[])" />. This allows
            a have a <b>System.Reflection</b> representation of the current type even
            when it cannot be loaded in the Virtual Runtime Engine.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.ITypeSignature.WriteReflectionTypeName(System.Text.StringBuilder,PostSharp.CodeModel.ReflectionNameOptions)">
      <summary>
            Gets the type name as used in <b>System.Reflection</b>.
            </summary>
      <returns>A <see cref="T:System.String" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.ITypeSignature.ContainsGenericArguments">
      <summary>
            Determines whether the type signature contains a generic argument.
            </summary>
      <returns>
        <b>true</b> if the type signature contains a generic argument, otherwise <b>false</b>.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.ITypeSignature.MapGenericArguments(PostSharp.CodeModel.GenericMap)">
      <summary>
            Resolves all generic arguments in the current type signature.
            </summary>
      <param name="genericMap">Generic context in which generic arguments have to be resolved.</param>
      <returns>A <see cref="T:PostSharp.CodeModel.IType" /> resolved against <paramref name="genericMap" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.ITypeSignature.GetNakedType(PostSharp.CodeModel.TypeNakingOptions)">
      <summary>
            Returns the meaningful type. Removes specified modifiers
            and resolves type references.
            </summary>
      <param name="options">Specifies what has to be ignored.</param>
      <returns>A 'naked' <see cref="T:PostSharp.CodeModel.IType" />.</returns>
      <remarks>This method only removes the modifiers on the current object,
            all of the nodes of a type signature. However, the object returned by 
            this method (i.e. the head of the chain) is guaranteed to be
            free from modifiers specified in <paramref name="options" />.</remarks>
    </member>
    <member name="M:PostSharp.CodeModel.ITypeSignature.Translate(PostSharp.CodeModel.ModuleDeclaration)">
      <summary>
            Translates the current type signature so that it is meaningful in another
            module than the one to which it primarly belong.
            </summary>
      <param name="targetModule">Module into which the type signature should be
            translated.</param>
      <returns>A type signature meaningful in the <paramref name="targetModule" />
            module.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.ITypeSignature.GetTypeDefinition">
      <summary>
            Finds in the current domain the <see cref="T:PostSharp.CodeModel.TypeDefDeclaration" /> corresponding
            to the current type and uses default <see cref="T:PostSharp.CodeModel.BindingOptions" />.
            </summary>
      <returns>The <see cref="T:PostSharp.CodeModel.TypeDefDeclaration" /> corresponding to the current 
            instance in the current domain.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.ITypeSignature.GetTypeDefinition(PostSharp.CodeModel.BindingOptions)">
      <summary>
            Finds in the current domain the <see cref="T:PostSharp.CodeModel.TypeDefDeclaration" /> corresponding
            to the current type and specifies <see cref="T:PostSharp.CodeModel.BindingOptions" />.
            </summary>
      <param name="bindingOptions">Binding options.</param>
      <returns>The <see cref="T:PostSharp.CodeModel.TypeDefDeclaration" /> corresponding to the current 
            instance in the current domain.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.ITypeSignature.MatchesReference(PostSharp.CodeModel.ITypeSignature)">
      <summary>
            Determines whether the current type signature matches a given type signature.
            </summary>
      <param name="reference">The type reference.</param>
      <returns>
        <b>true</b> if the current type signature matches <paramref name="reference" />,
            otherwise <b>false</b>.</returns>
      <remarks>A type reference can use an incomplete assembly reference. Therefore, the matching
            is performed using <see cref="M:PostSharp.CodeModel.IAssembly.MatchesReference(PostSharp.CodeModel.IAssemblyName)" />.
            Matching an assembly reference is a looser requirement than matching an assembly name exactly;
            an assembly reference may set no requirement on the public key token or the version, for instance.</remarks>
    </member>
    <member name="M:PostSharp.CodeModel.ITypeSignature.IsAssignableTo(PostSharp.CodeModel.ITypeSignature,PostSharp.CodeModel.GenericMap)">
      <summary>
            Determines whether instances of the current type is assignable to
            locations of a specified type (i.e. whether the current type derives
            or implements this type) and specifies a <see cref="T:PostSharp.CodeModel.GenericMap" />.
            </summary>
      <param name="type">The type that the current type may derive or inherit.</param>
      <param name="genericMap">Map that has to be applied on generic arguments of <paramref name="type" />
            before the comparison is performed. It is generally wrong to pass an empty generic map (like <see cref="F:PostSharp.CodeModel.GenericMap.Empty" />).
            The identical generic map should be passed instrad.</param>
      <returns>
        <b>true</b> if the current type can be assigned to (i.e., derives or implements) <paramref name="type" />,
            otherwise <b>false</b>.</returns>
      <remarks>There are some exceptions to the rule that a type can be assigned to another if it derives
            or implements it. For instance, an <see cref="T:System.Int32" /> is assignable to an <see cref="T:System.UInt32" />.</remarks>
    </member>
    <member name="M:PostSharp.CodeModel.ITypeSignature.IsAssignableTo(PostSharp.CodeModel.ITypeSignature)">
      <summary>
            Determines whether instances of the current type is assignable to
            locations of a specified type (i.e. whether the current type derives
            or implements this type).
            </summary>
      <param name="type">The type that the current type may derive or inherit.</param>
      <returns>
        <b>true</b> if the current type can be assigned to (i.e., derives or implements) <paramref name="type" />,
            otherwise <b>false</b>.</returns>
      <remarks>There are some exceptions to the rule that a type can be assigned to another if it derives
            or implements it. For instance, an <see cref="T:System.Int32" /> is assignable to an <see cref="T:System.UInt32" />.</remarks>
    </member>
    <member name="M:PostSharp.CodeModel.ITypeSignature.GetCanonicalHashCode">
      <summary>
            Gets a hash code that is invariant under type signature equality
            (i.e. if two types are equal under <see cref="T:System.IEquatable`1" />, they have the
            same canonical has code).
            </summary>
      <returns>A hash code that is invariant under type signature equality.</returns>
      <remarks>This method is of course useful to build dictionaries. The <see cref="T:PostSharp.CodeModel.Binding.TypeComparer" /> class
            uses this method.</remarks>
    </member>
    <member name="P:PostSharp.CodeModel.IType.DeclaringType">
      <summary>
            Gets the declaring type (i.e. the type in which the current type
            is nested), or <b>null</b> if the current type is not nested.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.IType.Methods">
      <summary>
            Gets the collection of methods.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.IType.Fields">
      <summary>
            Gets the collection of fields.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.IType.Attributes">
      <summary>
            Gets or sets the type attributes.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.IType.IsSealed">
      <summary>
            Determines whether the type is sealed.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.IType.IsInterface">
      <summary>
            Determines whether the type is an interface.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.IType.IsAbstract">
      <summary>
            Determines whether the class is abstract.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.INamedType">
      <summary>
            Defines the semantics of a type (<see cref="T:PostSharp.CodeModel.IType" />) that can be named.
            </summary>
      <remarks>The only named types are <see cref="T:PostSharp.CodeModel.TypeDefDeclaration" />
            and <see cref="T:PostSharp.CodeModel.TypeRefDeclaration" />.
            </remarks>
    </member>
    <member name="P:PostSharp.CodeModel.INamedType.NestedTypes">
      <summary>
            Gets the collection of types nested in the current type.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.Collections.INamedTypeCollection">
      <summary>
            Semantics of collections of types as required by <see cref="T:PostSharp.CodeModel.IType" />.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.INamedTypeCollection.GetByName(System.String)" />
    <member name="T:PostSharp.CodeModel.Collections.IMethodCollection">
      <summary>
            Semantics of collections of methods as required by <see cref="T:PostSharp.CodeModel.IType" />.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.IMethodCollection.GetMethod(System.String,PostSharp.CodeModel.IMethodSignature,PostSharp.CodeModel.BindingOptions)">
      <summary>
            Finds a method in the type given its name and signature.
            </summary>
      <param name="name">Method name.</param>
      <param name="signature">Method signature.</param>
      <param name="bindingOptions">Determines the behavior in case the method is not
            found.</param>
      <returns>The method, or <b>null</b> if the method could not be found.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.IMethodCollection.GetByName(System.String)">
      <summary>
            Gets a set of methods given their name.
            </summary>
      <param name="name">Method name.</param>
      <returns>The set of methods named <paramref name="name" />.</returns>
    </member>
    <member name="T:PostSharp.CodeModel.ITypeContainer">
      <summary>
            Exposes the semantics of a declaration that can contain type definitions
            (<see cref="T:PostSharp.CodeModel.ModuleDeclaration" /> or <see cref="T:PostSharp.CodeModel.TypeDefDeclaration" />).
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.ITypeContainer.Types">
      <summary>
            Gets the collection of types.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.ITypeRefResolutionScope">
      <summary>
            Defines semantics of <see cref="T:PostSharp.CodeModel.TypeRefDeclaration" /> resolution scopes
            (<see cref="T:PostSharp.CodeModel.TypeRefDeclaration" />, <see cref="T:PostSharp.CodeModel.AssemblyRefDeclaration" />,
            <see cref="T:PostSharp.CodeModel.ModuleDeclaration" />).
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.ITypeRefResolutionScope.TypeRefs">
      <summary>
            Gets the collection of type references (<see cref="T:PostSharp.CodeModel.TypeRefDeclaration" />)
            whose resolution scope is the current declaration.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.IWeakReferenceable">
      <summary>
            Defines the semantics of declarations (<see cref="T:PostSharp.CodeModel.TypeRefDeclaration" />
            and <see cref="T:PostSharp.CodeModel.AssemblyRefDeclaration" />) that can be "weakly references".
            </summary>
      <remarks>
        <para>
            Serialized constructions (custom attributes and permission set) may reference a
            type using its fully qualified name instead of an entry in a metadata table.
            In PostSharp, these "weak references" are not implemented by strings
            but by references to pseudo-metadata declarations. They are metadata declarations
            that are marked to have no "strong" reference. 
            </para>
        <para>
            Metadata declarations with "strong" references are called <i>linked</i>
            and other non-linked.
            </para>
      </remarks>
    </member>
    <member name="P:PostSharp.CodeModel.IWeakReferenceable.IsWeaklyReferenced">
      <summary>
            Determines whether the current declaration is weakly or strongly
            referenced in the current module.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.MethodDefDeclaration">
      <summary>
            Represents a method definition (<see cref="F:PostSharp.CodeModel.TokenType.MethodDef" />).
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.IGenericDefinitionDefinition">
      <summary>
            Exposes the semantics of a generic definition but, unlike <see cref="T:PostSharp.CodeModel.IGenericDefinition" />,
            are a real definition and not a reference.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.IGenericDefinitionDefinition.GenericParameters">
      <summary>
            Gets the collection of generic parameters.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.MethodDefDeclaration.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.MethodDefDeclaration" />.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.MethodDefDeclaration.GetTokenType">
      <summary>
            Gets the metadata token type of the current declaration.
            </summary>
      <returns>A <see cref="T:PostSharp.CodeModel.TokenType" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.MethodDefDeclaration.GetParentDefinition">
      <summary>
            When the current method overrides a method in a parent type, returns
            the overriden method.
            </summary>
      <returns>The overridden method, or <b>null</b>if the current method
            does not override any method.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.MethodDefDeclaration.Equals(PostSharp.CodeModel.IMethodSignature)" />
    <member name="M:PostSharp.CodeModel.MethodDefDeclaration.Equals(PostSharp.CodeModel.IMethod)" />
    <member name="M:PostSharp.CodeModel.MethodDefDeclaration.MatchesReference(PostSharp.CodeModel.IMethod)" />
    <member name="M:PostSharp.CodeModel.MethodDefDeclaration.MatchesReference(PostSharp.CodeModel.IMethodSignature)">
      <summary>
            Determines whether the current method signature matches a given method signature reference.
            </summary>
      <param name="reference">The method signature reference.</param>
      <returns>
        <b>true</b> if the current method signature matches <paramref name="reference" />,
            otherwise <b>false</b>.</returns>
      <remarks>A method signature reference can use an incomplete assembly reference. Therefore, the matching
            is performed using <see cref="M:PostSharp.CodeModel.IAssembly.MatchesReference(PostSharp.CodeModel.IAssemblyName)" />.
            Matching an assembly reference is a looser requirement than matching an assembly name exactly;
            an assembly reference may set no requirement on the public key token or the version, for instance.</remarks>
    </member>
    <member name="M:PostSharp.CodeModel.MethodDefDeclaration.ToString" />
    <member name="M:PostSharp.CodeModel.MethodDefDeclaration.GetReflectionWrapper(System.Type[],System.Type[])">
      <summary>
            Gets a reflection <see cref="T:System.Reflection.MethodInfo" /> that wraps the current method.
            </summary>
      <param name="genericTypeArguments">Array of generic type arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <param name="genericMethodArguments">Array of generic method arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <returns>A <see cref="T:System.Reflection.MethodInfo" /> wrapping current method in the
            given generic context.</returns>
      <remarks>
            This method returns a <see cref="T:System.Reflection.MethodInfo" /> that is different from the system
            runtime method that is retrieved by <see cref="M:PostSharp.CodeModel.IMethod.GetSystemMethod(System.Type[],System.Type[],PostSharp.CodeModel.BindingOptions)" />. This allows
            a have a <b>System.Reflection</b> representation of the current method even
            when the declaring type it cannot be loaded in the Virtual Runtime Engine.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.MethodDefDeclaration.WriteReflectionMethodName(System.Text.StringBuilder,PostSharp.CodeModel.ReflectionNameOptions)">
      <summary>
            Writes to a <see cref="T:System.Text.StringBuilder" /> the full method signature as it would
            be output by <see cref="N:System.Reflection" />. It tries more specifically to produce
            the same result as <b>MethodBase.ToString()</b>.
            </summary>
      <param name="stringBuilder">The <see cref="T:System.Text.StringBuilder" /> to which the signature
            should be written.</param>
      <param name="options">Options.</param>
    </member>
    <member name="M:PostSharp.CodeModel.MethodDefDeclaration.GetSystemMethod(System.Type[],System.Type[],PostSharp.CodeModel.BindingOptions)">
      <summary>
            Gets the system runtime method corresponding to the current method.
            </summary>
      <param name="genericTypeArguments">Array of generic type arguments valid in the current context.</param>
      <param name="genericMethodArguments">Array of generic method arguments valid in the current context.</param>
      <param name="bindingOptions">Binding options.</param>
      <returns>The system runtime <see cref="T:System.Reflection.MethodBase" />, or <b>null</b> if
            the current method could not be bound.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.MethodDefDeclaration.FindGenericInstance(System.Collections.Generic.IList{PostSharp.CodeModel.ITypeSignature},PostSharp.CodeModel.BindingOptions)">
      <summary>
            Finds or construct a specific generic instance of the current generic method definition.
            </summary>
      <param name="genericArguments">Generic arguments.</param>
      <param name="bindingOptions">Binding options.</param>
      <returns>The generic instance, or <b>null</b> if it was not found and was not
            requested to be created.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.MethodDefDeclaration.ReferencesAnyGenericArgument">
      <summary>
            Determines whether generic arguments are used in the current signature.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.MethodDefDeclaration.MapGenericArguments(PostSharp.CodeModel.GenericMap)">
      <summary>
            Resolves all generic arguments in the current method signature.
            </summary>
      <param name="genericMap">Generic context in which generic arguments have to be resolved.</param>
      <returns>A method signature resolved against <paramref name="genericMap" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.MethodDefDeclaration.Translate(PostSharp.CodeModel.ModuleDeclaration)">
      <summary>
            Translates the current method signature so that it is meaningful in another
            module than the one to which it primarly belong.
            </summary>
      <param name="targetModule">Module into which the type signature should be
            translated.</param>
      <returns>A method signature meaningful in the <paramref name="targetModule" />
            module.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.MethodDefDeclaration.GetGenericContext(PostSharp.CodeModel.GenericContextOptions)">
      <summary>
            Gets the <see cref="T:PostSharp.CodeModel.GenericMap" /> of the current method.
            </summary>
      <returns>The <see cref="T:PostSharp.CodeModel.GenericMap" /> of the current method.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.MethodDefDeclaration.Visit(System.String,PostSharp.Collections.Visitor{PostSharp.CodeModel.ITypeSignature})">
      <summary>
            Requires a callback method (named <i>visitor</i>) to be called
            for each item of a given role in the current object, recursively.
            </summary>
      <param name="role">Role of items to be visited, or <b>null</b> if all items
            of type <typeparamref name="T" /> should be visited.</param>
      <param name="visitor">Delegate that should be called when an
            item in the given role is found.</param>
    </member>
    <member name="M:PostSharp.CodeModel.MethodDefDeclaration.WriteILDefinition(PostSharp.ModuleWriter.ILWriter)">
      <summary>
            Writes the IL definition of the current instance.
            </summary>
      <param name="writer">An <see cref="T:PostSharp.ModuleWriter.ILWriter" />.</param>
    </member>
    <member name="M:PostSharp.CodeModel.MethodDefDeclaration.ReleaseBody">
      <summary>
            Indicates that the body is no more needed in memory, so that
            it is marked for garbage collection. 
            </summary>
      <remarks>
            The body will be rebuilt
            from the PE image the next time it will be requested. All changes
            will be lost.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.MethodDefDeclaration.Remove">
      <summary>
            Remove the current declaration from its parent.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.MethodDefDeclaration.ClearCache" />
    <member name="P:PostSharp.CodeModel.MethodDefDeclaration.Visibility">
      <summary>
            Gets the visibility of the current method.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodDefDeclaration.MethodSpecs">
      <summary>
            Gets the collection of method specifications (<see cref="T:PostSharp.CodeModel.MethodSpecDeclaration" />).
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodDefDeclaration.GenericParameters">
      <summary>
            Gets the collection of generic formal parameters (<see cref="T:PostSharp.CodeModel.GenericParameterDeclaration" />).
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodDefDeclaration.PInvokeMap">
      <summary>
            Gets the P-Invoke map.
            </summary>
      <value>
            A <see cref="P:PostSharp.CodeModel.MethodDefDeclaration.PInvokeMap" />, or <b>null</b> if the current method
            is not a P-Invoke.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.MethodDefDeclaration.ReturnParameter">
      <summary>
            Gets the return parameter.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodDefDeclaration.Parameters">
      <summary>
            Gets the collection of parameters.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodDefDeclaration.Attributes">
      <summary>
            Gets or sets the method attributes.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodDefDeclaration.IsVirtual">
      <summary>
            Determines whether the method is virtual.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodDefDeclaration.IsAbstract">
      <summary>
            Determines whether the method is abstract.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodDefDeclaration.IsSealed">
      <summary>
            Determines whether the method is sealed.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodDefDeclaration.IsNew">
      <summary>
            Determines whether the method takes a new slot.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodDefDeclaration.IsStatic">
      <summary>
            Determines whether the method is static.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodDefDeclaration.CallingConvention">
      <summary>
            Gets or sets the method calling convention.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodDefDeclaration.PermissionSets">
      <summary>
            Gets the collection of permission sets (<see cref="T:PostSharp.CodeModel.PermissionSetDeclaration" />).
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodDefDeclaration.ImplementationAttributes">
      <summary>
            Gets or sets the method implementation attributes.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodDefDeclaration.HasBody">
      <summary>
            Determines whether the method currently has a body.
            </summary>
      <see cref="P:PostSharp.CodeModel.MethodDefDeclaration.MayHaveBody" />
    </member>
    <member name="P:PostSharp.CodeModel.MethodDefDeclaration.MayHaveBody">
      <summary>
            Determines whether this method may have a body.
            </summary>
      <see cref="P:PostSharp.CodeModel.MethodDefDeclaration.HasBody" />
      <remarks>
            The difference with <see cref="P:PostSharp.CodeModel.MethodDefDeclaration.HasBody" /> is that property
            returns <b>true</b> if the method body is <b>not yet</b>
            implemented, for instance because it was marked as <b>external</b>
            in C#. But the method would accept a method body. The current property
            returns <b>false</b> even if the current method has a body, but may not.
            </remarks>
    </member>
    <member name="P:PostSharp.CodeModel.MethodDefDeclaration.MethodBody">
      <summary>
            Gets the method body.
            </summary>
      <exception cref="T:System.InvalidOperationException">
            	This method can have no body.
            </exception>
    </member>
    <member name="P:PostSharp.CodeModel.MethodDefDeclaration.CallSiteSignatures">
      <summary>
            Call-site signature of the current method, if 
            it calling convention is <see cref="F:PostSharp.CodeModel.CallingConvention.VarArg" />.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodDefDeclaration.InterfaceImplementations">
      <summary>
            Gets the collection of interface methods that are implemented by the current method.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodDefDeclaration.IsGenericDefinition">
      <summary>
            Determines whether the current instance is a generic definition, i.e. whether it can
            be used to construct generic instances.
            </summary>
      <remarks>
            If the current property returns <b>true</b>, the semantics of <see cref="T:PostSharp.CodeModel.IGenericDefinition" />
            are meaningfull for the current intance.
            </remarks>
    </member>
    <member name="P:PostSharp.CodeModel.MethodDefDeclaration.DeclaringType">
      <summary>
            Gets the declaring <see cref="T:PostSharp.CodeModel.TypeDefDeclaration" />.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.Collections.MethodDefDeclarationCollection">
      <summary>
            Collection of methods (<see cref="T:PostSharp.CodeModel.MethodDefDeclaration" />).
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.MethodDefDeclarationCollection.GetMethod(System.String,PostSharp.CodeModel.IMethodSignature,PostSharp.CodeModel.BindingOptions)">
      <summary>
            Finds a method in the type given its name and signature.
            </summary>
      <param name="name">Method name.</param>
      <param name="signature">Method signature.</param>
      <param name="bindingOptions">Determines the behavior in case the method is not
            found.</param>
      <returns>The method, or <b>null</b> if the method could not be found.</returns>
    </member>
    <member name="T:PostSharp.CodeModel.MethodGroupDeclaration">
      <summary>
            Implements the functionalities that are common to <see cref="T:PostSharp.CodeModel.PropertyDeclaration" />
            and <see cref="T:PostSharp.CodeModel.EventDeclaration" />, which are both lexical collections of
            method semantics (<see cref="T:PostSharp.CodeModel.MethodSemanticDeclaration" />).
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.MethodGroupDeclaration.GetAccessor(PostSharp.CodeModel.MethodSemantics)">
      <summary>
            Gets an accessor method.
            </summary>
      <param name="semantic">Semantic of the requested accessor method.</param>
      <returns>The method of requested semantic, or <b>null</b> if the current <see cref="T:PostSharp.CodeModel.MethodGroupDeclaration" />
            does not contain the requested semantic.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.MethodGroupDeclaration.WriteMethodsILDefinition(PostSharp.ModuleWriter.ILWriter,PostSharp.CodeModel.GenericMap)">
      <summary>
            Writes the IL definition of the method semantics contained in the current collection.
            </summary>
      <param name="writer">An <see cref="T:PostSharp.ModuleWriter.ILWriter" />.</param>
      <param name="genericMap">The <see cref="T:PostSharp.CodeModel.GenericMap" /> of the
            declaring type.</param>
    </member>
    <member name="P:PostSharp.CodeModel.MethodGroupDeclaration.DeclaringType">
      <summary>
            Gets the parent <see cref="T:PostSharp.CodeModel.TypeDefDeclaration" />.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodGroupDeclaration.Members">
      <summary>
            Gets the collection of method semantics, which map a method to a role
            in the current event or property.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodGroupDeclaration.Visibility">
      <summary>
            Gets the visibility of the current element.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.PermissionDeclaration">
      <summary>
            Represents a permission attribute. 
            </summary>
      <remarks>
            Permission attributes are owned
            by permission sets (<see cref="T:PostSharp.CodeModel.PermissionSetDeclaration" />).
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.PermissionDeclaration.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.PermissionDeclaration" />.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.PermissionDeclaration.WriteILDefinition(PostSharp.ModuleWriter.ILWriter)">
      <summary>
            Writes the IL definition of the current instance.
            </summary>
      <param name="writer">An <see cref="T:PostSharp.ModuleWriter.ILWriter" />.</param>
    </member>
    <member name="M:PostSharp.CodeModel.PermissionDeclaration.Dispose" />
    <member name="P:PostSharp.CodeModel.PermissionDeclaration.Type">
      <summary>
            Gets the type of permission attribute.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.PermissionDeclaration.Properties">
      <summary>
            Gets the list of properties.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.PermissionDeclaration.IsDisposed">
      <summary>
            Determines whether the current instance has been disposed.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.Collections.PermissionDeclarationCollection">
      <summary>
            Collection of permission attributes (<see cref="T:PostSharp.CodeModel.PermissionDeclaration" />).
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.RawUnmanagedResource">
      <summary>
            Unmanaged resource given in raw form, as an array of bytes.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.UnmanagedResource">
      <summary>
            Abstract class representing an unmanaged (Windows) resource.
            The only current implementation is <see cref="T:PostSharp.CodeModel.RawUnmanagedResource" />,
            but later versions may provide implementations for specific types
            of resources.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.UnmanagedResource.Name">
      <summary>
            Gets the name of the current resource.
            </summary>
      <remarks>
            The combination of <see cref="P:PostSharp.CodeModel.UnmanagedResource.Name" />, type and <see cref="P:PostSharp.CodeModel.UnmanagedResource.Language" />
            should be unique.
            </remarks>
    </member>
    <member name="P:PostSharp.CodeModel.UnmanagedResource.CodePage">
      <summary>
            Gets or sets the code page identifier of the current resource.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.UnmanagedResource.Language">
      <summary>
            Gets or sets the language identifier of the current resource.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.UnmanagedResource.TypeId">
      <summary>
            Gets the well-known type of the current resource, or <see cref="F:PostSharp.CodeModel.UnmanagedResourceType.None" />
            if the type is not well-known, in which case its name is given by the <see cref="P:PostSharp.CodeModel.UnmanagedResource.TypeName" />
            property.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.UnmanagedResource.TypeName">
      <summary>
            Gets the name of the type of the current resource, in case that the
            <see cref="P:PostSharp.CodeModel.UnmanagedResource.TypeId" /> property is <see cref="F:PostSharp.CodeModel.UnmanagedResourceType.None" />/.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.UnmanagedResource.Version">
      <summary>
            Gets or sets the version of the current resource. 
            </summary>
      <remarks>
            Note that only the <b>Major</b> and <b>Minor</b> parts of the version
            are relevant, and they should be coded on a <see cref="T:System.Int16" />, not
            an <see cref="T:System.Int32" />.
            </remarks>
    </member>
    <member name="P:PostSharp.CodeModel.UnmanagedResource.Characteristics">
      <summary>
            Gets or sets the characteristics (attributes) of the resource.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.RawUnmanagedResource.#ctor(PostSharp.CodeModel.UnmanagedResourceName,PostSharp.CodeModel.UnmanagedResourceName,System.Int32,System.Int32,System.Version,System.Int32,System.Byte[])">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.RawUnmanagedResource" /></summary>
      <param name="name">Resource name.</param>
      <param name="type">Resource type. Typically, an <see cref="T:PostSharp.CodeModel.UnmanagedResourceType" />
            wrapped into an <see cref="T:PostSharp.CodeModel.UnmanagedResourceName" />.</param>
      <param name="codePage">Code page identifier.</param>
      <param name="language">Language identifier.</param>
      <param name="version">Resource version. Only <see cref="P:System.Version.Major" />
            and <see cref="P:System.Version.Minor" /> properties are relevant.</param>
      <param name="characteristics">Resource characteristics (attributes).</param>
      <param name="data">Raw data, or <b>null</b>.</param>
    </member>
    <member name="M:PostSharp.CodeModel.RawUnmanagedResource.ToString" />
    <member name="P:PostSharp.CodeModel.RawUnmanagedResource.Data">
      <summary>
            Gets or sets the array of bytes implementing the resource.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.ReflectionNameOptions">
      <summary>
            Options for the methods <see cref="M:PostSharp.CodeModel.ITypeSignature.WriteReflectionTypeName(System.Text.StringBuilder,PostSharp.CodeModel.ReflectionNameOptions)" />
            and <see cref="M:PostSharp.CodeModel.IMethod.WriteReflectionMethodName(System.Text.StringBuilder,PostSharp.CodeModel.ReflectionNameOptions)" />.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.ReflectionNameOptions.None">
      <summary>
            Default.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.ReflectionNameOptions.UseAssemblyName">
      <summary>
            Use assembly-qualified type names.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.ReflectionNameOptions.UseBracketsForGenerics">
      <summary>
            Use square brackets (e.g. <c>[T]</c>) instead of angle brackets (e.g. <c>&lt;T&gt;</c>).
            By default, angle brackets are used.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.ReflectionNameOptions.IgnoreGenericTypeDefParameters">
      <summary>
            Do not write generic parameters in type definitions. By default, the list of generic parameters
            is written.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.ReflectionNameOptions.NormalEncoding">
      <summary>
            Default encoding rules. Masked by <see cref="F:PostSharp.CodeModel.ReflectionNameOptions.EncodingMask" />.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.ReflectionNameOptions.MethodParameterEncoding">
      <summary>
            Encode using the rule that <see cref="N:System.Reflection" /> follows when it writes method parameters.
            Masked by <see cref="F:PostSharp.CodeModel.ReflectionNameOptions.EncodingMask" />.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.ReflectionNameOptions.GenericArgumentEncoding">
      <summary>
            Encode using the rule that <see cref="N:System.Reflection" /> follows when it writes generic arguments.
            Masked by <see cref="F:PostSharp.CodeModel.ReflectionNameOptions.EncodingMask" />.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.ReflectionNameOptions.EncodingMask">
      <summary>
            Masks the bits determining the encoding rules. Encoding rules are needed when trying to mimmic fidelly
            the behavior of <see cref="N:System.Reflection" />.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.ReflectionNameOptions.UseOrdinalsForGenerics">
      <summary>
            Write ordinals of generic parameters (.e.g. <c>!0</c>, <c>!1</c>, <c>!!0</c>, ...)
            instead of the name of generic parameters.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.ReflectionNameOptions.SkipNamespace">
      <summary>
            Do not write namespaces of types.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.ReflectionWrapper.IReflectionWrapper`1">
      <summary>
            Defines common public semantics of all reflection wrappers.
            </summary>
      <typeparam name="T">Type of underlying object.</typeparam>
    </member>
    <member name="P:PostSharp.CodeModel.ReflectionWrapper.IReflectionWrapper`1.WrappedObject">
      <summary>
            Gets the underlying <b>PostSharp.CodeModel</b> object.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.ReflectionWrapper.ReflectionWrapperUtil">
      <summary>
            Provides utility methods to work with reflection wrappers.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.ReflectionWrapper.ReflectionWrapperUtil.HideTypeFromAssembly(PostSharp.CodeModel.TypeDefDeclaration)">
      <summary>
            Marks a <see cref="T:PostSharp.CodeModel.TypeDefDeclaration" /> to that it won't be enumerated by
            the <see cref="M:PostSharp.CodeModel.ReflectionWrapper.IAssemblyWrapper.GetTypes" /> method of <see cref="T:PostSharp.CodeModel.ReflectionWrapper.AssemblyWrapper" />.
            </summary>
      <param name="typeDef">Type to hide from reflection wrappers.</param>
    </member>
    <member name="T:PostSharp.CodeModel.SerializationType">
      <summary>
            Represents the type of a serialized value.
            </summary>
      <remarks>
        <para>
            Implementations of this abstract type are present in
            the <see cref="N:PostSharp.CodeModel.SerializationTypes" /> namespace.
            </para>
        <para>
            Note that this type and its implementation only represent <i>intrinsic</i>
            serialization types and arrays. Compound types are not covered.
            </para>
      </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.SerializationType.GetRuntimeType">
      <summary>
            Gets the runtime, deserialized type correspondint to the current
            <see cref="T:PostSharp.CodeModel.SerializationType" />.
            </summary>
      <returns>Then runtime type that corresponds to the serialized type of the 
            current <see cref="T:PostSharp.CodeModel.SerializationType" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.SerializationType.ValidateValue(System.Object)">
      <summary>
            Ensures that a value is compatible with the current type.
            </summary>
      <param name="value">The value to validate.</param>
      <remarks>
        <para>Implementations should raise an <see cref="T:System.ArgumentException" /> if the value
            is invalid. 
            </para>
        <para>
            When PostSharp.Core.dll is compiled without the ASSERT constant, implementations
            do not throw exceptions and this method is always successful.
            </para>
      </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.SerializationType.GetSerializationType(PostSharp.CodeModel.ITypeSignature)">
      <summary>
            Gets the <see cref="T:PostSharp.CodeModel.SerializationType" /> corresponding to a given <see cref="T:PostSharp.CodeModel.ITypeSignature" />.
            </summary>
      <param name="typeSignature">A <see cref="T:PostSharp.CodeModel.ITypeSignature" />.</param>
      <returns>The <see cref="T:PostSharp.CodeModel.SerializationType" /> corresponding to <paramref name="typeSignature" />.</returns>
      <exception cref="T:System.ArgumentException">The given type cannot be serialized in intrinsic types.</exception>
    </member>
    <member name="M:PostSharp.CodeModel.SerializationType.Translate(PostSharp.CodeModel.ModuleDeclaration)">
      <summary>
            Translates the current <see cref="T:PostSharp.CodeModel.SerializationType" /> so that it is valid
            in another module.
            </summary>
      <param name="module">The module for which the <see cref="T:PostSharp.CodeModel.SerializationType" /> should be expressed.</param>
      <returns>An instance of <see cref="T:PostSharp.CodeModel.SerializationType" /> expressed for the other <paramref name="module" />.</returns>
    </member>
    <member name="P:PostSharp.CodeModel.SerializationType.Module">
      <summary>
            Gets the module to which the current <see cref="T:PostSharp.CodeModel.SerializationType" /> belongs.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.SerializationTypes.ArraySerializationType">
      <summary>
            Represents the serialization type of an array.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.SerializationTypes.ArraySerializationType.#ctor(PostSharp.CodeModel.SerializationType)">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.SerializationTypes.ArraySerializationType" />.
            </summary>
      <param name="elementType">Type of array elements.</param>
    </member>
    <member name="M:PostSharp.CodeModel.SerializationTypes.ArraySerializationType.GetRuntimeType" />
    <member name="M:PostSharp.CodeModel.SerializationTypes.ArraySerializationType.ValidateValue(System.Object)" />
    <member name="M:PostSharp.CodeModel.SerializationTypes.ArraySerializationType.Translate(PostSharp.CodeModel.ModuleDeclaration)" />
    <member name="P:PostSharp.CodeModel.SerializationTypes.ArraySerializationType.ElementType">
      <summary>
            Gets or sets the type of array elements.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.SerializationTypes.EnumerationSerializationType">
      <summary>
            Represents the serialization type of an enumeration.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.SerializationTypes.EnumerationSerializationType.#ctor(PostSharp.CodeModel.INamedType)">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.SerializationTypes.EnumerationSerializationType" />.
            </summary>
      <param name="enumerationType">Runtime type of the enumeration.</param>
    </member>
    <member name="M:PostSharp.CodeModel.SerializationTypes.EnumerationSerializationType.GetIntrinsicType" />
    <member name="M:PostSharp.CodeModel.SerializationTypes.EnumerationSerializationType.GetIntrinsicSerializationType" />
    <member name="M:PostSharp.CodeModel.SerializationTypes.EnumerationSerializationType.GetRuntimeType" />
    <member name="M:PostSharp.CodeModel.SerializationTypes.EnumerationSerializationType.ValidateValue(System.Object)" />
    <member name="M:PostSharp.CodeModel.SerializationTypes.EnumerationSerializationType.Translate(PostSharp.CodeModel.ModuleDeclaration)" />
    <member name="P:PostSharp.CodeModel.SerializationTypes.EnumerationSerializationType.EnumerationType">
      <summary>
            Gets or sets the runtime type of the enumeration.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.SerializationTypes.IntrinsicSerializationType">
      <summary>
            Represents instrinsic serialization types (boolean, int32, int64, ...).
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.SerializationTypes.IntrinsicSerializationType.GetInstance(PostSharp.CodeModel.ModuleDeclaration,PostSharp.CodeModel.IntrinsicType)">
      <summary>
            Gets an instance <see cref="T:PostSharp.CodeModel.SerializationTypes.IntrinsicSerializationType" /> for the current module.
            </summary>
      <param name="module">Module in which the instance should be valid.</param>
      <param name="type">Intrinsic type that should be represented by the instance.</param>
      <returns>An <see cref="T:PostSharp.CodeModel.SerializationTypes.IntrinsicSerializationType" /> represening <paramref name="type" />,
            valid in <paramref name="module" />.</returns>
      <remarks>
            User code should use the <see cref="T:PostSharp.CodeModel.DeclarationCache" />.
            <see cref="M:PostSharp.CodeModel.DeclarationCache.GetIntrinsicSerializationType(PostSharp.CodeModel.IntrinsicType)" />
            method instead.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.SerializationTypes.IntrinsicSerializationType.CreateValue(PostSharp.CodeModel.ModuleDeclaration,PostSharp.CodeModel.IntrinsicType,System.Object)">
      <summary>
            Creates a <see cref="T:PostSharp.CodeModel.SerializedValue" /> representing an intrinsic type.
            </summary>
      <param name="module">Module in which the <see cref="T:PostSharp.CodeModel.SerializedValue" /> should be valid.</param>
      <param name="type">Type of the intrinsic value.</param>
      <param name="value">A boxed value of type <paramref name="type" />.</param>
      <returns>A <see cref="T:PostSharp.CodeModel.SerializedValue" /> of type <paramref name="type" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.SerializationTypes.IntrinsicSerializationType.CreateValue(PostSharp.CodeModel.ModuleDeclaration,System.Boolean)">
      <summary>
            Creates a <see cref="T:PostSharp.CodeModel.SerializedValue" /> representing a <see cref="T:System.Boolean" />.
            </summary>
      <param name="module">Module in which the <see cref="T:PostSharp.CodeModel.SerializedValue" /> should be valid.</param>
      <param name="value">Value.</param>
      <returns>A <see cref="T:PostSharp.CodeModel.SerializedValue" /> encapsulating <paramref name="value" /> in <paramref name="module" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.SerializationTypes.IntrinsicSerializationType.CreateValue(PostSharp.CodeModel.ModuleDeclaration,System.Byte)">
      <summary>
            Creates a <see cref="T:PostSharp.CodeModel.SerializedValue" /> representing a <see cref="T:System.Boolean" />.
            </summary>
      <param name="module">Module in which the <see cref="T:PostSharp.CodeModel.SerializedValue" /> should be valid.</param>
      <param name="value">Value.</param>
      <returns>A <see cref="T:PostSharp.CodeModel.SerializedValue" /> encapsulating <paramref name="value" /> in <paramref name="module" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.SerializationTypes.IntrinsicSerializationType.CreateValue(PostSharp.CodeModel.ModuleDeclaration,System.Char)">
      <summary>
            Creates a <see cref="T:PostSharp.CodeModel.SerializedValue" /> representing a <see cref="T:System.Boolean" />.
            </summary>
      <param name="module">Module in which the <see cref="T:PostSharp.CodeModel.SerializedValue" /> should be valid.</param>
      <param name="value">Value.</param>
      <returns>A <see cref="T:PostSharp.CodeModel.SerializedValue" /> encapsulating <paramref name="value" /> in <paramref name="module" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.SerializationTypes.IntrinsicSerializationType.CreateValue(PostSharp.CodeModel.ModuleDeclaration,System.Double)">
      <summary>
            Creates a <see cref="T:PostSharp.CodeModel.SerializedValue" /> representing a <see cref="T:System.Double" />.
            </summary>
      <param name="module">Module in which the <see cref="T:PostSharp.CodeModel.SerializedValue" /> should be valid.</param>
      <param name="value">Value.</param>
      <returns>A <see cref="T:PostSharp.CodeModel.SerializedValue" /> encapsulating <paramref name="value" /> in <paramref name="module" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.SerializationTypes.IntrinsicSerializationType.CreateValue(PostSharp.CodeModel.ModuleDeclaration,System.Int16)">
      <summary>
            Creates a <see cref="T:PostSharp.CodeModel.SerializedValue" /> representing a <see cref="T:System.Int16" />.
            </summary>
      <param name="module">Module in which the <see cref="T:PostSharp.CodeModel.SerializedValue" /> should be valid.</param>
      <param name="value">Value.</param>
      <returns>A <see cref="T:PostSharp.CodeModel.SerializedValue" /> encapsulating <paramref name="value" /> in <paramref name="module" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.SerializationTypes.IntrinsicSerializationType.CreateValue(PostSharp.CodeModel.ModuleDeclaration,System.Int32)">
      <summary>
            Creates a <see cref="T:PostSharp.CodeModel.SerializedValue" /> representing a <see cref="T:System.Int32" />.
            </summary>
      <param name="module">Module in which the <see cref="T:PostSharp.CodeModel.SerializedValue" /> should be valid.</param>
      <param name="value">Value.</param>
      <returns>A <see cref="T:PostSharp.CodeModel.SerializedValue" /> encapsulating <paramref name="value" /> in <paramref name="module" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.SerializationTypes.IntrinsicSerializationType.CreateValue(PostSharp.CodeModel.ModuleDeclaration,System.Int64)">
      <summary>
            Creates a <see cref="T:PostSharp.CodeModel.SerializedValue" /> representing a <see cref="T:System.Int64" />.
            </summary>
      <param name="module">Module in which the <see cref="T:PostSharp.CodeModel.SerializedValue" /> should be valid.</param>
      <param name="value">Value.</param>
      <returns>A <see cref="T:PostSharp.CodeModel.SerializedValue" /> encapsulating <paramref name="value" /> in <paramref name="module" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.SerializationTypes.IntrinsicSerializationType.CreateValue(PostSharp.CodeModel.ModuleDeclaration,System.SByte)">
      <summary>
            Creates a <see cref="T:PostSharp.CodeModel.SerializedValue" /> representing a <see cref="T:System.SByte" />.
            </summary>
      <param name="module">Module in which the <see cref="T:PostSharp.CodeModel.SerializedValue" /> should be valid.</param>
      <param name="value">Value.</param>
      <returns>A <see cref="T:PostSharp.CodeModel.SerializedValue" /> encapsulating <paramref name="value" /> in <paramref name="module" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.SerializationTypes.IntrinsicSerializationType.CreateValue(PostSharp.CodeModel.ModuleDeclaration,System.Single)">
      <summary>
            Creates a <see cref="T:PostSharp.CodeModel.SerializedValue" /> representing a <see cref="T:System.Single" />.
            </summary>
      <param name="module">Module in which the <see cref="T:PostSharp.CodeModel.SerializedValue" /> should be valid.</param>
      <param name="value">Value.</param>
      <returns>A <see cref="T:PostSharp.CodeModel.SerializedValue" /> encapsulating <paramref name="value" /> in <paramref name="module" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.SerializationTypes.IntrinsicSerializationType.CreateValue(PostSharp.CodeModel.ModuleDeclaration,System.String)">
      <summary>
            Creates a <see cref="T:PostSharp.CodeModel.SerializedValue" /> representing a <see cref="T:System.String" />.
            </summary>
      <param name="module">Module in which the <see cref="T:PostSharp.CodeModel.SerializedValue" /> should be valid.</param>
      <param name="value">Value.</param>
      <returns>A <see cref="T:PostSharp.CodeModel.SerializedValue" /> encapsulating <paramref name="value" /> in <paramref name="module" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.SerializationTypes.IntrinsicSerializationType.CreateValue(PostSharp.CodeModel.ModuleDeclaration,System.UInt16)">
      <summary>
            Creates a <see cref="T:PostSharp.CodeModel.SerializedValue" /> representing a <see cref="T:System.UInt16" />.
            </summary>
      <param name="module">Module in which the <see cref="T:PostSharp.CodeModel.SerializedValue" /> should be valid.</param>
      <param name="value">Value.</param>
      <returns>A <see cref="T:PostSharp.CodeModel.SerializedValue" /> encapsulating <paramref name="value" /> in <paramref name="module" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.SerializationTypes.IntrinsicSerializationType.CreateValue(PostSharp.CodeModel.ModuleDeclaration,System.UInt32)">
      <summary>
            Creates a <see cref="T:PostSharp.CodeModel.SerializedValue" /> representing a <see cref="T:System.UInt32" />.
            </summary>
      <param name="module">Module in which the <see cref="T:PostSharp.CodeModel.SerializedValue" /> should be valid.</param>
      <param name="value">Value.</param>
      <returns>A <see cref="T:PostSharp.CodeModel.SerializedValue" /> encapsulating <paramref name="value" /> in <paramref name="module" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.SerializationTypes.IntrinsicSerializationType.CreateValue(PostSharp.CodeModel.ModuleDeclaration,System.UInt64)">
      <summary>
            Creates a <see cref="T:PostSharp.CodeModel.SerializedValue" /> representing a <see cref="T:System.UInt64" />.
            </summary>
      <param name="module">Module in which the <see cref="T:PostSharp.CodeModel.SerializedValue" /> should be valid.</param>
      <param name="value">Value.</param>
      <returns>A <see cref="T:PostSharp.CodeModel.SerializedValue" /> encapsulating <paramref name="value" /> in <paramref name="module" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.SerializationTypes.IntrinsicSerializationType.GetRuntimeType" />
    <member name="M:PostSharp.CodeModel.SerializationTypes.IntrinsicSerializationType.ValidateValue(System.Object)" />
    <member name="M:PostSharp.CodeModel.SerializationTypes.IntrinsicSerializationType.Translate(PostSharp.CodeModel.ModuleDeclaration)" />
    <member name="P:PostSharp.CodeModel.SerializationTypes.IntrinsicSerializationType.Type">
      <summary>
            Gets the <see cref="T:PostSharp.CodeModel.IntrinsicType" /> enumeration value.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.SerializationTypes.TaggedObjectSerializationType">
      <summary>
            Represents a tagged object serialization type, i.e. the type of a boxed value.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.SerializationTypes.TaggedObjectSerializationType.GetInstance(PostSharp.CodeModel.ModuleDeclaration)">
      <summary>
            Gets an instance of <see cref="T:PostSharp.CodeModel.SerializationTypes.TaggedObjectSerializationType" /> for a specific module.
            </summary>
      <param name="module">Module for which the instance should be valid.</param>
      <returns>A <see cref="T:PostSharp.CodeModel.SerializationTypes.TaggedObjectSerializationType" />.</returns>
      <remarks>
            User code should use <see cref="T:PostSharp.CodeModel.DeclarationCache" />.<see cref="F:PostSharp.CodeModel.DeclarationCache.TaggedObjectSerializationType" />
            instead of this method.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.SerializationTypes.TaggedObjectSerializationType.GetRuntimeType" />
    <member name="M:PostSharp.CodeModel.SerializationTypes.TaggedObjectSerializationType.ValidateValue(System.Object)" />
    <member name="M:PostSharp.CodeModel.SerializationTypes.TaggedObjectSerializationType.Translate(PostSharp.CodeModel.ModuleDeclaration)" />
    <member name="T:PostSharp.CodeModel.SerializationTypes.TypeSerializationType">
      <summary>
            Represents the serialization type of a type reference.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.SerializationTypes.TypeSerializationType.GetInstance(PostSharp.CodeModel.ModuleDeclaration)">
      <summary>
            Gets a <see cref="T:PostSharp.CodeModel.SerializationTypes.TypeSerializationType" /> for a given module.
            </summary>
      <param name="module">Module in which the instance should be valid.</param>
      <returns>A <see cref="T:PostSharp.CodeModel.SerializationTypes.TypeSerializationType" /> value for this module.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.SerializationTypes.TypeSerializationType.GetRuntimeType" />
    <member name="M:PostSharp.CodeModel.SerializationTypes.TypeSerializationType.ValidateValue(System.Object)" />
    <member name="M:PostSharp.CodeModel.SerializationTypes.TypeSerializationType.Translate(PostSharp.CodeModel.ModuleDeclaration)" />
    <member name="T:PostSharp.CodeModel.StandaloneAssemblyName">
      <summary>
            Standalone implementation  of <see cref="T:PostSharp.CodeModel.IAssemblyName" />.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.StandaloneAssemblyName.#ctor(System.String,System.Version,System.String,System.Byte[])">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.StandaloneAssemblyName" />.
            </summary>
      <param name="name">Short assembly name.</param>
      <param name="version">Assembly version.</param>
      <param name="culture">Assembly culture.</param>
      <param name="publicKeyToken">Assembly public key token/</param>
    </member>
    <member name="M:PostSharp.CodeModel.StandaloneAssemblyName.GetPublicKey">
      <summary>
            Gets the assemby public key.
            </summary>
      <value>
            An array of bytes containing the public key,
            or <b>null</b> if no public key is specified (for instance if
            only the public key token is given).
            </value>
      <returns>An array of bytes containing the public key,
            or <b>null</b> if no public key is specified.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.StandaloneAssemblyName.GetPublicKeyToken">
      <summary>
            Gets the assembly public key token.
            </summary>
      <returns>An array of bytes containing the public key token,
            or <b>null</b> if no public key is specified.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.StandaloneAssemblyName.ToString" />
    <member name="P:PostSharp.CodeModel.StandaloneAssemblyName.Name">
      <summary>
            Gets the assembly friendly name.
            </summary>
      <value>
            The assembly friendly name.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.StandaloneAssemblyName.FullName">
      <summary>
            Gets the assembly full name.
            </summary>
      <value>
            The assembly full name including version number, culture name
            and public key token.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.StandaloneAssemblyName.Version">
      <summary>
            Gets the assembly version.
            </summary>
      <value>
            A <see cref="P:PostSharp.CodeModel.IAssemblyName.Version" />.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.StandaloneAssemblyName.Culture">
      <summary>
            Gets the assembly culture name.
            </summary>
      <value>
            The standard assembly culture name, or <b>null</b> if the assembly
            is culture-neutral.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.StandaloneAssemblyName.IsMscorlib">
      <summary>
            Determines whether the current assembly is <b>mscorlib</b>.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.StandaloneAssemblyName.PublicKeyToken" />
    <member name="T:PostSharp.CodeModel.TypeClassifications">
      <summary>
            Type classifications are predicate that applies on types.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TypeClassifications.None">
      <summary>
            No classification.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TypeClassifications.Interface">
      <summary>
            Interface.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TypeClassifications.Class">
      <summary>
            Class.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TypeClassifications.Struct">
      <summary>
            Value type (other than <see cref="F:PostSharp.CodeModel.TypeClassifications.Enum" />).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TypeClassifications.Enum">
      <summary>
            Enumeration.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TypeClassifications.Module">
      <summary>
            The type representing the module.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TypeClassifications.Delegate">
      <summary>
            Delegate.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TypeClassifications.Pointer">
      <summary>
            Pointer (managed or unmanaged).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TypeClassifications.MethodPointer">
      <summary>
            Pointer to method.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TypeClassifications.Array">
      <summary>
            Array.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TypeClassifications.Boxed">
      <summary>
            Boxed value type.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TypeClassifications.GenericTypeInstance">
      <summary>
            Generic type instance.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TypeClassifications.GenericParameter">
      <summary>
            Generic parameter.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TypeClassifications.Intrinsic">
      <summary>
            Intrinsic.
            </summary>
      <remarks>
            An intrinsic type is defined by the VRE. Other are defined by libraries.
            </remarks>
    </member>
    <member name="F:PostSharp.CodeModel.TypeClassifications.Signature">
      <summary>
            Any type represented by a signature (not directly a type definition or type reference).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TypeClassifications.ReferenceType">
      <summary>
            Reference (heap) type.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TypeClassifications.ValueType">
      <summary>
            Value (stack) type.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TypeClassifications.Any">
      <summary>
            Any type.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.TypeDefDeclaration">
      <summary>
            Represents a type.
            </summary>
      <remarks>
             Types may be contained by other types (<see cref="T:PostSharp.CodeModel.TypeDefDeclaration" />)
            or modules (<see cref="T:PostSharp.CodeModel.ModuleDeclaration" />).
            </remarks>
    </member>
    <member name="F:PostSharp.CodeModel.TypeDefDeclaration.InstanceConstructorName">
      <summary>
            Method name for instance constructors.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TypeDefDeclaration.TypeConstructorName">
      <summary>
            Method name for type constructors.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TypeDefDeclaration.Auto">
      <summary>
            When applied to the <see cref="P:PostSharp.CodeModel.TypeDefDeclaration.ExplicitTypeSize" /> 
            or <see cref="P:PostSharp.CodeModel.TypeDefDeclaration.ExplicitAlignment" /> property,
            specifies that the type size or alignment (packing size) is determined automatically 
            by the runtime according to the current platform.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.TypeDefDeclaration.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.TypeDefDeclaration" />.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.TypeDefDeclaration.GetTokenType">
      <summary>
            Gets the metadata token type of the current declaration.
            </summary>
      <returns>A <see cref="T:PostSharp.CodeModel.TokenType" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeDefDeclaration.GetInterfacesRecursive">
      <summary>
            Gets the list of interfaces implemented directly or indirectly by the current type.
            </summary>
      <returns>The of interfaces implemented directly or indirectly by the current type.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeDefDeclaration.Equals(PostSharp.CodeModel.ITypeSignature)" />
    <member name="M:PostSharp.CodeModel.TypeDefDeclaration.MatchesReference(PostSharp.CodeModel.ITypeSignature)">
      <summary>
            Determines whether the current type signature matches a given type signature.
            </summary>
      <param name="reference">The type reference.</param>
      <returns>
        <b>true</b> if the current type signature matches <paramref name="reference" />,
            otherwise <b>false</b>.</returns>
      <remarks>A type reference can use an incomplete assembly reference. Therefore, the matching
            is performed using <see cref="M:PostSharp.CodeModel.IAssembly.MatchesReference(PostSharp.CodeModel.IAssemblyName)" />.
            Matching an assembly reference is a looser requirement than matching an assembly name exactly;
            an assembly reference may set no requirement on the public key token or the version, for instance.</remarks>
    </member>
    <member name="M:PostSharp.CodeModel.TypeDefDeclaration.ToString" />
    <member name="M:PostSharp.CodeModel.TypeDefDeclaration.IsAssignableTo(PostSharp.CodeModel.ITypeSignature,PostSharp.CodeModel.GenericMap)" />
    <member name="M:PostSharp.CodeModel.TypeDefDeclaration.IsAssignableTo(PostSharp.CodeModel.ITypeSignature)" />
    <member name="M:PostSharp.CodeModel.TypeDefDeclaration.GetCanonicalHashCode">
      <summary>
            Gets a hash code that is invariant under type signature equality
            (i.e. if two types are equal under <see cref="T:System.IEquatable`1" />, they have the
            same canonical has code).
            </summary>
      <returns>A hash code that is invariant under type signature equality.</returns>
      <remarks>This method is of course useful to build dictionaries. The <see cref="T:PostSharp.CodeModel.Binding.TypeComparer" /> class
            uses this method.</remarks>
    </member>
    <member name="M:PostSharp.CodeModel.TypeDefDeclaration.BelongsToClassification(PostSharp.CodeModel.TypeClassifications)">
      <summary>
            Determines whether the type signature belongs to a given classification,
            i.e. whether it fulfills a given predicate.
            </summary>
      <param name="typeClassification">The classification (or predicate) 
            (combination of bits are not allowed).</param>
      <returns>
        <see cref="F:PostSharp.NullableBool.True" /> if the predicate is true, 
            <see cref="F:PostSharp.NullableBool.False" /> if the predicate is false or
            <see cref="F:PostSharp.NullableBool.Null" /> if it cannot be determined. </returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeDefDeclaration.ContainsGenericArguments">
      <summary>
            Determines whether the type signature contains a generic argument.
            </summary>
      <returns>
        <b>true</b> if the type signature contains a generic argument, otherwise <b>false</b>.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeDefDeclaration.MapGenericArguments(PostSharp.CodeModel.GenericMap)">
      <summary>
            Resolves all generic arguments in the current type signature.
            </summary>
      <param name="genericMap">Generic context in which generic arguments have to be resolved.</param>
      <returns>A <see cref="T:PostSharp.CodeModel.IType" /> resolved against <paramref name="genericMap" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeDefDeclaration.GetValueSize(PostSharp.CodeModel.PlatformInfo)">
      <summary>
            Gets the size of the value type.
            </summary>
      <param name="platform">Information about the target platform.</param>
      <returns>The size of the value type in bytes, or -1 if the
            type is not a value type or has no fixed size.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeDefDeclaration.WriteReflectionTypeName(System.Text.StringBuilder,PostSharp.CodeModel.ReflectionNameOptions)">
      <summary>
            Gets the full type name according the conventions of <see cref="N:System.Reflection" />
            (with the namespace and nesting type but without the assembly name).
            </summary>
      <returns>The full type name (with the namespace and nesting type but without the assembly name).</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeDefDeclaration.GetSystemType(System.Type[],System.Type[])">
      <summary>
            Gets the system, runtime <see cref="T:System.Type" /> corresponding to the current type.
            </summary>
      <param name="genericTypeArguments">Array of generic type arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <param name="genericMethodArguments">Array of generic method arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <returns>The system <see cref="T:System.Type" /> associated the current type in the
            given generic context.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeDefDeclaration.GetReflectionWrapper(System.Type[],System.Type[])">
      <summary>
            Gets a reflection <see cref="T:System.Type" /> that wraps the current type.
            </summary>
      <param name="genericTypeArguments">Array of generic type arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <param name="genericMethodArguments">Array of generic method arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <returns>A <see cref="T:System.Type" /> wrapping current type in the
            given generic context.</returns>
      <remarks>
            This method returns a <see cref="T:System.Type" /> that is different from the system
            runtime type that is retrieved by <see cref="M:PostSharp.CodeModel.ITypeSignature.GetSystemType(System.Type[],System.Type[])" />. This allows
            a have a <b>System.Reflection</b> representation of the current type even
            when it cannot be loaded in the Virtual Runtime Engine.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.TypeDefDeclaration.Translate(PostSharp.CodeModel.ModuleDeclaration)">
      <summary>
            Translates the current type signature so that it is meaningful in another
            module than the one to which it primarly belong.
            </summary>
      <param name="targetModule">Module into which the type signature should be
            translated.</param>
      <returns>A type signature meaningful in the <paramref name="targetModule" />
            module.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeDefDeclaration.GetGenericContext(PostSharp.CodeModel.GenericContextOptions)">
      <summary>
            Gets the generic context inside the scope of the generic instance.
            </summary>
      <returns>A <see cref="T:PostSharp.CodeModel.GenericMap" /> mapping ordinals either
            to <see cref="T:PostSharp.CodeModel.GenericParameterDeclaration" /> (in case of
            generic definition), either of the type signature associated
            to this ordinal (in the case of generic instance).</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeDefDeclaration.WriteILDefinition(PostSharp.ModuleWriter.ILWriter)">
      <summary>
            Writes the IL definition of the current instance.
            </summary>
      <param name="writer">An <see cref="T:PostSharp.ModuleWriter.ILWriter" />.</param>
    </member>
    <member name="M:PostSharp.CodeModel.TypeDefDeclaration.FindField(System.String)">
      <summary>
            Finds a field in the current type or in its parents.
            </summary>
      <param name="fieldName">Field name.</param>
      <returns>The field named <paramref name="fieldName" />,
            or <b>null</b> if the field was not found.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeDefDeclaration.FindProperty(System.String)">
      <summary>
            Finds a property in the current type or in its parents.
            </summary>
      <param name="propertyName">Property name.</param>
      <returns>The property named <paramref name="propertyName" />,
            or <b>null</b> if that property could not be found.</returns>
      <remarks>Only parameterless properties are considered.</remarks>
    </member>
    <member name="M:PostSharp.CodeModel.TypeDefDeclaration.Remove">
      <summary>
            Remove the current declaration from its parent.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.TypeDefDeclaration.ClearCache" />
    <member name="P:PostSharp.CodeModel.TypeDefDeclaration.Visibility">
      <summary>
            Gets the type visibility.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeDefDeclaration.DeclaringType">
      <summary>
            Gets the declaring type (i.e. the type in which the current type
            is nested), or <b>null</b> if the current type is not nested.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeDefDeclaration.Attributes">
      <summary>
            Gets or sets the type attributes.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeDefDeclaration.IsSealed">
      <summary>
            Determines whether the type is sealed.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeDefDeclaration.IsInterface">
      <summary>
            Determines whether the type is an interface.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeDefDeclaration.IsAbstract">
      <summary>
            Determines whether the class is abstract.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeDefDeclaration.ExplicitAlignment">
      <summary>
            Gets or sets the field alignment (packing size).
            </summary>
      <value>
            Of of {1, 2, 4, 8, 16, 32, 64, 128}, or <see cref="F:PostSharp.CodeModel.TypeDefDeclaration.Auto" />
            to specify that the alignment shall be determined by the runtime.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.TypeDefDeclaration.ExplicitTypeSize">
      <summary>
            Gets or sets the type size.
            </summary>
      <value>
            A strictly positive integer, or <see cref="F:PostSharp.CodeModel.TypeDefDeclaration.Auto" />
            to specify that the size shall be computed by the runtime.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.TypeDefDeclaration.BaseType">
      <summary>
            Gets or sets the base type, from which the current type derives.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeDefDeclaration.Methods">
      <summary>
            Gets the collection of methods (<see cref="T:PostSharp.CodeModel.MethodDefDeclaration" />).
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeDefDeclaration.Types">
      <summary>
            Gets the collection of nested types (<see cref="T:PostSharp.CodeModel.TypeDefDeclaration" />).
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeDefDeclaration.Fields">
      <summary>
            Gets the collection of fields (<see cref="T:PostSharp.CodeModel.FieldDefDeclaration" />).
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeDefDeclaration.PermissionSets">
      <summary>
            Gets the collection of permission sets (<see cref="T:PostSharp.CodeModel.PermissionSetDeclaration" />).
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeDefDeclaration.InterfaceImplementations">
      <summary>
            Gets the collection of interfaces implemented by the current type.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeDefDeclaration.Properties">
      <summary>
            Gets the collection of properties (<see cref="T:PostSharp.CodeModel.PropertyDeclaration" />) defined
            in the current type.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeDefDeclaration.Events">
      <summary>
            Gets the collection of events (<see cref="T:PostSharp.CodeModel.EventDeclaration" />) defined
            in the current type.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeDefDeclaration.GenericParameters">
      <summary>
            Gets the collection of formal generic parameters of the current type.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeDefDeclaration.IsModuleSpecialType">
      <summary>
            Determines whether the current type is the special type representing the module.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeDefDeclaration.IsGenericDefinition">
      <summary>
            Determines whether the current instance is a generic definition, i.e. whether it can
            be used to construct generic instances.
            </summary>
      <remarks>
            If the current property returns <b>true</b>, the semantics of <see cref="T:PostSharp.CodeModel.IGenericDefinition" />
            are meaningfull for the current intance.
            </remarks>
    </member>
    <member name="T:PostSharp.CodeModel.Collections.TypeDefDeclarationCollection">
      <summary>
            Collection of types (<see cref="T:PostSharp.CodeModel.TypeDefDeclaration" />).
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.TypeNakingOptions">
      <summary>
            Determines the behavior of the <see cref="M:PostSharp.CodeModel.ITypeSignature.GetNakedType(PostSharp.CodeModel.TypeNakingOptions)" /> method.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TypeNakingOptions.None">
      <summary>
            No naking (unless unwrapping <see cref="T:PostSharp.CodeModel.TypeSpecDeclaration" />).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TypeNakingOptions.IgnoreOptionalCustomModifiers">
      <summary>
            Optional custom modifiers should be removed.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TypeNakingOptions.IgnoreRequiredCustomModifiers">
      <summary>
            Required custom modifiers should be removed.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TypeNakingOptions.IgnoreAllCustomModifiers">
      <summary>
            All custom modifiers should be removed.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TypeNakingOptions.IgnorePinned">
      <summary>
            Pinned modifiers should be removed.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TypeNakingOptions.IgnoreAll">
      <summary>
            Obsolete.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TypeNakingOptions.IgnoreModifiers">
      <summary>
            All modifiers (custom modifiers and <i>pinned</i> modifier) should be removed.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TypeNakingOptions.IgnoreManagedPointers">
      <summary>
            Ignore managed pointers.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.TypeSignatures.CustomModifier">
      <summary>
            Represents a custom modifier, which are tags emitted by compilers that
            add some meaning to the modified type.
            </summary>
      <remarks>
        <para>
               A custom modifier modifies a type and gives a a different meaning. For instance,
               the <see cref="T:System.Runtime.CompilerServices.IsConst" /> means that the argument
               should not be changed. Custom modifiers are emitted by compilers.
            </para>
      </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignatures.CustomModifier.#ctor(System.Boolean,PostSharp.CodeModel.ITypeSignature)">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.TypeSignatures.CustomModifier" />.
            </summary>
      <param name="required">Whether the custom attribute is required.</param>
      <param name="type">Type of the custom attribute.</param>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignatures.CustomModifier.Translate(PostSharp.CodeModel.ModuleDeclaration)" />
    <member name="P:PostSharp.CodeModel.TypeSignatures.CustomModifier.Required">
      <summary>
            Specifies whether the custom modifier is required.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeSignatures.CustomModifier.Type">
      <summary>
            Gets or sets the type of the custom modifier.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.TypeSignatures.GenericTypeInstanceTypeSignature">
      <summary>
            Represents a generic type construction.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.TypeSignature">
      <summary>
            Represents a type construction (pointer, array, generic type instance, intrinsic, ...).
            </summary>
      <remarks>
        <para>
            A type signature is composed of chains of type signature elements. Elements are instances
            of types of the <see cref="N:PostSharp.CodeModel.TypeSignatures" /> namespace. All
            element types are derived from <see cref="T:PostSharp.CodeModel.TypeSignature" />. The 
            <see cref="P:PostSharp.CodeModel.TypeSignature.ElementType" /> property gives the next element of the chain.
            </para>
        <para>
            For instance, the type signature <c>int * pinned</c> is
            a chain formed by <see cref="T:PostSharp.CodeModel.TypeSignatures.PinnedTypeSignature" /> ,
            <see cref="T:PostSharp.CodeModel.TypeSignatures.PointerTypeSignature" /> and 
            <see cref="T:PostSharp.CodeModel.TypeSignatures.IntrinsicTypeSignature" />. This type signature
            would be instantiated by the following code:
            </para>
        <code>
            TypeSignature sig = TypeSignature.MakeIntrinsic(PrimitiveType.Int32).MakePointer(true).MakePinned();
            </code>
        <para>
            The <see cref="T:PostSharp.CodeModel.TypeSignature" /> type defines the common functionalities of
            all type signature elements.
            </para>
        <para>
            Instances of all types derived from <see cref="T:PostSharp.CodeModel.TypeSignature" /> are immutable.
            </para>
      </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignature.ContainsGenericArguments">
      <summary>
            Determines whether the type signature contains a generic argument.
            </summary>
      <returns>
        <b>true</b> if the type signature contains a generic argument, otherwise <b>false</b>.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignature.MapGenericArguments(PostSharp.CodeModel.GenericMap)">
      <summary>
            Resolves all generic arguments in the current type signature.
            </summary>
      <param name="genericMap">Generic context in which generic arguments have to be resolved.</param>
      <returns>A <see cref="T:PostSharp.CodeModel.IType" /> resolved against <paramref name="genericMap" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignature.BelongsToClassification(PostSharp.CodeModel.TypeClassifications)">
      <summary>
            Determines whether the type signature belongs to a given classification,
            i.e. whether it fulfills a given predicate.
            </summary>
      <param name="typeClassification">The classification (or predicate) 
            (combination of bits are not allowed).</param>
      <returns>
        <see cref="F:PostSharp.NullableBool.True" /> if the predicate is true, 
            <see cref="F:PostSharp.NullableBool.False" /> if the predicate is false or
            <see cref="F:PostSharp.NullableBool.Null" /> if it cannot be determined. </returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignature.GetSystemType(System.Type[],System.Type[])">
      <summary>
            Gets the system, runtime <see cref="T:System.Type" /> corresponding to the current type.
            </summary>
      <param name="genericTypeArguments">Array of generic type arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <param name="genericMethodArguments">Array of generic method arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <returns>The system <see cref="T:System.Type" /> associated the current type in the
            given generic context.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignature.GetReflectionWrapper(System.Type[],System.Type[])">
      <summary>
            Gets a reflection <see cref="T:System.Type" /> that wraps the current type.
            </summary>
      <param name="genericTypeArguments">Array of generic type arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <param name="genericMethodArguments">Array of generic method arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <returns>A <see cref="T:System.Type" /> wrapping current type in the
            given generic context.</returns>
      <remarks>
            This method returns a <see cref="T:System.Type" /> that is different from the system
            runtime type that is retrieved by <see cref="M:PostSharp.CodeModel.ITypeSignature.GetSystemType(System.Type[],System.Type[])" />. This allows
            a have a <b>System.Reflection</b> representation of the current type even
            when it cannot be loaded in the Virtual Runtime Engine.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignature.GetValueSize(PostSharp.CodeModel.PlatformInfo)">
      <summary>
            Gets the size of the value type.
            </summary>
      <param name="platform">Information about the target platform.</param>
      <returns>The size of the value type in bytes, or -1 if the
            type is not a value type or has no fixed size.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignature.Translate(PostSharp.CodeModel.ModuleDeclaration)">
      <summary>
            Translates the current type signature so that it is meaningful in another
            module than the one to which it primarly belong.
            </summary>
      <param name="targetModule">Module into which the type signature should be
            translated.</param>
      <returns>A type signature meaningful in the <paramref name="targetModule" />
            module.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignature.WriteReflectionTypeName(System.Text.StringBuilder,PostSharp.CodeModel.ReflectionNameOptions)">
      <summary>
            Gets the type name as used in <b>System.Reflection</b>.
            </summary>
      <returns>A <see cref="T:System.String" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignature.Visit(System.String,PostSharp.Collections.Visitor{PostSharp.CodeModel.ITypeSignature})">
      <summary>
            Requires a callback method (named <i>visitor</i>) to be called
            for each item of a given role in the current object, recursively.
            </summary>
      <param name="role">Role of items to be visited, or <b>null</b> if all items
            of type <typeparamref name="T" /> should be visited.</param>
      <param name="visitor">Delegate that should be called when an
            item in the given role is found.</param>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignature.IsAssignableTo(PostSharp.CodeModel.ITypeSignature,PostSharp.CodeModel.GenericMap)" />
    <member name="M:PostSharp.CodeModel.TypeSignature.IsAssignableTo(PostSharp.CodeModel.ITypeSignature)" />
    <member name="M:PostSharp.CodeModel.TypeSignature.GetCanonicalHashCode">
      <summary>
            Gets a hash code that is invariant under type signature equality
            (i.e. if two types are equal under <see cref="T:System.IEquatable`1" />, they have the
            same canonical has code).
            </summary>
      <returns>A hash code that is invariant under type signature equality.</returns>
      <remarks>This method is of course useful to build dictionaries. The <see cref="T:PostSharp.CodeModel.Binding.TypeComparer" /> class
            uses this method.</remarks>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignature.GetTypeDefinition" />
    <member name="M:PostSharp.CodeModel.TypeSignature.GetTypeDefinition(PostSharp.CodeModel.BindingOptions)" />
    <member name="M:PostSharp.CodeModel.TypeSignature.Equals(PostSharp.CodeModel.ITypeSignature)" />
    <member name="M:PostSharp.CodeModel.TypeSignature.MatchesReference(PostSharp.CodeModel.ITypeSignature)">
      <summary>
            Determines whether the current type signature matches a given type signature.
            </summary>
      <param name="reference">The type reference.</param>
      <returns>
        <b>true</b> if the current type signature matches <paramref name="reference" />,
            otherwise <b>false</b>.</returns>
      <remarks>A type reference can use an incomplete assembly reference. Therefore, the matching
            is performed using <see cref="M:PostSharp.CodeModel.IAssembly.MatchesReference(PostSharp.CodeModel.IAssemblyName)" />.
            Matching an assembly reference is a looser requirement than matching an assembly name exactly;
            an assembly reference may set no requirement on the public key token or the version, for instance.</remarks>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignature.InternalGetTypeDefinition(PostSharp.CodeModel.BindingOptions)" />
    <member name="M:PostSharp.CodeModel.TypeSignature.GetGenericContext(PostSharp.CodeModel.GenericContextOptions)">
      <summary>
            Gets the generic context inside the scope of the generic instance.
            </summary>
      <returns>A <see cref="T:PostSharp.CodeModel.GenericMap" /> mapping ordinals either
            to <see cref="T:PostSharp.CodeModel.GenericParameterDeclaration" /> (in case of
            generic definition), either of the type signature associated
            to this ordinal (in the case of generic instance).</returns>
    </member>
    <member name="P:PostSharp.CodeModel.TypeSignature.ElementType">
      <summary>
            Gets the textWriter <see cref="T:PostSharp.CodeModel.TypeSignature" />, i.e. the next element of
            the chains of type signature element.
            </summary>
      <remarks>
            A <see cref="T:PostSharp.CodeModel.TypeSignature" />, or <b>null</b> if there is no textWriter type.
            </remarks>
    </member>
    <member name="P:PostSharp.CodeModel.TypeSignature.Name" />
    <member name="P:PostSharp.CodeModel.TypeSignature.AssemblyQualifiedName" />
    <member name="P:PostSharp.CodeModel.TypeSignature.DeclaringAssembly">
      <summary>
            Gets the declaring assembly.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeSignature.Module">
      <summary>
            Gets the declaring module.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeSignature.IsGenericInstance">
      <summary>
            Determines whether the current instance is a generic instance, i.e. whether it has
            been constructed from a generic definition.
            </summary>
      <remarks>
            If the current property returns <b>true</b>, the semantics of <see cref="T:PostSharp.CodeModel.IGenericInstance" />
            are meaningfull for the current intance.
            </remarks>
    </member>
    <member name="T:PostSharp.CodeModel.IGenericInstance">
      <summary>
            Exposes the semantics of a generic instance (i.e. an instance of generic definition,
            with concretely specified generic, bound arguments).
            </summary>
      <remarks>
            The fact that an object can be casted to <see cref="T:PostSharp.CodeModel.IGenericInstance" /> does not
            automatically mean that it is actually a generic instance. It is always necessary
            to check the <see cref="P:PostSharp.CodeModel.IGeneric.IsGenericInstance" /> property.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.IGenericInstance.GetGenericArgument(System.Int32)">
      <summary>
            Gets a generic (concrete, bound) argument given its ordinal.
            </summary>
      <param name="ordinal">The generic argument ordinal (position).</param>
      <returns>An <see cref="T:PostSharp.CodeModel.IType" />, or <b>null</b>
            if the current generic orginal does not exist.</returns>
    </member>
    <member name="P:PostSharp.CodeModel.IGenericInstance.GenericArgumentCount">
      <summary>
            Gets the number of (concrete, bound) generic arguments.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignatures.GenericTypeInstanceTypeSignature.#ctor(PostSharp.CodeModel.INamedType,System.Collections.Generic.IList{PostSharp.CodeModel.ITypeSignature})">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.TypeSignatures.GenericTypeInstanceTypeSignature" />.
            </summary>
      <param name="genericDeclaration">The formal generic type.</param>
      <param name="genericArguments">List of concrete generic arguments.</param>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignatures.GenericTypeInstanceTypeSignature.WriteReflectionTypeName(System.Text.StringBuilder,PostSharp.CodeModel.ReflectionNameOptions)" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.GenericTypeInstanceTypeSignature.ToString" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.GenericTypeInstanceTypeSignature.BelongsToClassification(PostSharp.CodeModel.TypeClassifications)" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.GenericTypeInstanceTypeSignature.GetGenericContext(PostSharp.CodeModel.GenericContextOptions)">
      <summary>
            Gets the generic context inside the scope of the generic instance.
            </summary>
      <returns>A <see cref="T:PostSharp.CodeModel.GenericMap" /> mapping ordinals either
            to <see cref="T:PostSharp.CodeModel.GenericParameterDeclaration" /> (in case of
            generic definition), either of the type signature associated
            to this ordinal (in the case of generic instance).</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignatures.GenericTypeInstanceTypeSignature.ContainsGenericArguments" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.GenericTypeInstanceTypeSignature.MapGenericArguments(PostSharp.CodeModel.GenericMap)" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.GenericTypeInstanceTypeSignature.GetValueSize(PostSharp.CodeModel.PlatformInfo)">
      <notSupported />
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignatures.GenericTypeInstanceTypeSignature.GetReflectionWrapper(System.Type[],System.Type[])" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.GenericTypeInstanceTypeSignature.GetSystemType(System.Type[],System.Type[])" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.GenericTypeInstanceTypeSignature.Translate(PostSharp.CodeModel.ModuleDeclaration)" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.GenericTypeInstanceTypeSignature.ResolveGenericContext(PostSharp.CodeModel.GenericMap)">
      <summary>
            Return the <see cref="T:PostSharp.CodeModel.GenericMap" /> valid inside the scope of this generic type specification.
            </summary>
      <param name="context">The <see cref="T:PostSharp.CodeModel.GenericMap" /> valid <i>outside</i> the scope
            of the generic type definition.</param>
      <returns>A <see cref="T:PostSharp.CodeModel.GenericMap" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignatures.GenericTypeInstanceTypeSignature.Visit(System.String,PostSharp.Collections.Visitor{PostSharp.CodeModel.ITypeSignature})" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.GenericTypeInstanceTypeSignature.GetCanonicalHashCode" />
    <member name="P:PostSharp.CodeModel.TypeSignatures.GenericTypeInstanceTypeSignature.GenericDefinition">
      <summary>
            Gets the formal generic type.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeSignatures.GenericTypeInstanceTypeSignature.GenericArguments">
      <summary>
            Gets the list of concrete generic arguments.
            </summary>
      <value>
            A read-only list of <see cref="T:PostSharp.CodeModel.TypeSignature" />.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.TypeSignatures.GenericTypeInstanceTypeSignature.IsGenericInstance">
      <summary>
            Determines whether the current instance is a generic instance, i.e. whether it has
            been constructed from a generic definition.
            </summary>
      <remarks>
            If the current property returns <b>true</b>, the semantics of <see cref="T:PostSharp.CodeModel.IGenericInstance" />
            are meaningfull for the current intance.
            </remarks>
    </member>
    <member name="P:PostSharp.CodeModel.TypeSignatures.GenericTypeInstanceTypeSignature.ElementType">
      <summary>
            Gets the formal generic type.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeSignatures.GenericTypeInstanceTypeSignature.Module" />
    <member name="T:PostSharp.CodeModel.Collections.UnmanagedResourceCollection">
      <summary>
            Collection of unmanaged resources (<see cref="T:PostSharp.CodeModel.UnmanagedResource" />).
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.UnmanagedResourceCollection.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.Collections.UnmanagedResourceCollection" />.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.UnmanagedResourceName">
      <summary>
            Represents the name or the type of an <see cref="T:PostSharp.CodeModel.UnmanagedResource" />,
            which can consist either in a string, either in an integer.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.UnmanagedResourceName.#ctor(System.Int32)">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.UnmanagedResourceName" /> with an integer.
            </summary>
      <param name="id">Integer identifier.</param>
    </member>
    <member name="M:PostSharp.CodeModel.UnmanagedResourceName.#ctor(System.String)">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.UnmanagedResourceName" /> with a string.
            </summary>
      <param name="name">String representation of the name.</param>
    </member>
    <member name="M:PostSharp.CodeModel.UnmanagedResourceName.#ctor(System.Object)">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.UnmanagedResourceName" /> with an
            integer <i>or</i> a string.
            </summary>
      <param name="idOrName">An <see cref="T:System.Int32" /> or a <see cref="T:System.String" />.</param>
    </member>
    <member name="M:PostSharp.CodeModel.UnmanagedResourceName.ToString" />
    <member name="M:PostSharp.CodeModel.UnmanagedResourceName.ToObject">
      <summary>
            Converts the current object to a boxed <see cref="T:System.Int32" /> or to a <see cref="T:System.String" />.
            </summary>
      <returns>A boxed <see cref="T:System.Int32" /> or a <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:PostSharp.CodeModel.UnmanagedResourceName.IsId">
      <summary>
            Determines whether the current <see cref="T:PostSharp.CodeModel.UnmanagedResourceName" />
            is an identifier (<see cref="T:System.Int32" />).
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.UnmanagedResourceName.IsName">
      <summary>
            Determines whether the current <see cref="T:PostSharp.CodeModel.UnmanagedResourceName" />
            is a name (<see cref="T:System.String" />).
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.UnmanagedResourceName.Name">
      <summary>
            Gets the string representing the current <see cref="T:PostSharp.CodeModel.UnmanagedResourceName" />,
            or <b>null</b> if the current object has an identifier (<see cref="P:PostSharp.CodeModel.UnmanagedResourceName.Id" />).
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.UnmanagedResourceName.Id">
      <summary>
            Gets the integer identifier representing the current <see cref="T:PostSharp.CodeModel.UnmanagedResourceName" />,
            or <b>0</b> if the current object has a name (<see cref="P:PostSharp.CodeModel.UnmanagedResourceName.Name" />).
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.UnmanagedResourceType">
      <summary>
            Types of unmanaged resources (like <see cref="F:PostSharp.CodeModel.UnmanagedResourceType.Accelerator" />, <see cref="F:PostSharp.CodeModel.UnmanagedResourceType.Icon" />, ...).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.UnmanagedResourceType.None">
      <summary>
            Not a well-known type. It may be a named type 
            (see <see cref="P:PostSharp.CodeModel.UnmanagedResource.TypeName" />).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.UnmanagedResourceType.Accelerator">
      <summary>
            Accelerator table. 
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.UnmanagedResourceType.AnimatedCursor">
      <summary>
            Animated cursor. 
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.UnmanagedResourceType.AnimatedIcon">
      <summary>
            Animated icon. 
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.UnmanagedResourceType.Bitmap">
      <summary>
            Bitmap resource. 
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.UnmanagedResourceType.Cursor">
      <summary>
            Hardware-dependent cursor resource. 
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.UnmanagedResourceType.Dialog">
      <summary>
            Dialog box. 
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.UnmanagedResourceType.DialogInclude">
      <summary>
            Allows a resource editing tool to associate a string with an .rc file. 
            Typically, the string is the name of the header file that provides symbolic names. 
            The resource compiler parses the string but otherwise ignores the value. 
            For example, file MyFile.dlg: 
            1 DLGINCLUDE "MyFile.h"
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.UnmanagedResourceType.Font">
      <summary>
            Font resource. 
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.UnmanagedResourceType.FontDirectory">
      <summary>
            Font directory resource. 
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.UnmanagedResourceType.GroupCursor">
      <summary>
            Hardware-independent cursor resource. 
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.UnmanagedResourceType.IconCursor">
      <summary>
            Hardware-independent icon resource. 
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.UnmanagedResourceType.Html">
      <summary>
            HTML
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.UnmanagedResourceType.Icon">
      <summary>
            Hardware-dependent icon resource. 
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.UnmanagedResourceType.Manifest">
      <summary>
            Microsoft Windows XP: Side-by-Side Assembly XML Manifest. 
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.UnmanagedResourceType.Menu">
      <summary>
            Menu resource. 
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.UnmanagedResourceType.MessageTable">
      <summary>
            Message-table entry. 
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.UnmanagedResourceType.PlugPlay">
      <summary>
            Plug and Play resource. 
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.UnmanagedResourceType.RcData">
      <summary>
            Application-defined resource (raw data). 
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.UnmanagedResourceType.String">
      <summary>
            String-table entry. 
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.UnmanagedResourceType.Version">
      <summary>
            Version resource. 
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.UnmanagedResourceType.VxD">
      <summary>
            VxD.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.Visibility">
      <summary>
            Visibity of types and type members.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.Visibility.Public">
      <summary>
            Public.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.Visibility.Family">
      <summary>
            Family (protected).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.Visibility.Assembly">
      <summary>
            Assembly (internal).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.Visibility.FamilyOrAssembly">
      <summary>
            Family or assembly (protected internal).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.Visibility.FamilyAndAssembly">
      <summary>
            Family and assembly (no C# equivalent: protected types inside the current assembly).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.Visibility.Private">
      <summary>
            Private.
            </summary>
    </member>
    <member name="T:PostSharp.CodeWeaver.IAdviceProvider">
      <summary>
            Pluggable tasks (<see cref="T:PostSharp.Extensibility.Task" />) should implement this interface
            when they want to provide advices (<see cref="T:PostSharp.CodeWeaver.IAdvice" />) to the <see cref="T:PostSharp.CodeWeaver.WeaverTask" />.
            </summary>
    </member>
    <member name="M:PostSharp.CodeWeaver.IAdviceProvider.ProvideAdvices(PostSharp.CodeWeaver.Weaver)">
      <summary>
            When implemented, adds advices to a <see cref="T:PostSharp.CodeWeaver.Weaver" />, typically
            using the <see cref="M:PostSharp.CodeWeaver.Weaver.AddMethodLevelAdvice(PostSharp.CodeWeaver.IAdvice,System.Collections.Generic.IEnumerable{PostSharp.CodeModel.MethodDefDeclaration},PostSharp.CodeWeaver.JoinPointKinds,System.Collections.Generic.IEnumerable{PostSharp.CodeModel.MetadataDeclaration})" /> and 
            <see cref="M:PostSharp.CodeWeaver.Weaver.AddTypeLevelAdvice(PostSharp.CodeWeaver.IAdvice,PostSharp.CodeWeaver.JoinPointKinds,System.Collections.Generic.IEnumerable{PostSharp.CodeModel.TypeDefDeclaration})" /> methods.
            </summary>
      <param name="codeWeaver">The weaver to which advices should be added.</param>
    </member>
    <member name="T:PostSharp.CodeWeaver.JoinPointKinds">
      <summary>
            Kinds of join points.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.JoinPointKinds.None">
      <summary>
            None.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.JoinPointKinds.BeforeMethodBody">
      <summary>
            Before the method body. This is a <b>method-level</b> advice.
            </summary>
      <remarks>
            If the method is an instance constructor, this join point is
            located just <i>after</i> the <b>this</b> pointer has been initialized.
            Use the <see cref="F:PostSharp.CodeWeaver.JoinPointKinds.BeforeInstanceConstructor" /> kind to have
            a join point located at the real beginning of the constructor.
            </remarks>
    </member>
    <member name="F:PostSharp.CodeWeaver.JoinPointKinds.AfterMethodBodyAlways">
      <summary>
            After the method body, in every case (exception or normal termination).
            This is a <b>method-level</b> advice.
            </summary>
      <remarks>
            The advice should not emit the <b>endfinally</b> instruction, since
            it is already emitted by the weaver.
            </remarks>
    </member>
    <member name="F:PostSharp.CodeWeaver.JoinPointKinds.AfterMethodBodySuccess">
      <summary>
            After the method body, in case of success.
            This is a <b>method-level</b> advice.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.JoinPointKinds.AfterMethodBodyException">
      <summary>
            After the method body, only in case of exception.
            This is a <b>method-level</b> advice.
            </summary>
      <remarks>
        <para>The exception object is available on the top of the stack.</para>
        <para>The advice should not emit the <b>endfinally</b> instruction, since
            it is already emitted by the weaver.</para>
      </remarks>
    </member>
    <member name="F:PostSharp.CodeWeaver.JoinPointKinds.BeforeGetField">
      <summary>
            Before getting a field.
             This is a <b>method-level</b> advice.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.JoinPointKinds.AfterGetField">
      <summary>
            After getting a field.
             This is a <b>method-level</b> advice.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.JoinPointKinds.InsteadOfGetField">
      <summary>
            Instead of getting a field.
            This is both a <b>field-level</b> and <b>method-level</b> advice.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.JoinPointKinds.BeforeSetField">
      <summary>
            Before setting a field.
             This is a <b>method-level</b> advice.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.JoinPointKinds.AfterSetField">
      <summary>
            After setting a field.
             This is a <b>method-level</b> advice.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.JoinPointKinds.InsteadOfSetField">
      <summary>
            Instead of setting a field.
             This is a <b>method-level</b> advice.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.JoinPointKinds.BeforeCall">
      <summary>
            Before calling a method.
            This is a <b>method-level</b> advice.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.JoinPointKinds.AfterCall">
      <summary>
            After calling a method.
            This is a <b>method-level</b> advice.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.JoinPointKinds.InsteadOfCall">
      <summary>
            Instead of calling a method.
            This is a <b>method-level</b> advice.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.JoinPointKinds.BeforeGetArray">
      <summary>
            Before getting an array element.
            This is a <b>method-level</b> advice.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.JoinPointKinds.AfterGetArray">
      <summary>
            After getting an array element.
            This is a <b>method-level</b> advice.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.JoinPointKinds.InsteadOfGetArray">
      <summary>
            Instead of getting an array element.
            This is a <b>method-level</b> advice.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.JoinPointKinds.BeforeSetArray">
      <summary>
            Before setting an array element.
            This is a <b>method-level</b> advice.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.JoinPointKinds.AfterSetArray">
      <summary>
            After setting an array element.
            This is a <b>method-level</b> advice.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.JoinPointKinds.InsteadOfSetArray">
      <summary>
            Instead of setting an array element.
            This is a <b>method-level</b> advice.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.JoinPointKinds.BeforeThrow">
      <summary>
            Before the <b>throw</b> or <b>rethrow</b> instruction.
            This is a <b>method-level</b> advice.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.JoinPointKinds.BeforeInstanceConstructor">
      <summary>
            In the real beginning of instance constructors, even before the <b>this</b> pointer
            is initialized.
            This is a <b>method-level</b> advice.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.JoinPointKinds.BeforeStaticConstructor">
      <summary>
            Before the class/static constructors (creates the class constructor if not yet present).
            This is a <b>type-level</b> advice.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.JoinPointKinds.AfterInstanceInitialization">
      <summary>
            Just after the <b>this</b> pointer has been initialized (in each constructor that calls
            the constructor of the base type).
            This is a <b>type-level</b> advice.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.JoinPointKinds.BeforeNewObject">
      <summary>
            Just before the <b>newobj</b> instruction.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.JoinPointKinds.InsteadOfNewObject">
      <summary>
            Instead of the <b>newobj</b> instruction.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.JoinPointKinds.AfterNewObject">
      <summary>
            Just before the <b>newobj</b> instruction.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.JoinPointKinds.BeforeGetFieldAddress">
      <summary>
            Just before the <b>ldflda</b> or <b>ldsflda</b> instruction.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.JoinPointKinds.AfterGetFieldAddress">
      <summary>
            Just after the <b>ldflda</b> or <b>ldsflda</b> instruction.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.JoinPointKinds.InsteadOfGetFieldAddress">
      <summary>
            Instead of the <b>ldflda</b> or <b>ldsflda</b> instruction.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.JoinPointKinds.BeforeLoadArgument">
      <summary>
            Just before the <b>ldarg*</b> instructions.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.JoinPointKinds.AfterLoadArgument">
      <summary>
            Just after the <b>ldarg*</b> instructions.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.JoinPointKinds.InsteadOfLoadArgument">
      <summary>
            Instead of the <b>ldarg*</b> instructions.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.JoinPointKinds.BeforeStoreArgument">
      <summary>
            Just before the <b>starg*</b> instructions.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.JoinPointKinds.AfterStoreArgument">
      <summary>
            Just after the <b>starg*</b> instructions.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.JoinPointKinds.InsteadOfStoreArgument">
      <summary>
            Instead of the <b>starg*</b> instructions.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.JoinPointKinds.BeforeLoadArgumentAddress">
      <summary>
            Just before the <b>ldarga*</b> instructions.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.JoinPointKinds.AfterLoadArgumentAddress">
      <summary>
            Just after the <b>ldarga*</b> instructions.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.JoinPointKinds.InsteadOfLoadArgumentAddress">
      <summary>
            Instead of the <b>ldarga*</b> instructions.
            </summary>
    </member>
    <member name="T:PostSharp.CodeWeaver.MethodBodyRestructurer">
      <summary>
            Restructures a method body so that the original code can be
            wrapped into a try...catch block.
            </summary>
    </member>
    <member name="M:PostSharp.CodeWeaver.MethodBodyRestructurer.#ctor(PostSharp.CodeModel.MethodDefDeclaration,PostSharp.CodeWeaver.MethodBodyRestructurerOptions,PostSharp.CodeWeaver.WeavingHelper)">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeWeaver.MethodBodyRestructurer" />.
            </summary>
      <param name="method">The method that will be restructured.</param>
      <param name="options">Options.</param>
      <param name="weavingHelper">A <see cref="T:PostSharp.CodeWeaver.WeavingHelper" />.</param>
    </member>
    <member name="M:PostSharp.CodeWeaver.MethodBodyRestructurer.Restructure(PostSharp.CodeModel.InstructionWriter)">
      <summary>
            Proceeds with the method body restructuration process.
            </summary>
      <param name="writer">An <see cref="T:PostSharp.CodeModel.InstructionWriter" />.</param>
    </member>
    <member name="P:PostSharp.CodeWeaver.MethodBodyRestructurer.InitializationBlock">
      <summary>
            Gets the block initializing the object (in case the method is a constructor).
            </summary>
    </member>
    <member name="P:PostSharp.CodeWeaver.MethodBodyRestructurer.AfterInitializationBlock">
      <summary>
            Gets the block execute just after the instance is initialized.
            </summary>
      <value>
            An <see cref="T:PostSharp.CodeModel.InstructionBlock" />, or <b>null</b> if the
            method is not a constructor.
            </value>
    </member>
    <member name="P:PostSharp.CodeWeaver.MethodBodyRestructurer.PrincipalBlock">
      <summary>
            Gets the block containing the original code,
            after the object has been initialized.
            </summary>
    </member>
    <member name="P:PostSharp.CodeWeaver.MethodBodyRestructurer.EntryBlock">
      <summary>
            Gets the entry block.
            </summary>
      <remarks>
            The entry block is a block that will be executed <i>before</i>
            any other in the method.
            </remarks>
    </member>
    <member name="P:PostSharp.CodeWeaver.MethodBodyRestructurer.ReturnValueVariable">
      <summary>
            Gets the variable containing the return value in the exit block.
            </summary>
    </member>
    <member name="P:PostSharp.CodeWeaver.MethodBodyRestructurer.ConstructorType">
      <summary>
            Gets the kind of constructor that was passed.
            </summary>
    </member>
    <member name="P:PostSharp.CodeWeaver.MethodBodyRestructurer.ReturnBranchTarget">
      <summary>
            Gets the <see cref="T:PostSharp.CodeModel.InstructionSequence" /> containing the <b>ret</b> instruction.
            </summary>
      <remarks>
            This instruction sequence loads the value of <see cref="P:PostSharp.CodeWeaver.MethodBodyRestructurer.ReturnValueVariable" />, then
            returns to the calling context. When some code in the protected block
            (<see cref="P:PostSharp.CodeWeaver.MethodBodyRestructurer.PrincipalBlock" />) wants to return to the calling context, it cannot
            use directly the <b>ret</b> instruction but should first set the 
            <see cref="P:PostSharp.CodeWeaver.MethodBodyRestructurer.ReturnValueVariable" /> variable (unless the method returns <b>void</b>),
            then use the <b>leave</b> instruction to the <see cref="P:PostSharp.CodeWeaver.MethodBodyRestructurer.ReturnBranchTarget" /> instruction
            sequence.
            </remarks>
    </member>
    <member name="T:PostSharp.CodeWeaver.MethodBodyRestructurerOptions">
      <summary>
            Options for the <see cref="T:PostSharp.CodeWeaver.MethodBodyRestructurer" /> class.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.MethodBodyRestructurerOptions.None">
      <summary>
            Default.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.MethodBodyRestructurerOptions.ChangeReturnInstructions">
      <summary>
            Change <b>ret</b> instructions into branching instructions.
            </summary>
    </member>
    <member name="T:PostSharp.CodeWeaver.ConstructorType">
      <summary>
            Determines whether the instance constructor calls a constructor its own
            class (<b>this</b>) or in the base class (<b>base</b>).
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.ConstructorType.Default">
      <summary>
            Default: <see cref="F:PostSharp.CodeWeaver.ConstructorType.NotAnInstanceConstructor" />.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.ConstructorType.NotAnInstanceConstructor">
      <summary>
            The method is not an instance constructor.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.ConstructorType.CallBase">
      <summary>
            The constructor calls the base class.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.ConstructorType.CallThis">
      <summary>
            The constructor calls the current class.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.ConstructorType.CallNothing">
      <summary>
            The constructor does not call any base constructor (<b>struct</b> constructor).
            </summary>
    </member>
    <member name="T:PostSharp.CodeWeaver.Weaver">
      <summary>
            Weaves advices with main source code.
            </summary>
    </member>
    <member name="M:PostSharp.CodeWeaver.Weaver.#ctor(PostSharp.Extensibility.Project)">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeWeaver.Weaver" />.
            </summary>
      <param name="project">Project to which the new <see cref="T:PostSharp.CodeWeaver.Weaver" /> is assigned.</param>
    </member>
    <member name="M:PostSharp.CodeWeaver.Weaver.IgnoreMethod(PostSharp.CodeModel.MethodDefDeclaration)">
      <summary>
            Specifies that a method should be ignored (skipped) by the <see cref="T:PostSharp.CodeWeaver.Weaver" />.
            </summary>
      <param name="method">A method.</param>
    </member>
    <member name="M:PostSharp.CodeWeaver.Weaver.AddMethodLevelAdvice(PostSharp.CodeWeaver.IAdvice,System.Collections.Generic.IEnumerable{PostSharp.CodeModel.MethodDefDeclaration},PostSharp.CodeWeaver.JoinPointKinds,System.Collections.Generic.IEnumerable{PostSharp.CodeModel.MetadataDeclaration})">
      <summary>
            Adds a method-level advice to the current <see cref="T:PostSharp.CodeWeaver.Weaver" />.
            </summary>
      <param name="advice">An advice.</param>
      <param name="methods">The set of methods to which the advice applies, or
            <b>null</b> if the advice applies to all methods.</param>
      <param name="joinPointKinds">The kinds of join points to which the advice applies.</param>
      <param name="operands">The set of operands to which the advice applies,
            or <b>null</b> if the selected kinds of join points have no operand <i>or</i> if
            the advice applies to all operands.</param>
    </member>
    <member name="M:PostSharp.CodeWeaver.Weaver.AddFieldLevelAdvice(PostSharp.CodeWeaver.IAdvice,PostSharp.CodeWeaver.JoinPointKinds,System.Collections.Generic.IEnumerable{PostSharp.CodeModel.IField})">
      <summary>
            Adds a field-level advice to the current <see cref="T:PostSharp.CodeWeaver.Weaver" />.
            </summary>
      <param name="advice">An advice.</param>
      <param name="joinPointKinds">The kinds of join points to which the advice applies.</param>
      <param name="fields">The set of fields to which the advice applies.</param>
    </member>
    <member name="M:PostSharp.CodeWeaver.Weaver.GeneratePropertyAroundField(PostSharp.CodeModel.FieldDefDeclaration)">
      <summary>
            Informs the weaver that a property should be generated around a field.
            </summary>
      <param name="fieldDef">Field that should be wrapped by a property.</param>
      <remarks>
            If this property is set, the field is made private and renamed, and a property
            with the original name and visibility of the field is created.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeWeaver.Weaver.AddTypeLevelAdvice(PostSharp.CodeWeaver.IAdvice,PostSharp.CodeWeaver.JoinPointKinds,System.Collections.Generic.IEnumerable{PostSharp.CodeModel.TypeDefDeclaration})">
      <summary>
            Adds a type-level advice to the current <see cref="T:PostSharp.CodeWeaver.Weaver" />.
            </summary>
      <param name="advice">An advice.</param>
      <param name="joinPointKinds">The kinds of join points to which the advice applies.</param>
      <param name="types">The set of types to which the advice applies.</param>
    </member>
    <member name="M:PostSharp.CodeWeaver.Weaver.Weave">
      <summary>
            Weave the module to which the current <see cref="T:PostSharp.CodeWeaver.Weaver" /> is related
            using the current set of advices.
            </summary>
      <see cref="M:PostSharp.CodeWeaver.Weaver.AddMethodLevelAdvice(PostSharp.CodeWeaver.IAdvice,System.Collections.Generic.IEnumerable{PostSharp.CodeModel.MethodDefDeclaration},PostSharp.CodeWeaver.JoinPointKinds,System.Collections.Generic.IEnumerable{PostSharp.CodeModel.MetadataDeclaration})" />
      <see cref="M:PostSharp.CodeWeaver.Weaver.AddTypeLevelAdvice(PostSharp.CodeWeaver.IAdvice,PostSharp.CodeWeaver.JoinPointKinds,System.Collections.Generic.IEnumerable{PostSharp.CodeModel.TypeDefDeclaration})" />
    </member>
    <member name="M:PostSharp.CodeWeaver.Weaver.Dispose" />
    <member name="T:PostSharp.CodeWeaver.IAdvice">
      <summary>
            An advice is a class that is able to produce some MSIL code.
            </summary>
      <remarks>
        <para>The <see cref="M:PostSharp.CodeWeaver.IAdvice.RequiresWeave(PostSharp.CodeWeaver.WeavingContext)" /> method determine whether the <see cref="M:PostSharp.CodeWeaver.IAdvice.Weave(PostSharp.CodeWeaver.WeavingContext,PostSharp.CodeModel.InstructionBlock)" />
            method should be called at a given join point.
            </para>
      </remarks>
    </member>
    <member name="M:PostSharp.CodeWeaver.IAdvice.RequiresWeave(PostSharp.CodeWeaver.WeavingContext)">
      <summary>
            Determines whether the current advice requires to be woven on a given join point.
            </summary>
      <param name="context">Weaving context.</param>
      <returns>
        <b>true</b> if the <see cref="M:PostSharp.CodeWeaver.IAdvice.Weave(PostSharp.CodeWeaver.WeavingContext,PostSharp.CodeModel.InstructionBlock)" /> method should be called for
            this join point, otherwise <b>false</b>.</returns>
      <remarks>
            It is theoretically possible for this method to return always <b>false</b>,
            because the <see cref="M:PostSharp.CodeWeaver.IAdvice.Weave(PostSharp.CodeWeaver.WeavingContext,PostSharp.CodeModel.InstructionBlock)" /> method is not obliged to emit any code. However,
            restructuring the method body to make weaving possible is expensive, so the
            <see cref="M:PostSharp.CodeWeaver.IAdvice.RequiresWeave(PostSharp.CodeWeaver.WeavingContext)" /> method should be designed in order to minimize
            the number of useless calls to the <see cref="M:PostSharp.CodeWeaver.IAdvice.Weave(PostSharp.CodeWeaver.WeavingContext,PostSharp.CodeModel.InstructionBlock)" /> method.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeWeaver.IAdvice.Weave(PostSharp.CodeWeaver.WeavingContext,PostSharp.CodeModel.InstructionBlock)">
      <summary>
            Weave the current advice into a given join point, i.e. inject code.
            </summary>
      <param name="context">Context.</param>
      <param name="block">Block where the code has to be injected.</param>
    </member>
    <member name="P:PostSharp.CodeWeaver.IAdvice.Priority">
      <summary>
            Gets the advice priority.
            </summary>
      <remarks>
            This influences the order in which advices are applied to join points, in case
            that many advices are applied to the same join point. In join point of type
            <i>before</i> or <i>instead of</i>, advices are injected with <i>direct</i> order of priority.
            In join point of type <i>after</i>, advices are injected with <i>inverse</i> order of priority.
            </remarks>
    </member>
    <member name="T:PostSharp.CodeWeaver.WeaverTask">
      <summary>
            Pluggable task that executes the <see cref="N:PostSharp.CodeWeaver" />.
            </summary>
      <remarks>
            This task first builds a collection of advices from other tasks implementing
            the <see cref="T:PostSharp.CodeWeaver.IAdviceProvider" /> interface. Then it weaves each method
            using the <see cref="N:PostSharp.CodeWeaver" /> class.
            </remarks>
    </member>
    <member name="T:PostSharp.Extensibility.Task">
      <summary>
            Execution unit of a <see cref="P:PostSharp.Extensibility.Task.Project" />.
            </summary>
      <remarks />
    </member>
    <member name="M:PostSharp.Extensibility.Task.Initialize">
      <summary>
            Initializes the current task.
            </summary>
      <remarks>
            In case that the task is deserialized from XML, this method is called after <see cref="M:PostSharp.Extensibility.Task.Deserialize(System.Xml.XmlElement)" />.
            </remarks>
    </member>
    <member name="M:PostSharp.Extensibility.Task.Deserialize(System.Xml.XmlElement)">
      <summary>
            Deserializes the current task from an XML element.
            </summary>
      <param name="xmlElement">The source XML element.</param>
    </member>
    <member name="M:PostSharp.Extensibility.Task.Validate">
      <summary>
            Determines whether the task configuration (deserialized from the attributes of the
            XML element representing the task instance) is valid.
            </summary>
      <returns>
        <b>true</b> if the task configuration is valid, otherwise <b>false</b>.</returns>
      <remarks>
            If the task configuration is invalid, the method implementation should additionally
            emit an error message.
            </remarks>
    </member>
    <member name="M:PostSharp.Extensibility.Task.Execute">
      <summary>
            Execute the current <see cref="T:PostSharp.Extensibility.Task" />.
            </summary>
      <returns>
        <b>true</b> if the exectution was successful, otherwise <b>false</b>.</returns>
    </member>
    <member name="M:PostSharp.Extensibility.Task.IsRequired">
      <summary>
            Determines whether the current task is required by another task in the project.
            </summary>
      <returns>
        <b>true</b> if the current task is required by another task
            in the project, otherwise <b>false</b>.</returns>
    </member>
    <member name="M:PostSharp.Extensibility.Task.Dispose(System.Boolean)">
      <summary>
            Disposes the resources hold by the current instance.
            </summary>
      <param name="disposing">
        <b>disposing</b> if the current method is called because an
            explicit call of <see cref="M:PostSharp.Extensibility.Task.Dispose" />, or <b>false</b> if the method
            is called by the destructor.</param>
    </member>
    <member name="M:PostSharp.Extensibility.Task.Dispose" />
    <member name="M:PostSharp.Extensibility.Task.Finalize">
      <summary>
            Destructor.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Task.TaskType">
      <summary>
            Gets the task type configuration.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Task.TaskName">
      <summary>
            Gets the task name.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Task.Disabled">
      <summary>
            Determines whether this task is disabled.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Task.ImplicitelyRequired">
      <summary>
            Indicates that this task was implicitely required
            by another task.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Task.Project">
      <summary>
            Gets the <see cref="P:PostSharp.Extensibility.Task.Project" /> to which the current task belongs.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Task.State">
      <summary>
            Gets the state of the current task.
            </summary>
    </member>
    <member name="M:PostSharp.CodeWeaver.WeaverTask.Execute" />
    <member name="T:PostSharp.CodeWeaver.WeavingHelper">
      <summary>
            Provides methods that generate frequently used snippets of IL instructions.
            </summary>
    </member>
    <member name="M:PostSharp.CodeWeaver.WeavingHelper.#ctor(PostSharp.CodeModel.ModuleDeclaration)">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeWeaver.WeavingHelper" />.
            </summary>
      <param name="module">Module into which instructions shall be generated.</param>
    </member>
    <member name="M:PostSharp.CodeWeaver.WeavingHelper.ToObject(PostSharp.CodeModel.ITypeSignature,PostSharp.ModuleWriter.InstructionEmitter)">
      <summary>
            Emits MSIL instructions that cast an object of any type to an object
            (eventually boxed).
            </summary>
      <param name="originalType">Type to be converted.</param>
      <param name="writer">
        <see cref="T:PostSharp.ModuleWriter.InstructionEmitter" /> to which instructions
            have to be written.</param>
    </member>
    <member name="M:PostSharp.CodeWeaver.WeavingHelper.FromObject(PostSharp.CodeModel.ITypeSignature,PostSharp.ModuleWriter.InstructionEmitter)">
      <summary>
            Emits MSIL instructions that cast an object (of type <see cref="T:System.Object" />)
            to a given type, performing unboxing when needed.
            </summary>
      <param name="targetType">Type into which the object has to be converted.</param>
      <param name="writer">
        <see cref="T:PostSharp.ModuleWriter.InstructionEmitter" /> into which instructions
            have to be written.</param>
    </member>
    <member name="M:PostSharp.CodeWeaver.WeavingHelper.MakeArrayOfArguments(PostSharp.CodeModel.MethodDefDeclaration,PostSharp.ModuleWriter.InstructionEmitter)">
      <summary>
            Emit instructions that create a new array of objects (object[]) and fills it with all input arguments,
            but allows the first arguments not to be included in this array.
            </summary>
      <param name="method">Method for which arguments have to be read.</param>
      <param name="writer">An <see cref="T:PostSharp.ModuleWriter.InstructionEmitter" />.</param>
      <remarks>
            Stack transition: ... -&gt; array, ... .
            </remarks>
    </member>
    <member name="M:PostSharp.CodeWeaver.WeavingHelper.MakeArrayOfArguments(PostSharp.CodeModel.MethodDefDeclaration,PostSharp.ModuleWriter.InstructionEmitter,System.Int32)">
      <summary>
            Emit instructions that create a new array of objects (object[]) and fills it with all input arguments,
            but allows the first arguments not to be included in this array,
            </summary>
      <param name="method">Method for which arguments have to be read.</param>
      <param name="writer">An <see cref="T:PostSharp.ModuleWriter.InstructionEmitter" />.</param>
      <param name="firstArgument">Ordinal of the first argument to be loaded into the array.</param>
      <remarks>
            Stack transition: ... -&gt; array, ... .
            </remarks>
    </member>
    <member name="M:PostSharp.CodeWeaver.WeavingHelper.MakeArrayOfArguments(PostSharp.CodeModel.MethodDefDeclaration,PostSharp.ModuleWriter.InstructionEmitter,System.Int32,System.Int32)">
      <summary>
            Emit instructions that create a new array of objects (object[]) and fills it with all input arguments,
            but allows the first arguments and last arguments not to be included in this array,
            </summary>
      <param name="method">Method for which arguments have to be read.</param>
      <param name="writer">An <see cref="T:PostSharp.ModuleWriter.InstructionEmitter" />.</param>
      <param name="firstArgument">Ordinal of the first argument to be loaded into the array.</param>
      <param name="argumentCount">Number of arguments to be loaded into the array.</param>
      <remarks>
            Stack transition: ... -&gt; array, ... .
            </remarks>
    </member>
    <member name="M:PostSharp.CodeWeaver.WeavingHelper.CopyArgumentsFromArray(PostSharp.CodeModel.LocalVariableSymbol,PostSharp.CodeModel.MethodDefDeclaration,PostSharp.ModuleWriter.InstructionEmitter)">
      <summary>
            Emit instructions that create a new array of objects (object[]) and fills it with all input arguments.
            </summary>
      <param name="method">Method for which arguments have to be read.</param>
      <param name="writer">An <see cref="T:PostSharp.ModuleWriter.InstructionEmitter" />.</param>
      <param name="arrayVariable">Local variable of type <c>object[]</c> that contains the array of arguments.</param>
      <remarks>
            Stack transition: ... -&gt; array, ... .
            </remarks>
    </member>
    <member name="M:PostSharp.CodeWeaver.WeavingHelper.CopyArgumentsFromArray(PostSharp.CodeModel.LocalVariableSymbol,PostSharp.CodeModel.MethodDefDeclaration,PostSharp.ModuleWriter.InstructionEmitter,System.Int32)">
      <summary>
            Emits instruction that write the output arguments from the value of an array of arguments (object[]).
            </summary>
      <param name="method">Method for which arguments have to be written.</param>
      <param name="writer">An <see cref="T:PostSharp.ModuleWriter.InstructionEmitter" />.</param>
      <param name="arrayVariable">Local variable of type <c>object[]</c> that contains the array of arguments.</param>
      <param name="firstArgument">Ordinal of the argument corresponding to the first (0) position in the array.</param>
      <remarks>
            Stack transition: ..., array -&gt; ... .
            </remarks>
    </member>
    <member name="M:PostSharp.CodeWeaver.WeavingHelper.MakeArrayOfGenericMethodArguments(PostSharp.CodeModel.MethodDefDeclaration,PostSharp.ModuleWriter.InstructionEmitter)">
      <summary>
            Emits instructions that create a new array of types (Type[]) and fills it with all generic arguments of a given method.
            </summary>
      <param name="method">Method for which generic arguments have to be read.</param>
      <param name="writer">
        <see cref="T:PostSharp.ModuleWriter.InstructionEmitter" />.</param>
      <remarks>
            Stack transition: ... -&gt; array, ... .
            </remarks>
    </member>
    <member name="M:PostSharp.CodeWeaver.WeavingHelper.MakeArrayOfGenericTypeArguments(PostSharp.CodeModel.TypeDefDeclaration,PostSharp.ModuleWriter.InstructionEmitter)">
      <summary>
            Emit instructions that create a new array of types (Type[]) and fills it with all generic arguments of a given type.
            </summary>
      <param name="type">Type for which generic arguments have to be read.</param>
      <param name="writer">An <see cref="T:PostSharp.ModuleWriter.InstructionEmitter" />.</param>
      <remarks>
            Stack transition: ... -&gt; array, ... .
            </remarks>
    </member>
    <member name="M:PostSharp.CodeWeaver.WeavingHelper.EmitCustomAttributeConstruction(PostSharp.CodeModel.IAnnotationValue,PostSharp.ModuleWriter.InstructionEmitter)">
      <summary>
            Emits instructions that construct a custom attribute.
            </summary>
      <param name="attribute">The custom attribute to construct.</param>
      <param name="writer">An <see cref="T:PostSharp.ModuleWriter.InstructionEmitter" />.</param>
      <remarks>
            Stack transition: ... -&gt; Ref(Of <c>attribute.Constructor.DeclaringType</c>), ... .
            </remarks>
    </member>
    <member name="M:PostSharp.CodeWeaver.WeavingHelper.GetDebuggerNonUserCodeAttribute">
      <summary>
            Builds a <see cref="T:PostSharp.CodeModel.CustomAttributeDeclaration" /> representing
            the <see cref="T:System.Diagnostics.DebuggerNonUserCodeAttribute" /> custom attribute.
            </summary>
      <returns>A new instance of <see cref="T:PostSharp.CodeModel.CustomAttributeDeclaration" /> representing
            the <see cref="T:System.Diagnostics.DebuggerNonUserCodeAttribute" /> custom attribute.</returns>
    </member>
    <member name="M:PostSharp.CodeWeaver.WeavingHelper.AddCompilerGeneratedAttribute(PostSharp.CodeModel.Collections.CustomAttributeDeclarationCollection)">
      <summary>
            Builds a <see cref="T:PostSharp.CodeModel.CustomAttributeDeclaration" /> representing
            the <see cref="T:System.Diagnostics.DebuggerNonUserCodeAttribute" /> custom attribute
            and adds it to a <see cref="T:PostSharp.CodeModel.Collections.CustomAttributeDeclarationCollection" />.
            </summary>
    </member>
    <member name="M:PostSharp.CodeWeaver.WeavingHelper.GetCompilerGeneratedAttribute">
      <summary>
            Builds a <see cref="T:PostSharp.CodeModel.CustomAttributeDeclaration" /> representing
            the <see cref="T:System.Diagnostics.DebuggerNonUserCodeAttribute" /> custom attribute.
            </summary>
      <returns>A new instance of <see cref="T:PostSharp.CodeModel.CustomAttributeDeclaration" /> representing
            the <see cref="T:System.Diagnostics.DebuggerNonUserCodeAttribute" /> custom attribute.</returns>
    </member>
    <member name="M:PostSharp.CodeWeaver.WeavingHelper.GetRuntimeType(PostSharp.CodeModel.ITypeSignature,PostSharp.ModuleWriter.InstructionEmitter)">
      <summary>
            Emits instruction that load a runtime type (<see cref="T:System.Type" />) on the stack.
            </summary>
      <param name="type">The type to load on the stack.</param>
      <param name="writer">An <see cref="T:PostSharp.ModuleWriter.InstructionEmitter" /></param>
      <remarks>
            Stack transition: ... -&gt; Ref(Of <see cref="T:System.Type" />), ... .
            </remarks>
    </member>
    <member name="M:PostSharp.CodeWeaver.WeavingHelper.GetRuntimeField(PostSharp.CodeModel.IField,PostSharp.ModuleWriter.InstructionEmitter)">
      <summary>
            Emits instruction that load a runtime field (<see cref="T:System.Reflection.FieldInfo" />) on the stack.
            </summary>
      <param name="field">The field to load on the stack.</param>
      <param name="writer">An <see cref="T:PostSharp.ModuleWriter.InstructionEmitter" /></param>
      <remarks>
            Stack transition: ... -&gt; Ref(Of <see cref="T:System.Reflection.FieldInfo" />), ... .
            </remarks>
    </member>
    <member name="M:PostSharp.CodeWeaver.WeavingHelper.GetRuntimeMethod(PostSharp.CodeModel.IMethod,PostSharp.ModuleWriter.InstructionEmitter)">
      <summary>
            Emits instruction that load a runtime method (<see cref="T:System.Reflection.MethodBase" />) on the stack.
            </summary>
      <param name="method">The method to load on the stack.</param>
      <param name="writer">An <see cref="T:PostSharp.ModuleWriter.InstructionEmitter" /></param>
      <remarks>
            Stack transition: ... -&gt; Ref(Of <see cref="T:System.Reflection.MethodBase" />), ... .
            </remarks>
    </member>
    <member name="M:PostSharp.CodeWeaver.WeavingHelper.WriteLine(System.String,PostSharp.ModuleWriter.InstructionEmitter,System.Object[])">
      <summary>
            Emits instructions that write a line using <see cref="M:System.Console.WriteLine(System.String)" />.
            </summary>
      <param name="format">Formatting string.</param>
      <param name="writer">An <see cref="T:PostSharp.ModuleWriter.InstructionEmitter" />.</param>
      <param name="parameters">Arguments of the formatting string.</param>
    </member>
    <member name="M:PostSharp.CodeWeaver.WeavingHelper.RedirectReturnInstructions(PostSharp.CodeModel.InstructionReader,PostSharp.CodeModel.InstructionWriter,PostSharp.CodeModel.InstructionBlock,PostSharp.CodeModel.InstructionSequence,PostSharp.CodeModel.LocalVariableSymbol,System.Boolean)">
      <summary>
            Transforms an <see cref="T:PostSharp.CodeModel.InstructionBlock" /> so that it can be protected
            and decorated with exception handlers. This method does not add the
            handlers in themselves.
            </summary>
      <param name="reader">An <see cref="T:PostSharp.CodeModel.InstructionReader" /> assigned to
            the method of the current <see cref="T:PostSharp.CodeModel.InstructionBlock" />.</param>
      <param name="writer">An available <see cref="T:PostSharp.CodeModel.InstructionWriter" />.</param>
      <param name="block">An <see cref="T:PostSharp.CodeModel.InstructionBlock" /> attached to
            a method.</param>
      <param name="returnSequence">An <see cref="T:PostSharp.CodeModel.InstructionSequence" /> located
            outside <paramref name="block" />, containing the instructions <c>ldloc
            <paramref name="returnValueVariable" />; ret</c>.
            <param name="useLeave"><b>true</b> if <b>leave</b> instructions should be
            used instead of <b>ret</b>, <b>false</b> to use <b>br</b> instructions.</param></param>
      <param name="returnValueVariable">A <see cref="T:PostSharp.CodeModel.LocalVariableSymbol" /> where
            the return value will be stored before the control will be directed
            to <paramref name="returnSequence" />.</param>
      <remarks>
        <para>
            The only branching instruction allowed to leave a protected block
            is the <b>leave</b> instruction. This method should change all branching
            instructions to <b>leave</b>. 
            </para>
        <para>
            The current implementation of the current method is only able to transform
            <b>ret</b> instructions, i.e. it assumes that all branch targets
            are internal to the block to protect.
            </para>
      </remarks>
    </member>
    <member name="M:PostSharp.CodeWeaver.WeavingHelper.AddExceptionHandlers(PostSharp.CodeModel.InstructionWriter,PostSharp.CodeModel.InstructionBlock,PostSharp.CodeModel.InstructionSequence,PostSharp.CodeModel.ITypeSignature[],System.Boolean,PostSharp.CodeModel.InstructionBlock@,PostSharp.CodeModel.InstructionBlock[]@,PostSharp.CodeModel.InstructionBlock@)">
      <summary>
            Adds exception handlers to an <see cref="T:PostSharp.CodeModel.InstructionBlock" />.
            </summary>
      <param name="writer">An available <see cref="T:PostSharp.CodeModel.InstructionWriter" />.</param>
      <param name="block">The <see cref="T:PostSharp.CodeModel.InstructionBlock" /> to which handlers have to be added. This block should be safe
            for being nested in an exception handler (see the <see cref="M:PostSharp.CodeWeaver.WeavingHelper.RedirectReturnInstructions(PostSharp.CodeModel.InstructionReader,PostSharp.CodeModel.InstructionWriter,PostSharp.CodeModel.InstructionBlock,PostSharp.CodeModel.InstructionSequence,PostSharp.CodeModel.LocalVariableSymbol,System.Boolean)" /> method).</param>
      <param name="leaveSequence">The branching target that should be used to jump out of the protected block
            (typically a sequence located just after this block).</param>
      <param name="catchExceptionTypes">An array of types for which typed <b>catch</b> handlers should be generated,
            or <b>null</b> or an empty array if no <b>catch</b> handler should be generated.</param>
      <param name="includeFinallyBlock">
        <b>true</b> whether a <b>finally</b> handler should be added, otherwise <b>false</b>.</param>
      <param name="protectedBlock">At output, an <see cref="T:PostSharp.CodeModel.InstructionBlock" /> containing the initial block and its handlers.</param>
      <param name="catchBlocks">At output, an array of blocks where the instructions of <b>catch</b> handler can be emitted. The <b>leave</b>
            instruction is already emitted, so user code should not do it a second time. <b>null</b> if no <b>catch</b> handler was requested.</param>
      <param name="finallyBlock">At output, an <see cref="T:PostSharp.CodeModel.InstructionBlock" /> where the instruction of the <b>finally</b> handler
            can be emitted. The <b>endfinally</b> instruction is already emitted, so user code should not do it a second time. 
            <b>null</b> if no <b>finally</b> handler was requested.</param>
      <remarks>
        <para>The method body is modified in such a way that the <b>finally</b> handler protects also the <b>catch</b> handlers.
            That is, if an exception is thrown from a <b>catch</b> handler, the <b>finally</b> handler will be invoked.
            </para>
      </remarks>
    </member>
    <member name="T:PostSharp.Collections.AppendingSortedList`2">
      <summary>
            Sorted list optimized to situations when items
            are added in the right order (from the smallest to the greatest).
            </summary>
      <typeparam name="TKey">Type of keys.</typeparam>
      <typeparam name="TValue">Type of values.</typeparam>
    </member>
    <member name="M:PostSharp.Collections.AppendingSortedList`2.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Collections.AppendingSortedList`2" /> with default capacity.
            </summary>
    </member>
    <member name="M:PostSharp.Collections.AppendingSortedList`2.#ctor(System.Int32)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Collections.AppendingSortedList`2" /> with given initial capacity.
            </summary>
      <param name="capacity">capacity</param>
    </member>
    <member name="M:PostSharp.Collections.AppendingSortedList`2.Add(`0,`1)" />
    <member name="M:PostSharp.Collections.AppendingSortedList`2.ContainsKey(`0)" />
    <member name="M:PostSharp.Collections.AppendingSortedList`2.Remove(`0)" />
    <member name="M:PostSharp.Collections.AppendingSortedList`2.TryGetValue(`0,`1@)" />
    <member name="M:PostSharp.Collections.AppendingSortedList`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})" />
    <member name="M:PostSharp.Collections.AppendingSortedList`2.Clear" />
    <member name="M:PostSharp.Collections.AppendingSortedList`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})" />
    <member name="M:PostSharp.Collections.AppendingSortedList`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)" />
    <member name="M:PostSharp.Collections.AppendingSortedList`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})" />
    <member name="M:PostSharp.Collections.AppendingSortedList`2.GetEnumerator" />
    <member name="P:PostSharp.Collections.AppendingSortedList`2.Capacity">
      <summary>
            Gets ot sets the list capacity.
            </summary>
    </member>
    <member name="P:PostSharp.Collections.AppendingSortedList`2.Keys" />
    <member name="P:PostSharp.Collections.AppendingSortedList`2.Values" />
    <member name="P:PostSharp.Collections.AppendingSortedList`2.Item(`0)" />
    <member name="P:PostSharp.Collections.AppendingSortedList`2.Count" />
    <member name="P:PostSharp.Collections.AppendingSortedList`2.IsReadOnly" />
    <member name="T:PostSharp.Collections.AppendingSortedListFactory`2">
      <summary>
            Factory of <see cref="T:PostSharp.Collections.AppendingSortedList`2" />.
            </summary>
      <typeparam name="TKey">Type of keys.</typeparam>
      <typeparam name="TValue">Type of values.</typeparam>
    </member>
    <member name="T:PostSharp.Collections.IDictionaryFactory`2">
      <summary>
            A dictionary factory creates instances of collections
            and allocates capacity.
            </summary>
      <typeparam name="TKey">Type of keys.</typeparam>
      <typeparam name="TValue">Type of values.</typeparam>
    </member>
    <member name="M:PostSharp.Collections.IDictionaryFactory`2.CreateDictionary">
      <summary>
            Creates a dictionary with default capacity.
            </summary>
      <returns>A dictionary.</returns>
    </member>
    <member name="M:PostSharp.Collections.IDictionaryFactory`2.CreateDictionary(System.Int32)">
      <summary>
            Creates a dictionary with given capacity.
            </summary>
      <param name="capacity">Initial dictionary capacity.</param>
      <returns>A dictionary.</returns>
    </member>
    <member name="M:PostSharp.Collections.IDictionaryFactory`2.EnsureCapacity(System.Collections.Generic.IDictionary{`0,`1},System.Int32)">
      <summary>
            Ensures that a dictionary has the given capacity.
            </summary>
      <param name="dictionary">A dictionary.</param>
      <param name="capacity">The required capacity.</param>
    </member>
    <member name="F:PostSharp.Collections.AppendingSortedListFactory`2.Default">
      <summary>
            Default instance.
            </summary>
    </member>
    <member name="T:PostSharp.Collections.CollectionDebugViewer">
      <summary>
            Debugger viewer that presents any collection (<see cref="T:System.Collections.ICollection" />)
            according to its semantics instead of its implementation, i.e. it displays
            the list of items exposed by the interface.
            </summary>
    </member>
    <member name="M:PostSharp.Collections.CollectionDebugViewer.#ctor(System.Collections.ICollection)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Collections.CollectionDebugViewer" />.
            </summary>
      <param name="collection">The collection to be viewed.</param>
    </member>
    <member name="P:PostSharp.Collections.CollectionDebugViewer.Items">
      <summary>
            Gets the array of items.
            </summary>
      <remarks>
            This array is displayed as the content of the collection.
            </remarks>
    </member>
    <member name="P:PostSharp.Collections.CollectionDebugViewer.Count">
      <summary>
            Gets the number of elements in the collection.
            </summary>
    </member>
    <member name="T:PostSharp.Collections.SortedDictionaryFactory`2">
      <summary>
            Factory of <see cref="T:System.Collections.Generic.Dictionary`2" />.
            </summary>
      <typeparam name="TKey">Type of keys.</typeparam>
      <typeparam name="TValue">Type of values.</typeparam>
    </member>
    <member name="F:PostSharp.Collections.SortedDictionaryFactory`2.Default">
      <summary>
            Default instance (using the default equality comparer).
            </summary>
    </member>
    <member name="M:PostSharp.Collections.SortedDictionaryFactory`2.#ctor(System.Collections.Generic.IComparer{`0})" />
    <member name="M:PostSharp.Collections.SortedDictionaryFactory`2.CreateDictionary" />
    <member name="M:PostSharp.Collections.SortedDictionaryFactory`2.CreateDictionary(System.Int32)" />
    <member name="M:PostSharp.Collections.SortedDictionaryFactory`2.EnsureCapacity(System.Collections.Generic.IDictionary{`0,`1},System.Int32)" />
    <member name="M:PostSharp.Collections.SortedDictionaryFactory`2.CreateCollection" />
    <member name="M:PostSharp.Collections.SortedDictionaryFactory`2.CreateCollection(System.Int32)" />
    <member name="M:PostSharp.Collections.SortedDictionaryFactory`2.EnsureCapacity(System.Collections.Generic.ICollection{System.Collections.Generic.KeyValuePair{`0,`1}},System.Int32)" />
    <member name="T:PostSharp.Collections.DictionaryFactory`2">
      <summary>
            Factory of <see cref="T:System.Collections.Generic.Dictionary`2" />.
            </summary>
      <typeparam name="TKey">Type of keys.</typeparam>
      <typeparam name="TValue">Type of values.</typeparam>
    </member>
    <member name="F:PostSharp.Collections.DictionaryFactory`2.Default">
      <summary>
            Default instance (using the default equality comparer).
            </summary>
    </member>
    <member name="M:PostSharp.Collections.DictionaryFactory`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})" />
    <member name="M:PostSharp.Collections.DictionaryFactory`2.CreateDictionary" />
    <member name="M:PostSharp.Collections.DictionaryFactory`2.CreateDictionary(System.Int32)" />
    <member name="M:PostSharp.Collections.DictionaryFactory`2.EnsureCapacity(System.Collections.Generic.IDictionary{`0,`1},System.Int32)" />
    <member name="M:PostSharp.Collections.DictionaryFactory`2.CreateCollection" />
    <member name="M:PostSharp.Collections.DictionaryFactory`2.CreateCollection(System.Int32)" />
    <member name="M:PostSharp.Collections.DictionaryFactory`2.EnsureCapacity(System.Collections.Generic.ICollection{System.Collections.Generic.KeyValuePair{`0,`1}},System.Int32)" />
    <member name="T:PostSharp.Collections.EmptyArray`1">
      <summary>
            Provides empty arrays of any type.
            </summary>
      <typeparam name="T" />
    </member>
    <member name="M:PostSharp.Collections.EmptyArray`1.GetInstance">
      <summary>
            Gets an empty array of type <b><typeparamref name="T" />[]</b>.
            </summary>
      <returns>An empty array of type <b><typeparamref name="T" />[]</b>.</returns>
    </member>
    <member name="T:PostSharp.Collections.EmptyCollection`1">
      <summary>
            An empty and read-only collection.
            </summary>
      <typeparam name="T">Type of items.</typeparam>
      <remarks>
            This collection is useful when one has to return an empty collection
            and cannot return <b>null</b>.
            </remarks>
    </member>
    <member name="M:PostSharp.Collections.EmptyCollection`1.GetInstance">
      <summary>
            Gets an empty and read-only collection.
            </summary>
      <returns>An empty and read-only collection</returns>
    </member>
    <member name="T:PostSharp.Collections.EmptyEnumerator`1">
      <summary>
            An enumerator over an empty collection.
            </summary>
      <typeparam name="T">Type of enumerated items.</typeparam>
    </member>
    <member name="M:PostSharp.Collections.EmptyEnumerator`1.GetInstance">
      <summary>
            Get an enumerator over an empty collection.
            </summary>
      <returns>An enumerator over an empty collection.</returns>
    </member>
    <member name="M:PostSharp.Collections.EmptyEnumerator`1.Dispose" />
    <member name="M:PostSharp.Collections.EmptyEnumerator`1.MoveNext" />
    <member name="M:PostSharp.Collections.EmptyEnumerator`1.Reset" />
    <member name="P:PostSharp.Collections.EmptyEnumerator`1.Current" />
    <member name="T:PostSharp.Collections.EnumerableWrapper`1">
      <summary>
            Wraps an <see cref="T:System.Collections.Generic.IEnumerable`1" /> so that the object
            behind becoms inaccessible, that is, read-only.
            </summary>
      <typeparam name="T">Type of items.</typeparam>
    </member>
    <member name="M:PostSharp.Collections.EnumerableWrapper`1.GetInstance(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Wraps an enumerable into a read-only enumerable. The original
            enumerable becomes inaccessible.
            </summary>
      <param name="inner">The inner enumerable.</param>
      <returns>An equivalent enumerable.</returns>
      <remarks>
            When PostSharp is compiled not compiled in debug mode, this method
            simply returns <paramref name="inner" />.
            </remarks>
    </member>
    <member name="M:PostSharp.Collections.EnumerableWrapper`1.GetEnumerator" />
    <member name="T:PostSharp.Collections.EnumeratorEnlarger">
      <summary>
            Provides a method that casts a enumerator of a specific type into
            an enumerator of a more general type.
            </summary>
    </member>
    <member name="M:PostSharp.Collections.EnumeratorEnlarger.EnlargeEnumerator``2(System.Collections.Generic.IEnumerator{``0})">
      <summary>
            Casts an enumerator <see cref="T:System.Collections.Generic.IEnumerator`1" />&lt;<typeparamref name="TSource" />&gt; into
            <see cref="T:System.Collections.Generic.IEnumerator`1" />&lt;<typeparamref name="TTarget" />&gt;, where
            <typeparamref name="TTarget" /> is derived from <typeparamref name="TSource" />.
            </summary>
      <typeparam name="TSource">Source type of enumerated items.</typeparam>
      <typeparam name="TTarget">Target type of enumerated items (should be derived from
            <typeparamref name="TSource" />).</typeparam>
      <param name="sourceEnumerator">Enumerator to be enlarged.</param>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerator`1" />&lt;<typeparamref name="TTarget" />&gt;
            that maps <paramref name="sourceEnumerator" />.</returns>
    </member>
    <member name="M:PostSharp.Collections.EnumeratorEnlarger.EnlargeEnumerable``2(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Casts an enumerable <see cref="T:System.Collections.Generic.IEnumerable`1" />&lt;<typeparamref name="TSource" />&gt; into
            <see cref="T:System.Collections.Generic.IEnumerable`1" />&lt;<typeparamref name="TTarget" />&gt;, where
            <typeparamref name="TTarget" /> is derived from <typeparamref name="TSource" />.
            </summary>
      <typeparam name="TSource">Source type of enumerated items.</typeparam>
      <typeparam name="TTarget">Target type of enumerated items (should be derived from
            <typeparamref name="TSource" />).</typeparam>
      <param name="sourceEnumerable">Enumerator to be enlarged.</param>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" />&lt;<typeparamref name="TTarget" />&gt;
            that maps <paramref name="sourceEnumerable" />.</returns>
    </member>
    <member name="T:PostSharp.Collections.FastStringComparer">
      <summary>
            Efficient implementation of an <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> of strings.
            </summary>
    </member>
    <member name="F:PostSharp.Collections.FastStringComparer.Instance">
      <summary>
            Singleton instance.
            </summary>
    </member>
    <member name="M:PostSharp.Collections.FastStringComparer.Equals(System.String,System.String)" />
    <member name="M:PostSharp.Collections.FastStringComparer.GetHashCode(System.String)" />
    <member name="T:PostSharp.Collections.IListFactory`1">
      <summary>
            A list factory creates instances of lists
            and allocates capacity.
            </summary>
      <typeparam name="T">Type of items in the list.</typeparam>
    </member>
    <member name="M:PostSharp.Collections.IListFactory`1.CreateList">
      <summary>
            Creates a list with default capacity.
            </summary>
      <returns>A list.</returns>
    </member>
    <member name="M:PostSharp.Collections.IListFactory`1.CreateList(System.Int32)">
      <summary>
            Creates a list with given capacity.
            </summary>
      <param name="capacity">Initial list capacity.</param>
      <returns>A collection.</returns>
    </member>
    <member name="M:PostSharp.Collections.IListFactory`1.EnsureCapacity(System.Collections.Generic.IList{`0},System.Int32)">
      <summary>
            Ensures that a list has the given capacity.
            </summary>
      <param name="list">A list.</param>
      <param name="capacity">The required capacity.</param>
    </member>
    <member name="T:PostSharp.Collections.Visitor`1">
      <summary>
            Signature of the method that should be called by <see cref="M:PostSharp.Collections.IVisitable`1.Visit(System.String,PostSharp.Collections.Visitor{`0})" />.
            </summary>
      <typeparam name="T">Type of items that should be visited.</typeparam>
      <param name="owner">Object owning the visited item.</param>
      <param name="role">Role of the visited item</param>
      <param name="item">Visited item.</param>
    </member>
    <member name="T:PostSharp.Collections.ListFactory`1">
      <summary>
            Factory of <see cref="T:System.Collections.Generic.List`1" />.
            </summary>
      <typeparam name="T">Type of list items.</typeparam>
    </member>
    <member name="F:PostSharp.Collections.ListFactory`1.Default">
      <summary>
            Singleton instance.
            </summary>
    </member>
    <member name="M:PostSharp.Collections.ListFactory`1.CreateList" />
    <member name="M:PostSharp.Collections.ListFactory`1.CreateList(System.Int32)" />
    <member name="M:PostSharp.Collections.ListFactory`1.EnsureCapacity(System.Collections.Generic.IList{`0},System.Int32)">
      <summary>
            Ensures that a list has the given capacity.
            </summary>
      <param name="list">A list.</param>
      <param name="capacity">The required capacity.</param>
    </member>
    <member name="M:PostSharp.Collections.ListFactory`1.CreateCollection" />
    <member name="M:PostSharp.Collections.ListFactory`1.CreateCollection(System.Int32)" />
    <member name="M:PostSharp.Collections.ListFactory`1.EnsureCapacity(System.Collections.Generic.ICollection{`0},System.Int32)">
      <summary>
            Ensures that a collection has the given capacity.
            </summary>
      <param name="collection">A collection.</param>
      <param name="capacity">The required capacity.</param>
    </member>
    <member name="T:PostSharp.Collections.MarshalByRefEnumerator`1">
      <summary>
            Wraps an enumerator with a class derived from <see cref="T:System.MarshalByRefObject" />,
            so that the enumerator can be used across application domain boundaries.
            </summary>
      <typeparam name="T">Type of enumerated elements.</typeparam>
    </member>
    <member name="M:PostSharp.Collections.MarshalByRefEnumerator`1.#ctor(System.Collections.Generic.IEnumerator{`0})">
      <summary>
            Initializes a new <see cref="T:PostSharp.Collections.MarshalByRefEnumerator`1" />.
            </summary>
      <param name="enumerator">Underlying enumerator.</param>
    </member>
    <member name="M:PostSharp.Collections.MarshalByRefEnumerator`1.Dispose" />
    <member name="M:PostSharp.Collections.MarshalByRefEnumerator`1.MoveNext" />
    <member name="M:PostSharp.Collections.MarshalByRefEnumerator`1.Reset" />
    <member name="P:PostSharp.Collections.MarshalByRefEnumerator`1.Current" />
    <member name="T:PostSharp.Collections.NodePosition">
      <summary>
            Relative position of nodes in a sequence.
            </summary>
    </member>
    <member name="F:PostSharp.Collections.NodePosition.Before">
      <summary>
            Before the reference node.
            </summary>
    </member>
    <member name="F:PostSharp.Collections.NodePosition.After">
      <summary>
            After the reference node.
            </summary>
    </member>
    <member name="T:PostSharp.Collections.NonNullableList`1">
      <summary>
            Wraps a list so that it is forbidden to add null items.
            </summary>
      <typeparam name="T">Type of items.</typeparam>
    </member>
    <member name="M:PostSharp.Collections.NonNullableList`1.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Collections.NonNullableList`1" /> with default capacity.
            </summary>
    </member>
    <member name="M:PostSharp.Collections.NonNullableList`1.#ctor(System.Int32)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Collections.NonNullableList`1" /> with given initial capacity.
            </summary>
      <param name="capacity">Initial capacity.</param>
    </member>
    <member name="M:PostSharp.Collections.NonNullableList`1.#ctor(System.Collections.Generic.ICollection{`0})">
      <summary>
            Initializes a new <see cref="T:PostSharp.Collections.NonNullableList`1" /> and copies the content of 
            an existing collection.
            </summary>
      <param name="items">The collection to be copied.</param>
    </member>
    <member name="M:PostSharp.Collections.NonNullableList`1.AddRange(System.Collections.Generic.ICollection{`0})">
      <summary>
            Adds a collection of items in the list.
            </summary>
      <param name="items">The collection of items to be added.</param>
    </member>
    <member name="M:PostSharp.Collections.NonNullableList`1.Add(`0)" />
    <member name="M:PostSharp.Collections.NonNullableList`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Adds a set of items to the current collection.
            </summary>
      <param name="items">A set of items.</param>
    </member>
    <member name="M:PostSharp.Collections.NonNullableList`1.Clear" />
    <member name="M:PostSharp.Collections.NonNullableList`1.Contains(`0)" />
    <member name="M:PostSharp.Collections.NonNullableList`1.CopyTo(`0[],System.Int32)" />
    <member name="M:PostSharp.Collections.NonNullableList`1.Remove(`0)" />
    <member name="M:PostSharp.Collections.NonNullableList`1.GetEnumerator" />
    <member name="M:PostSharp.Collections.NonNullableList`1.IndexOf(`0)" />
    <member name="M:PostSharp.Collections.NonNullableList`1.Insert(System.Int32,`0)" />
    <member name="M:PostSharp.Collections.NonNullableList`1.RemoveAt(System.Int32)" />
    <member name="P:PostSharp.Collections.NonNullableList`1.Capacity">
      <summary>
            Gets or sets the capacity of the current list.
            </summary>
    </member>
    <member name="P:PostSharp.Collections.NonNullableList`1.Count" />
    <member name="P:PostSharp.Collections.NonNullableList`1.IsReadOnly" />
    <member name="P:PostSharp.Collections.NonNullableList`1.Item(System.Int32)" />
    <member name="T:PostSharp.Collections.UnionCollection`1">
      <summary>
            Wrapper that exposes the union of two collections as a single collection.
            </summary>
      <typeparam name="ItemType" />
    </member>
    <member name="M:PostSharp.Collections.UnionCollection`1.#ctor(System.Collections.Generic.ICollection{`0},System.Collections.Generic.ICollection{`0})">
      <summary>
            Initializes a new <see cref="T:PostSharp.Collections.UnionCollection`1" />.
            </summary>
      <param name="first">A collection.</param>
      <param name="second">A collection.</param>
    </member>
    <member name="M:PostSharp.Collections.UnionCollection`1.Add(`0)" />
    <member name="M:PostSharp.Collections.UnionCollection`1.Clear" />
    <member name="M:PostSharp.Collections.UnionCollection`1.Contains(`0)" />
    <member name="M:PostSharp.Collections.UnionCollection`1.CopyTo(`0[],System.Int32)" />
    <member name="M:PostSharp.Collections.UnionCollection`1.Remove(`0)" />
    <member name="M:PostSharp.Collections.UnionCollection`1.GetEnumerator" />
    <member name="P:PostSharp.Collections.UnionCollection`1.Count" />
    <member name="P:PostSharp.Collections.UnionCollection`1.IsReadOnly" />
    <member name="T:PostSharp.Extensibility.AssembleOptions">
      <summary>
            Options of the <see cref="T:PostSharp.PlatformAbstraction.TargetPlatformAdapter" />.<see cref="M:PostSharp.PlatformAbstraction.TargetPlatformAdapter.Assemble(PostSharp.CodeModel.ModuleDeclaration,PostSharp.Extensibility.AssembleOptions)" /> method.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.AssembleOptions.#ctor(System.String,System.String)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.AssembleOptions" />.
            </summary>
      <param name="sourceFile">Source file.</param>
      <param name="targetFile">Target file.</param>
    </member>
    <member name="P:PostSharp.Extensibility.AssembleOptions.DebugOptions">
      <summary>
            Gets ot sets the debug options.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.AssembleOptions.UnmanagedResourceFile">
      <summary>
            Gets or sets the path of the file containing unmanaged resources in .RES format.
            </summary>
      <value>
            A complete file path, or <b>null</b> if the module does not contain unmanaged resources.
            </value>
    </member>
    <member name="P:PostSharp.Extensibility.AssembleOptions.SourceFile">
      <summary>
            Gets or sets the path of the source file.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.AssembleOptions.TargetFile">
      <summary>
            Gets or sets the path of the target file.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.AssembleOptions.SignAssembly">
      <summary>
            Determines whether the assembly should be signed using a digital key.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.AssembleOptions.PrivateKeyLocation">
      <summary>
            If <see cref="P:PostSharp.Extensibility.AssembleOptions.SignAssembly" /> is <b>true</b>, full path of the key
            file that should be used to sign the assembly. If the key should not
            be taken from a file, but from a key repository, this property
            should start with an '<b>@</b>' sign.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.DebugOption">
      <summary>
            Determines how debugging will be supported for
            the target module. 
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.DebugOption.Auto">
      <summary>
            Determines automatically (<see cref="F:PostSharp.Extensibility.DebugOption.Pdb" /> if the
            source module has debugging information, otherwise
            <see cref="F:PostSharp.Extensibility.DebugOption.None" />.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.DebugOption.Pdb">
      <summary>
            Create a PDB file.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.DebugOption.None">
      <summary>
            No support for debugging.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.AutoUpdate">
      <summary>
            Checks whether newer versions of PostSharp or other related are available and
            write a warning if so.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.AutoUpdate.BeginRetrieveMessages">
      <summary>
            Executes <see cref="M:PostSharp.Extensibility.AutoUpdate.GetAutoUpdateMessages" /> in a new thread. Gives the
            opportunity to the caller to kill the thread if it does not finish in time.
            </summary>
      <returns>The thread in which the <see cref="M:PostSharp.Extensibility.AutoUpdate.GetAutoUpdateMessages" />
            method runs.</returns>
    </member>
    <member name="M:PostSharp.Extensibility.AutoUpdate.StopRetrieveMessages">
      <summary>
            Interrupts the process initiated by the <see cref="M:PostSharp.Extensibility.AutoUpdate.BeginRetrieveMessages" />
            method.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.AutoUpdate.GetAutoUpdateMessages">
      <summary>
            Checks whether newer versions of PostSharp or other related are available and
            write a warning if so.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.CompilerWorkarounds">
      <summary>
            Some hard-coded workarounds of some compiler's behaviours.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.CompilerWorkarounds.IsCompilerGenerated(PostSharp.CodeModel.TypeDefDeclaration)">
      <summary>
            Determines whether a <see cref="T:PostSharp.CodeModel.TypeDefDeclaration" /> is generated by the compiler.
            </summary>
      <param name="type">Type.</param>
      <returns>
        <b>true</b> if the <paramref name="type" /> has been generated by the compiler,
            otherwise <b>false</b>.</returns>
      <remarks>
            Normally, a compiler should annotate the artefacts it generates by the 
            <see cref="T:System.Runtime.CompilerServices.CompilerGeneratedAttribute" />. However, there are some exceptions requiring
            hard coding implemented in this this method.
            </remarks>
    </member>
    <member name="M:PostSharp.Extensibility.CompilerWorkarounds.IsCompilerGenerated(PostSharp.CodeModel.MetadataDeclaration)">
      <summary>
            Determines whether a <see cref="T:PostSharp.CodeModel.Declaration" /> is generated by the compiler.
            </summary>
      <param name="declaration">A declaration.</param>
      <returns>
        <b>true</b> if the <paramref name="declaration" /> has been generated by the compiler,
            otherwise <b>false</b>.</returns>
      <remarks>
            Normally, a compiler should annotate the artefacts it generates by the 
            <see cref="T:System.Runtime.CompilerServices.CompilerGeneratedAttribute" />. However, there are some exceptions requiring
            hard coding implemented in this this method.
            </remarks>
    </member>
    <member name="T:PostSharp.Extensibility.ConfigurablePropertyAttribute">
      <summary>
            Custom attribute that, then applied on a property of a class derived
            from <see cref="T:PostSharp.Extensibility.Task" />, specifies that this property is configurable
            as an XML attribute in the XML project file.
            </summary>
      <remarks>
            Configurable properties may be of one of the following types: enumeration,
            <see cref="T:System.DateTime" />, or any type implementing <see cref="T:System.IConvertible" />.
            </remarks>
    </member>
    <member name="M:PostSharp.Extensibility.ConfigurablePropertyAttribute.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.ConfigurablePropertyAttribute" />, specifying
            that the property is not required.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.ConfigurablePropertyAttribute.#ctor(System.Boolean)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.ConfigurablePropertyAttribute" />, and specifies
            whether the property is required or not.
            </summary>
      <param name="required" />
    </member>
    <member name="P:PostSharp.Extensibility.ConfigurablePropertyAttribute.Required">
      <summary>
            Determines whether the property is required.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.Configuration.ApplicationConfiguration">
      <summary>
            Application-level configuration.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.Configuration.BaseConfiguration">
      <summary>
            Elements of configuration that are common to the application-level,
            plugin-level and project-level configuration.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.Configuration.ConfigurationElement">
      <summary>
            Base class for all configuration elements.
            </summary>
      <remarks>
            This class provides access to parent elements.
            </remarks>
    </member>
    <member name="M:PostSharp.Extensibility.Configuration.ConfigurationElement.Validate">
      <summary>
            Validates the current configuration element.
            </summary>
      <returns>
        <b>true</b> if the current configuration element is valid,
            otherwise <b>false</b>.</returns>
      <remarks>
            This method should writer errors (and warnings) to the current <see cref="T:PostSharp.Extensibility.Messenger" />.
            It should validate child configuration elements recursively.
            </remarks>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.ConfigurationElement.Parent">
      <summary>
            Gets the parent configuration element.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.ConfigurationElement.Root">
      <summary>
            Gets the root configuration element.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Configuration.BaseConfiguration.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.Configuration.BaseConfiguration" />.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.BaseConfiguration.FileName">
      <summary>
            Gets or sets the name of the file declaring the current configuration.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.BaseConfiguration.SearchPath">
      <summary>
            Gets or sets the collection of directories to be added to the search path.
            </summary>
      <value>
            A collection of directories given either absolutely either relatively
            to the declaring file.
            </value>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.BaseConfiguration.UsedPlugIns">
      <summary>
            Gets or sets the collection of plug-ins to be included in the project.
            </summary>
      <value>
            A collection of plug-in configuration file names given either absolutely
            either relatively to the declaring file.
            </value>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.BaseConfiguration.TaskTypes">
      <summary>
            Gets or sets the collection of task types defined in the current file.
            </summary>
      <value>
            A collection of task types (<see cref="T:PostSharp.Extensibility.Configuration.TaskTypeConfiguration" />).
            </value>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.BaseConfiguration.Platforms">
      <summary>
            Gets or sets the collection of platforms defined in the current file.
            </summary>
      <value>
            A collection of platforms (<see cref="T:PostSharp.Extensibility.Configuration.PlatformConfiguration" />).
            </value>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.BaseConfiguration.Properties">
      <summary>
            Gets or sets the collection of properties defined in the current file.
            </summary>
      <value>
            A collection of properties.
            </value>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.BaseConfiguration.AssemblyBinding">
      <summary>
            Gets or sets the section configuring assembly redirectio policies.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.BaseConfiguration.StrongNames">
      <summary>
            Gets or sets the collection of strong names.
            </summary>
      <remarks>
            Strong names allow to automatically map short assembly names on strong assembly names,
            when short assembly names are provided in a configuration file.
            </remarks>
    </member>
    <member name="M:PostSharp.Extensibility.Configuration.ApplicationConfiguration.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.Configuration.ApplicationConfiguration" />.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.ApplicationConfiguration.Phases">
      <summary>
            Gets or sets the collection of phases (<see cref="T:PostSharp.Extensibility.Configuration.PhaseConfiguration" />) in the post-compilation process.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.Configuration.AssemblyBindingConfiguration">
      <summary>
            Section containing the configuration of assembly redirection.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.AssemblyBindingConfiguration.DependentAssemblies">
      <summary>
            Gets the collection of assembly redirections.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.AssemblyBindingConfiguration.ImportAssemblyBindings">
      <summary>
            Gets the collection of imports of assembly direction configurations.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.Configuration.AssemblyBindingExternalConfiguration">
      <summary>
            Imported section of assembly redirection configuration
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.AssemblyBindingExternalConfiguration.DependentAssemblies">
      <summary>
            Gets the collection of <see cref="T:PostSharp.Extensibility.Configuration.DependentAssemblyConfiguration" /> configuration
            elements.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.Configuration.AssemblyIdentityConfiguration">
      <summary>
            Part of an <see cref="T:PostSharp.Extensibility.Configuration.DependentAssemblyConfigurationCollection" />.
            Identifies a set if assembly.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.AssemblyIdentityConfiguration.Name">
      <summary>
            Gets of sets short name of matching assemblies, or '*' to match all assemblies.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.AssemblyIdentityConfiguration.PublicKeyToken">
      <summary>
            Gets or sets the public key token of matching assemblies.
            </summary>
      <remarks>
            If this property is <b>null</b>, any signed or unsigned assembly will match.
            </remarks>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.AssemblyIdentityConfiguration.Culture">
      <summary>
            Gets or sets the culture name of the matching assembly.
            </summary>
      <remarks>
            If this property is <b>null</b>, assemblies of any culture will match.
            </remarks>
    </member>
    <member name="T:PostSharp.Extensibility.Configuration.BindingRedirectConfiguration">
      <summary>
            Specifies the new target of an assembly. Part of a <see cref="T:PostSharp.Extensibility.Configuration.DependentAssemblyConfiguration" />
            configuration element.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.BindingRedirectConfiguration.OldVersion">
      <summary>
            Gets or sets the version that the version of the redirected assembly.
            </summary>
      <remarks>
        <para>If this property is <b>null</b>, all versions are matches. Otherwise,
            the version can be given in format <c>0.0.0.0</c> or in format <c>0.0.0.0-0.0.0.0</c>.</para>
      </remarks>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.BindingRedirectConfiguration.NewVersion">
      <summary>
            Gets or sets the version of the target assembly.
            </summary>
      <remarks>
            If this property is <b>null</b>, the new version will be equal to the old version.
            </remarks>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.BindingRedirectConfiguration.NewPublicKeyToken">
      <summary>
            Gets or sets the public key token of the target assembly.
            </summary>
      <remarks>
            If this property is <b>null</b>, the new public key token will be equal to the old one.
            </remarks>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.BindingRedirectConfiguration.NewName">
      <summary>
            Gets or sets the name of the target assembly.
            </summary>
      <remarks>
            If this property is <b>null</b>, the new name will be equal to the old one.
            </remarks>
    </member>
    <member name="T:PostSharp.Extensibility.Configuration.DependentAssemblyConfiguration">
      <summary>
            Configures an assembly redirection policy.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.DependentAssemblyConfiguration.AssemblyIdentity">
      <summary>
            Gets or sets the element identifying the source of the redirection.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.DependentAssemblyConfiguration.BindingRedirect">
      <summary>
            Gets or sets the element identifying the target of the redirection.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.Configuration.DependentAssemblyConfigurationCollection">
      <summary>
            Collection of <see cref="T:PostSharp.Extensibility.Configuration.DependentAssemblyConfiguration" />.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.Configuration.ImportAssemblyBindingsConfiguration">
      <summary>
            Specifies that assembly redirection configuration should be
            imported from another XML file. Part of the <see cref="T:PostSharp.Extensibility.Configuration.AssemblyBindingConfiguration" />
            element.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.ImportAssemblyBindingsConfiguration.File">
      <summary>
            Gets or sets the path of the imported XML file.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.ImportAssemblyBindingsConfiguration.Select">
      <summary>
            Gets or sets the XPath expression evaluating to a node of type <see cref="T:PostSharp.Extensibility.Configuration.AssemblyBindingExternalConfiguration" />.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.Configuration.ImportAssemblyBindingsConfigurationCollection">
      <summary>
            Collection of <see cref="T:PostSharp.Extensibility.Configuration.ImportAssemblyBindingsConfiguration" />.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.Configuration.PhaseConfiguration">
      <summary>
            Post-compilation phase, which divides sequentially the post-compilation process
            and to which tasks belong.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.PhaseConfiguration.Ordinal">
      <summary>
            Gets or sets the phase ordinal.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.PhaseConfiguration.Name">
      <summary>
            Gets or sets the phase name.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.Configuration.PhaseConfigurationCollection">
      <summary>
            Collection of phases (<see cref="T:PostSharp.Extensibility.Configuration.PhaseConfiguration" />).
            </summary>
    </member>
    <member name="T:PostSharp.Collections.MarshalByRefList`1">
      <summary>
            Implementation of generic <see cref="T:System.Collections.Generic.IList`1" /> marshalled by reference.
            </summary>
      <typeparam name="T">Type of items.</typeparam>
    </member>
    <member name="M:PostSharp.Collections.MarshalByRefList`1.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Collections.MarshalByRefList`1" /> with a <see cref="T:System.Collections.Generic.List`1" />
            as the underlying implementation.
            </summary>
    </member>
    <member name="M:PostSharp.Collections.MarshalByRefList`1.#ctor(System.Collections.Generic.IList{`0})">
      <summary>
            Initializes a new <see cref="T:PostSharp.Collections.MarshalByRefList`1" /> and specifies the
            underlying implementation.
            </summary>
      <param name="implementation">The underlying implementation,
            or the collection to wrap.</param>
    </member>
    <member name="M:PostSharp.Collections.MarshalByRefList`1.IndexOf(`0)" />
    <member name="M:PostSharp.Collections.MarshalByRefList`1.Insert(System.Int32,`0)" />
    <member name="M:PostSharp.Collections.MarshalByRefList`1.RemoveAt(System.Int32)" />
    <member name="M:PostSharp.Collections.MarshalByRefList`1.Add(`0)" />
    <member name="M:PostSharp.Collections.MarshalByRefList`1.Clear" />
    <member name="M:PostSharp.Collections.MarshalByRefList`1.Contains(`0)" />
    <member name="M:PostSharp.Collections.MarshalByRefList`1.CopyTo(`0[],System.Int32)" />
    <member name="M:PostSharp.Collections.MarshalByRefList`1.Remove(`0)" />
    <member name="M:PostSharp.Collections.MarshalByRefList`1.GetEnumerator" />
    <member name="P:PostSharp.Collections.MarshalByRefList`1.Item(System.Int32)" />
    <member name="P:PostSharp.Collections.MarshalByRefList`1.Count" />
    <member name="P:PostSharp.Collections.MarshalByRefList`1.IsReadOnly" />
    <member name="M:PostSharp.Extensibility.Configuration.PhaseConfigurationCollection.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.Configuration.PhaseConfigurationCollection" />.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.Configuration.PhaseConfigurationDictionary">
      <summary>
            Collection of phases ordered by ordinal and accessible by name.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Configuration.PhaseConfigurationDictionary.Contains(System.String)">
      <summary>
            Determines whether there exists a phase of a given name.
            </summary>
      <param name="name">Phase name.</param>
      <returns>
        <b>true</b> if there exists a phase named <paramref name="name" />,
            <value>false</value> otherwise.</returns>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.PhaseConfigurationDictionary.Item(System.String)">
      <summary>
            Gets a phase given its name.
            </summary>
      <param name="name">Phase name.</param>
      <returns>The phase named <paramref name="name" />, or <b>null</b> if no
            phase was found.</returns>
    </member>
    <member name="T:PostSharp.Extensibility.Configuration.SearchPathConfiguration">
      <summary>
            Specifies that a directory should be included in the search path.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Configuration.SearchPathConfiguration.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.Configuration.SearchPathConfiguration" />.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.SearchPathConfiguration.Directory">
      <summary>
            Gets or sets the directory to be included in the search path.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.SearchPathConfiguration.File">
      <summary>
            Gets or sets the file to be included in the search path.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.Configuration.SearchPathConfigurationCollection">
      <summary>
            Collection of <see cref="T:PostSharp.Extensibility.Configuration.SearchPathConfiguration" />.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Configuration.SearchPathConfigurationCollection.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.Configuration.SearchPathConfigurationCollection" />.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.Configuration.SourceConfiguration">
      <summary>
            Determines the source module.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Configuration.SourceConfiguration.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.Configuration.SourceConfiguration" />.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Configuration.SourceConfiguration.Validate" />
    <member name="P:PostSharp.Extensibility.Configuration.SourceConfiguration.SourceFile">
      <summary>
            Gets or sets the path of the source module.
            </summary>
      <value>
            An absolute file name, or a location relative to the declaring project
            file location.
            </value>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.SourceConfiguration.FullPath">
      <summary>
            Gets the full path of the current project file.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.Configuration.UsingConfiguration">
      <summary>
            Includes a plug-in in the current project.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Configuration.UsingConfiguration.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.Configuration.UsingConfiguration" />.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.UsingConfiguration.PlugInFile">
      <summary>
            Gets or sets the path of the plug-in configuration file.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.Configuration.UsingConfigurationCollection">
      <summary>
            Collection of <see cref="T:PostSharp.Extensibility.Configuration.UsingConfiguration" />.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Configuration.UsingConfigurationCollection.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.Configuration.UsingConfigurationCollection" />.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.AnnotationValue">
      <summary>
            Represents a custom attribute value that is not declared inside a module,
            i.e. is not a <see cref="T:PostSharp.CodeModel.MetadataDeclaration" />.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.AnnotationValue.#ctor(PostSharp.CodeModel.IMethod)">
      <summary>
            Initializes a new instance of the <see cref="T:PostSharp.CodeModel.CustomAttributeDeclaration" /> type.
            </summary>
      <param name="constructor">Custom attribute constructor.</param>
      <remarks>
            The <paramref name="constructor" /> parameter should be set to a valid
            instance constructor. This rule is not enforced programmatically.
            </remarks>
    </member>
    <member name="M:PostSharp.Extensibility.AnnotationValue.Translate(PostSharp.CodeModel.ModuleDeclaration)">
      <summary>
            Translates the current annotation so that it is valid in another module.
            </summary>
      <param name="module">The module into which the current <see cref="T:PostSharp.CodeModel.IAnnotationValue" />
            should be translated.</param>
      <returns>An <see cref="T:PostSharp.CodeModel.IAnnotationValue" /> valid in <paramref name="module" />.</returns>
    </member>
    <member name="M:PostSharp.Extensibility.AnnotationValue.AssertNotDisposed">
      <summary>
            Throws an exception if the current instance has been disposed.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.AnnotationValue.Dispose(System.Boolean)">
      <summary>
            Disposes the resources hold by the current instance.
            </summary>
      <param name="disposing">
        <b>disposing</b> if the current method is called because an
            explicit call of <see cref="M:PostSharp.Extensibility.AnnotationValue.Dispose" />, or <b>false</b> if the method
            is called by the destructor.</param>
    </member>
    <member name="M:PostSharp.Extensibility.AnnotationValue.Dispose" />
    <member name="P:PostSharp.Extensibility.AnnotationValue.ConstructorArguments">
      <summary>
            Gets the collection of constructor arguments.
            </summary>
      <value>A collection of values (<see cref="T:PostSharp.CodeModel.MemberValuePair" />)
            where <see cref="P:PostSharp.CodeModel.MemberValuePair.MemberName" /> 
            is not signiticative.</value>
    </member>
    <member name="P:PostSharp.Extensibility.AnnotationValue.NamedArguments">
      <summary>
            Gets the collection of named arguments.
            </summary>
      <value>
            A collection of member-value associations (<see cref="T:PostSharp.CodeModel.MemberValuePair" />).
            </value>
    </member>
    <member name="P:PostSharp.Extensibility.AnnotationValue.Constructor">
      <summary>
            Gets the constructor that
            was used to build the custom attribute.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.AnnotationValue.IsDisposed">
      <summary>
            Determines whether the current instance has been disposed.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.AnnotationInstance">
      <summary>
            Represents a <see cref="T:PostSharp.Extensibility.AnnotationValue" /> that is applied to one
            and only one target element.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.AnnotationInstance.#ctor(PostSharp.CodeModel.MetadataDeclaration,PostSharp.CodeModel.IMethod)">
      <summary>
            Initializes a new instance of the <see cref="T:PostSharp.Extensibility.AnnotationInstance" /> type.
            </summary>
      <param name="constructor">Custom attribute constructor.</param>
      <param name="targetElement">Element on which the custom attribute applies.</param>
      <remarks>
            The <paramref name="constructor" /> parameter should be set to a valid
            instance constructor. This rule is not enforced programmatically.
            </remarks>
    </member>
    <member name="P:PostSharp.Extensibility.AnnotationInstance.TargetElement">
      <summary>
            Element on which the custom attribute value is applied.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.AnnotationInstance.Value">
      <summary>
            Custom attribute value.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.SharedAnnotationInstance">
      <summary>
            Implementation of <see cref="T:PostSharp.CodeModel.IAnnotationInstance" /> that allows the same custom attribute
            value to be applied to many target elements.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.SharedAnnotationInstance.#ctor(PostSharp.CodeModel.IAnnotationValue,PostSharp.CodeModel.MetadataDeclaration)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.SharedAnnotationInstance" />.
            </summary>
      <param name="value">Custom attribute value.</param>
      <param name="targetElement">Target element.</param>
    </member>
    <member name="P:PostSharp.Extensibility.SharedAnnotationInstance.Value">
      <summary>
            Custom attribute value.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.SharedAnnotationInstance.TargetElement">
      <summary>
            Element on which the custom attribute value is applied.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.LiteralString">
      <summary>
            Encapsulates a read-only array of characters.
            </summary>
      <remarks>We use <see cref="T:PostSharp.CodeModel.LiteralString" />
            instead of <see cref="T:System.String" /> because <see cref="T:System.String" /> sometimes transforms 
            the array of characters, but we require binary identity between what we read
            and what we writer.</remarks>
    </member>
    <member name="F:PostSharp.CodeModel.LiteralString.Null">
      <summary>
            Represents a null <see cref="T:PostSharp.CodeModel.LiteralString" />.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.LiteralString.#ctor(System.Char[])">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.LiteralString" />
            from an array of characters.
            </summary>
      <param name="chars">An array of characters, or <b>null</b> to construct
            a null <see cref="T:PostSharp.CodeModel.LiteralString" />.</param>
      <remarks>
            For performance reasons, the current constructor stores a reference 
            to <paramref name="chars" />, i.e. does <i>not</i> take a copy of the array.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.LiteralString.#ctor(System.String)">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.LiteralString" /> from a string.
            </summary>
      <param name="text">A string, or <b>null</b> to construct a null 
            <see cref="T:PostSharp.CodeModel.LiteralString" />.</param>
    </member>
    <member name="M:PostSharp.CodeModel.LiteralString.GetChar(System.Int32)">
      <summary>
            Gets a character given its position.
            </summary>
      <param name="index">The character position.</param>
      <returns>The character at position <paramref name="index" />.</returns>
      <exception cref="T:System.InvalidOperationException">The <see cref="T:PostSharp.CodeModel.LiteralString" /> is null.</exception>
    </member>
    <member name="M:PostSharp.CodeModel.LiteralString.ToString">
      <summary>
            Convert this instance to a <see cref="T:System.String" />.
            </summary>
      <returns>The <see cref="T:System.String" /> contained in the current instance,
            or <b>null</b> if the current instance is null.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.LiteralString.op_Implicit(System.String)~PostSharp.CodeModel.LiteralString">
      <summary>
            Converts a <see cref="T:System.String" /> to a <see cref="T:PostSharp.CodeModel.LiteralString" />.
            </summary>
      <param name="text">A string, or <b>null</b> to construct a null 
            <see cref="T:PostSharp.CodeModel.LiteralString" />.</param>
      <returns>A <see cref="T:PostSharp.CodeModel.LiteralString" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.LiteralString.Equals(System.Object)" />
    <member name="M:PostSharp.CodeModel.LiteralString.Equals(PostSharp.CodeModel.LiteralString)" />
    <member name="M:PostSharp.CodeModel.LiteralString.op_Equality(PostSharp.CodeModel.LiteralString,PostSharp.CodeModel.LiteralString)">
      <summary>
            Determines whether two strings are equal.
            </summary>
      <param name="left">A <see cref="T:PostSharp.CodeModel.LiteralString" />.</param>
      <param name="right">A <see cref="T:PostSharp.CodeModel.LiteralString" />.</param>
      <returns>
        <b>true</b> if both strings are equal, otherwise <b>false</b>.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.LiteralString.op_Inequality(PostSharp.CodeModel.LiteralString,PostSharp.CodeModel.LiteralString)">
      <summary>
            Determines whether two strings are different.
            </summary>
      <param name="left">A <see cref="T:PostSharp.CodeModel.LiteralString" />.</param>
      <param name="right">A <see cref="T:PostSharp.CodeModel.LiteralString" />.</param>
      <returns>
        <b>true</b> if both strings are different, otherwise <b>false</b>.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.LiteralString.GetHashCode" />
    <member name="P:PostSharp.CodeModel.LiteralString.Length">
      <summary>
            Gets the string lenght.
            </summary>
      <value>
            The number of characters in the array.
            </value>
      <exception cref="T:System.InvalidOperationException">The <see cref="T:PostSharp.CodeModel.LiteralString" /> is null.</exception>
    </member>
    <member name="P:PostSharp.CodeModel.LiteralString.IsNull">
      <summary>
            Determines whether the current instance represents a null string.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.MarshalTypes.ArrayMarshalType">
      <summary>
            Represents the type of an unmanaged LPArray, i.e. a pointer to a standard C array.
            </summary>
      <remarks>
            The number of elements in the array is determined by the following formula:
            <list type="bullet"><item>
            		If <see cref="P:PostSharp.CodeModel.MarshalTypes.ArrayMarshalType.AdditionalSizeParameter" /> = 0, the size is <see cref="P:PostSharp.CodeModel.MarshalTypes.ArrayMarshalType.FixedArraySize" />.
            	</item><item>
            		Otherwise, the size is @<see cref="P:PostSharp.CodeModel.MarshalTypes.ArrayMarshalType.AdditionalSizeParameter" /> + <see cref="P:PostSharp.CodeModel.MarshalTypes.ArrayMarshalType.FixedArraySize" />,
            		where @<see cref="P:PostSharp.CodeModel.MarshalTypes.ArrayMarshalType.AdditionalSizeParameter" /> is the value of the parameter
            		whose 0-based index is <see cref="P:PostSharp.CodeModel.MarshalTypes.ArrayMarshalType.AdditionalSizeParameter" />-1.
            	</item></list></remarks>
    </member>
    <member name="T:PostSharp.CodeModel.MarshalType">
      <summary>
            Marshal types. Determines how fields and parameters are marshalled
            during PInvoke. 
            </summary>
      <remarks>
            Concrete implementations are in the 
            <see cref="N:PostSharp.CodeModel.MarshalTypes" /> namespace.
            </remarks>
    </member>
    <member name="F:PostSharp.CodeModel.MarshalTypes.ArrayMarshalType.UnknownElementType">
      <summary>
            When applies to the <see cref="P:PostSharp.CodeModel.MarshalTypes.ArrayMarshalType.ElementType" /> property, means that the
            element type is not known.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.MarshalTypes.ArrayMarshalType.#ctor(System.Runtime.InteropServices.UnmanagedType,System.Int32,System.Int32)">
      <summary>
            Initializes a new instance of <see cref="T:PostSharp.CodeModel.MarshalTypes.ArrayMarshalType" />.
            </summary>
      <param name="elementType">Type of array elements.</param>
      <param name="fixedArraySize">Fixed array size, or -1 if the size is not specified.</param>
      <param name="additionalSizeParameter">0-based index of the parameter containing
            the additional number of array elements, or -1 is the array size is solely
            determined by <paramref name="fixedArraySize" />.</param>
    </member>
    <member name="P:PostSharp.CodeModel.MarshalTypes.ArrayMarshalType.ElementType">
      <summary>
            Gets the type of elements.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MarshalTypes.ArrayMarshalType.AdditionalSizeParameter">
      <summary>
            Gets the index of the parameter containing the array size.
            </summary>
      <value>
            The 1-based index of the parameter containing the array size, or 0 if
            the array size is fixed and set to <see cref="P:PostSharp.CodeModel.MarshalTypes.ArrayMarshalType.FixedArraySize" />.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.MarshalTypes.ArrayMarshalType.FixedArraySize">
      <summary>
            Gets the fixed array size.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.MarshalTypes.CustomMarshallerMarshalType">
      <summary>
            Special <see cref="T:PostSharp.CodeModel.MarshalType" /> meaning that a custom marshaller should
            be used.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.MarshalTypes.CustomMarshallerMarshalType.#ctor(System.Guid,System.String,System.String,System.String)">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.MarshalTypes.CustomMarshallerMarshalType" />.
            </summary>
      <param name="guid">GUID.</param>
      <param name="unmanagedType">Unmanaged type name.</param>
      <param name="managedType">Managed type name.</param>
      <param name="cookie">Cookie.</param>
    </member>
    <member name="P:PostSharp.CodeModel.MarshalTypes.CustomMarshallerMarshalType.Guid">
      <summary>
            Gets the custom marshaller GUID.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MarshalTypes.CustomMarshallerMarshalType.UnmanagedType">
      <summary>
            Gets the unmanaged type name.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MarshalTypes.CustomMarshallerMarshalType.ManagedType">
      <summary>
            Gets the managed type name.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MarshalTypes.CustomMarshallerMarshalType.Cookie">
      <summary>
            Gets the cookie.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.MarshalTypes.FixedArrayMarshalType">
      <summary>
            Represents the type of an unmanaged array with fixed number of elements, passed by value.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.MarshalTypes.FixedArrayMarshalType.#ctor(System.Runtime.InteropServices.UnmanagedType,System.Int32)">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.MarshalTypes.FixedArrayMarshalType" />.
            </summary>
      <param name="elementType">Type of array elements.</param>
      <param name="elementNumber">Number of array elements.</param>
    </member>
    <member name="P:PostSharp.CodeModel.MarshalTypes.FixedArrayMarshalType.ElementType">
      <summary>
            Gets the type of array elements.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MarshalTypes.FixedArrayMarshalType.ElementNumber">
      <summary>
            Gets the number of elements in the array.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.MarshalTypes.FixedStringMarshalType">
      <summary>
            Represents the type of an unmanaged string passed by value.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.MarshalTypes.FixedStringMarshalType.#ctor(System.Int32)">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.MarshalTypes.FixedStringMarshalType" />.
            </summary>
      <param name="size">Number of characters in the string.</param>
    </member>
    <member name="P:PostSharp.CodeModel.MarshalTypes.FixedStringMarshalType.Size">
      <summary>
            Gets the string size.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.MarshalTypes.IntrinsicMarshalType">
      <summary>
            Represents the type of an intrinsic unmanaged scalar.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.MarshalTypes.IntrinsicMarshalType.#ctor(System.Runtime.InteropServices.UnmanagedType)">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.MarshalTypes.IntrinsicMarshalType" />.
            </summary>
      <param name="type">The instrinsic type.</param>
    </member>
    <member name="P:PostSharp.CodeModel.MarshalTypes.IntrinsicMarshalType.Type">
      <summary>
            Gets the instrinsic type.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.MarshalTypes.SafeArrayMarshalType">
      <summary>
            Represents the type of an unmanaged Safe Array.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.MarshalTypes.SafeArrayMarshalType.#ctor(System.Runtime.InteropServices.VarEnum)">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.MarshalTypes.SafeArrayMarshalType" />.
            </summary>
      <param name="elementType">Type of array elements.</param>
    </member>
    <member name="P:PostSharp.CodeModel.MarshalTypes.SafeArrayMarshalType.ElementType">
      <summary>
            Gets the type of array elements.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.PlatformInfo">
      <summary>
            Contains the characteristics of a platform, typically
            the target platform of the module.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.PlatformInfo.NativePointerSize">
      <summary>
            Gets the size of a native pointer in bytes.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.TypeSignatures.ArrayTypeSignature">
      <summary>
            Represents the type of an array.
            </summary>
      <remarks>
            Arrays with a single dimension, no fixed size and zero lower bound are called
            <b>Vectors</b>. Normal arrays in C#, for instance, are vectors. Use the 
            <see cref="P:PostSharp.CodeModel.TypeSignatures.ArrayTypeSignature.IsVector" /> property to determine whether an <see cref="T:PostSharp.CodeModel.TypeSignatures.ArrayTypeSignature" />
            is a vector.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignatures.ArrayTypeSignature.#ctor(PostSharp.CodeModel.ITypeSignature,PostSharp.CodeModel.TypeSignatures.ArrayDimension[])">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.TypeSignatures.ArrayTypeSignature" />.
            </summary>
      <param name="innerType">Type of array elements.</param>
      <param name="dimensions">Array dimensions.</param>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignatures.ArrayTypeSignature.#ctor(PostSharp.CodeModel.ITypeSignature)">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.TypeSignatures.ArrayTypeSignature" /> with default dimensions ([0..]).
            </summary>
      <param name="innerType">Type of array elements.</param>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignatures.ArrayTypeSignature.WriteReflectionTypeName(System.Text.StringBuilder,PostSharp.CodeModel.ReflectionNameOptions)" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.ArrayTypeSignature.BelongsToClassification(PostSharp.CodeModel.TypeClassifications)" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.ArrayTypeSignature.ContainsGenericArguments" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.ArrayTypeSignature.MapGenericArguments(PostSharp.CodeModel.GenericMap)" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.ArrayTypeSignature.ToString" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.ArrayTypeSignature.GetDimension(System.Int32)">
      <summary>
            Gets a dimension given its index.
            </summary>
      <param name="index">Dimension index.</param>
      <returns>The dimension at index <paramref name="index" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignatures.ArrayTypeSignature.GetSystemType(System.Type[],System.Type[])" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.ArrayTypeSignature.GetReflectionWrapper(System.Type[],System.Type[])" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.ArrayTypeSignature.Translate(PostSharp.CodeModel.ModuleDeclaration)" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.ArrayTypeSignature.GetCanonicalHashCode" />
    <member name="P:PostSharp.CodeModel.TypeSignatures.ArrayTypeSignature.Rank">
      <summary>
            Gets the array rank (number of dimensions).
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeSignatures.ArrayTypeSignature.IsVector">
      <summary>
            Determines whether the current array is a vector.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeSignatures.ArrayTypeSignature.ElementType">
      <summary>
            Gets the type of array elements.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeSignatures.ArrayTypeSignature.Module" />
    <member name="T:PostSharp.CodeModel.TypeSignatures.ArrayDimension">
      <summary>
            Specifies the bounds of a single dimension of an <see cref="T:PostSharp.CodeModel.TypeSignatures.ArrayTypeSignature" />.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TypeSignatures.ArrayDimension.Unlimited">
      <summary>
            When set to <see cref="P:PostSharp.CodeModel.TypeSignatures.ArrayDimension.LowerBound" /> or <see cref="P:PostSharp.CodeModel.TypeSignatures.ArrayDimension.Size" />, specifies
            that the value is unbounded.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignatures.ArrayDimension.#ctor(System.Int32,System.Int32)">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.TypeSignatures.ArrayDimension" />.
            </summary>
      <param name="lowerBound">Lower bound, or <see cref="F:PostSharp.CodeModel.TypeSignatures.ArrayDimension.Unlimited" />.</param>
      <param name="size">Number of elements, or <see cref="F:PostSharp.CodeModel.TypeSignatures.ArrayDimension.Unlimited" />.</param>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignatures.ArrayDimension.Equals(System.Object)" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.ArrayDimension.Equals(PostSharp.CodeModel.TypeSignatures.ArrayDimension)" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.ArrayDimension.op_Equality(PostSharp.CodeModel.TypeSignatures.ArrayDimension,PostSharp.CodeModel.TypeSignatures.ArrayDimension)">
      <summary>
            Determines whether two instances are equal.
            </summary>
      <param name="left">An <see cref="T:PostSharp.CodeModel.TypeSignatures.ArrayDimension" />.</param>
      <param name="right">An <see cref="T:PostSharp.CodeModel.TypeSignatures.ArrayDimension" />.</param>
      <returns>
        <b>true</b> if both instances are equal, otherwise <b>false</b>.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignatures.ArrayDimension.op_Inequality(PostSharp.CodeModel.TypeSignatures.ArrayDimension,PostSharp.CodeModel.TypeSignatures.ArrayDimension)">
      <summary>
            Determines whether two instances are different.
            </summary>
      <param name="left">An <see cref="T:PostSharp.CodeModel.TypeSignatures.ArrayDimension" />.</param>
      <param name="right">An <see cref="T:PostSharp.CodeModel.TypeSignatures.ArrayDimension" />.</param>
      <returns>
        <b>true</b> if both instances are different, otherwise <b>false</b>.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignatures.ArrayDimension.GetHashCode" />
    <member name="P:PostSharp.CodeModel.TypeSignatures.ArrayDimension.LowerBound">
      <summary>
            Gets the lower bound.
            </summary>
      <remarks>
            A signed interger, or <see cref="F:PostSharp.CodeModel.TypeSignatures.ArrayDimension.Unlimited" /> so specify that this
            dimension has no lower bound.
            </remarks>
    </member>
    <member name="P:PostSharp.CodeModel.TypeSignatures.ArrayDimension.HasLowerBound">
      <summary>
            Determines whether the dimension has a lower bound.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeSignatures.ArrayDimension.Size">
      <summary>
            Gets the number of elements.
            </summary>
      <remarks>
            A singed integer, or <see cref="F:PostSharp.CodeModel.TypeSignatures.ArrayDimension.Unlimited" /> to specify that this
            dimension can have an unlimited number of elements.
            </remarks>
    </member>
    <member name="P:PostSharp.CodeModel.TypeSignatures.ArrayDimension.HasSize">
      <summary>
            Determines whether the dimension has a limited number of elements.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.TypeSignatures.BoxedTypeSignature">
      <summary>
            Represents the type of a boxed value.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignatures.BoxedTypeSignature.#ctor(PostSharp.CodeModel.ITypeSignature)">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.TypeSignatures.BoxedTypeSignature" />.
            </summary>
      <param name="innerType">The type of values being boxed.</param>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignatures.BoxedTypeSignature.WriteReflectionTypeName(System.Text.StringBuilder,PostSharp.CodeModel.ReflectionNameOptions)" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.BoxedTypeSignature.ToString" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.BoxedTypeSignature.BelongsToClassification(PostSharp.CodeModel.TypeClassifications)" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.BoxedTypeSignature.ContainsGenericArguments" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.BoxedTypeSignature.MapGenericArguments(PostSharp.CodeModel.GenericMap)" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.BoxedTypeSignature.GetReflectionWrapper(System.Type[],System.Type[])" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.BoxedTypeSignature.GetSystemType(System.Type[],System.Type[])" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.BoxedTypeSignature.Translate(PostSharp.CodeModel.ModuleDeclaration)" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.BoxedTypeSignature.GetCanonicalHashCode" />
    <member name="P:PostSharp.CodeModel.TypeSignatures.BoxedTypeSignature.ElementType">
      <summary>
            Gets the type of values being boxed.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeSignatures.BoxedTypeSignature.Module" />
    <member name="T:PostSharp.CodeModel.TypeSignatures.CustomModifierTypeSignature">
      <summary>
            Represents a type modified by a custom modifier.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignatures.CustomModifierTypeSignature.#ctor(PostSharp.CodeModel.TypeSignatures.CustomModifier,PostSharp.CodeModel.ITypeSignature)">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.TypeSignatures.CustomModifierTypeSignature" />.
            </summary>
      <param name="customModifier">The custom modifier.</param>
      <param name="innerType">The modified type.</param>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignatures.CustomModifierTypeSignature.WriteReflectionTypeName(System.Text.StringBuilder,PostSharp.CodeModel.ReflectionNameOptions)" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.CustomModifierTypeSignature.BelongsToClassification(PostSharp.CodeModel.TypeClassifications)" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.CustomModifierTypeSignature.ContainsGenericArguments" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.CustomModifierTypeSignature.MapGenericArguments(PostSharp.CodeModel.GenericMap)" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.CustomModifierTypeSignature.ToString" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.CustomModifierTypeSignature.Visit(System.String,PostSharp.Collections.Visitor{PostSharp.CodeModel.ITypeSignature})" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.CustomModifierTypeSignature.GetValueSize(PostSharp.CodeModel.PlatformInfo)" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.CustomModifierTypeSignature.GetSystemType(System.Type[],System.Type[])" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.CustomModifierTypeSignature.GetReflectionWrapper(System.Type[],System.Type[])" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.CustomModifierTypeSignature.Translate(PostSharp.CodeModel.ModuleDeclaration)" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.CustomModifierTypeSignature.GetCanonicalHashCode" />
    <member name="P:PostSharp.CodeModel.TypeSignatures.CustomModifierTypeSignature.Modifier">
      <summary>
            Gets the custom modifier.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeSignatures.CustomModifierTypeSignature.ElementType">
      <summary>
            Gets the modified type.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeSignatures.CustomModifierTypeSignature.Module" />
    <member name="T:PostSharp.CodeModel.TypeSignatures.GenericParameterTypeSignature">
      <summary>
            Represents a reference to a generic parameter.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.IGenericParameter">
      <summary>
            Defines the semantics of a generic parameter <i>or</i> argument.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.IGenericParameter.GetReference">
      <summary>
            Gets the <see cref="T:PostSharp.CodeModel.TypeSignatures.GenericParameterTypeSignature" /> that references to the current
            instance.
            </summary>
      <returns>A <see cref="T:PostSharp.CodeModel.TypeSignatures.GenericParameterTypeSignature" /> with same ordinal and
            kind as the current instance.</returns>
    </member>
    <member name="P:PostSharp.CodeModel.IGenericParameter.Kind">
      <summary>
            Gets the kind of generic parameter (<see cref="F:PostSharp.CodeModel.GenericParameterKind.Method" />
            or <see cref="F:PostSharp.CodeModel.GenericParameterKind.Type" />).
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.IGenericParameter.Ordinal">
      <summary>
            Gets the generic parameter ordinal.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignatures.GenericParameterTypeSignature.GetInstance(PostSharp.CodeModel.ModuleDeclaration,System.Int32,PostSharp.CodeModel.GenericParameterKind)">
      <summary>
            Gets a <see cref="T:PostSharp.CodeModel.TypeSignatures.GenericParameterTypeSignature" />.
            </summary>
      <param name="ordinal">Ordinal.</param>
      <param name="genericParameterKind">Kind of generic parameter (method or type).</param>
      <param name="module">Module for which the instance is valid.</param>
      <returns>The requested <see cref="T:PostSharp.CodeModel.TypeSignatures.GenericParameterTypeSignature" />.</returns>
      <remarks>
            User code should call <see cref="T:PostSharp.CodeModel.DeclarationCache" />.<see cref="M:PostSharp.CodeModel.DeclarationCache.GetGenericParameter(System.Int32,PostSharp.CodeModel.GenericParameterKind)" />
            instead of this method.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignatures.GenericParameterTypeSignature.WriteReflectionTypeName(System.Text.StringBuilder,PostSharp.CodeModel.ReflectionNameOptions)">
      <summary>
            Gets the type name as used in <b>System.Reflection</b>.
            </summary>
      <returns>A <see cref="T:System.String" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignatures.GenericParameterTypeSignature.ToString" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.GenericParameterTypeSignature.BelongsToClassification(PostSharp.CodeModel.TypeClassifications)">
      <summary>
            Determines whether the type signature belongs to a given classification,
            i.e. whether it fulfills a given predicate.
            </summary>
      <param name="typeClassification">The classification (or predicate) 
            (combination of bits are not allowed).</param>
      <returns>
        <see cref="F:PostSharp.NullableBool.True" /> if the predicate is true, 
            <see cref="F:PostSharp.NullableBool.False" /> if the predicate is false or
            <see cref="F:PostSharp.NullableBool.Null" /> if it cannot be determined. </returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignatures.GenericParameterTypeSignature.ContainsGenericArguments">
      <summary>
            Determines whether the type signature contains a generic argument.
            </summary>
      <returns>
        <b>true</b> if the type signature contains a generic argument, otherwise <b>false</b>.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignatures.GenericParameterTypeSignature.MapGenericArguments(PostSharp.CodeModel.GenericMap)">
      <summary>
            Resolves all generic arguments in the current type signature.
            </summary>
      <param name="genericMap">Generic context in which generic arguments have to be resolved.</param>
      <returns>A <see cref="T:PostSharp.CodeModel.IType" /> resolved against <paramref name="genericMap" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignatures.GenericParameterTypeSignature.GetReflectionWrapper(System.Type[],System.Type[])">
      <summary>
            Gets a reflection <see cref="T:System.Type" /> that wraps the current type.
            </summary>
      <param name="genericTypeArguments">Array of generic type arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <param name="genericMethodArguments">Array of generic method arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <returns>A <see cref="T:System.Type" /> wrapping current type in the
            given generic context.</returns>
      <remarks>
            This method returns a <see cref="T:System.Type" /> that is different from the system
            runtime type that is retrieved by <see cref="M:PostSharp.CodeModel.ITypeSignature.GetSystemType(System.Type[],System.Type[])" />. This allows
            a have a <b>System.Reflection</b> representation of the current type even
            when it cannot be loaded in the Virtual Runtime Engine.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignatures.GenericParameterTypeSignature.GetSystemType(System.Type[],System.Type[])">
      <summary>
            Gets the system, runtime <see cref="T:System.Type" /> corresponding to the current type.
            </summary>
      <param name="genericTypeArguments">Array of generic type arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <param name="genericMethodArguments">Array of generic method arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <returns>The system <see cref="T:System.Type" /> associated the current type in the
            given generic context.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignatures.GenericParameterTypeSignature.Translate(PostSharp.CodeModel.ModuleDeclaration)">
      <summary>
            Translates the current type signature so that it is meaningful in another
            module than the one to which it primarly belong.
            </summary>
      <param name="targetModule">Module into which the type signature should be
            translated.</param>
      <returns>A type signature meaningful in the <paramref name="targetModule" />
            module.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignatures.GenericParameterTypeSignature.GetCanonicalHashCode">
      <summary>
            Gets a hash code that is invariant under type signature equality
            (i.e. if two types are equal under <see cref="T:System.IEquatable`1" />, they have the
            same canonical has code).
            </summary>
      <returns>A hash code that is invariant under type signature equality.</returns>
      <remarks>This method is of course useful to build dictionaries. The <see cref="T:PostSharp.CodeModel.Binding.TypeComparer" /> class
            uses this method.</remarks>
    </member>
    <member name="P:PostSharp.CodeModel.TypeSignatures.GenericParameterTypeSignature.Ordinal">
      <summary>
            Gets the generic parameter orginal.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeSignatures.GenericParameterTypeSignature.Kind">
      <summary>
            Gets the kind of generic parameter (type or method).
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeSignatures.GenericParameterTypeSignature.ElementType" />
    <member name="P:PostSharp.CodeModel.TypeSignatures.GenericParameterTypeSignature.Module">
      <summary>
            Gets the declaring module.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.TypeSignatures.IntrinsicTypeSignature">
      <summary>
            Represents an instrinsic type.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignatures.IntrinsicTypeSignature.MapReflectionType(System.Type)">
      <summary>
            Gets the <see cref="P:PostSharp.CodeModel.TypeSignatures.IntrinsicTypeSignature.IntrinsicType" /> corresponding to a <see cref="T:System.Type" />.
            </summary>
      <param name="reflectionType">The <see cref="T:System.Type" /> to be
            mapped to an <see cref="P:PostSharp.CodeModel.TypeSignatures.IntrinsicTypeSignature.IntrinsicType" />.</param>
      <returns>The <see cref="P:PostSharp.CodeModel.TypeSignatures.IntrinsicTypeSignature.IntrinsicType" /> corresponding to <paramref name="reflectionType" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignatures.IntrinsicTypeSignature.IsIntrinsic(System.Type)">
      <summary>
            Determines whether a <see cref="T:System.Type" /> is intrinsic.
            </summary>
      <param name="reflectionType" />
      <returns />
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignatures.IntrinsicTypeSignature.GetInstance(System.Type,PostSharp.CodeModel.ModuleDeclaration)">
      <summary>
            Gets an <see cref="T:PostSharp.CodeModel.TypeSignatures.IntrinsicTypeSignature" /> instance given a reflection <see cref="T:System.Type" />.
            </summary>
      <param name="reflectionType">An instrinsic runtime <see cref="T:System.Type" />.</param>
      <param name="module">Module for which the instance should be valid.</param>
      <returns>The <see cref="T:PostSharp.CodeModel.TypeSignatures.IntrinsicTypeSignature" /> corresponding to <paramref name="reflectionType" />.</returns>
      <remarks>
            User code should use the method <see cref="T:PostSharp.CodeModel.DeclarationCache" />.<see cref="M:PostSharp.CodeModel.DeclarationCache.GetIntrinsic(System.Type)" />
            instead of this one.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignatures.IntrinsicTypeSignature.GetInstance(PostSharp.CodeModel.IntrinsicType,PostSharp.CodeModel.ModuleDeclaration)">
      <summary>
            Gets an instance of a <see cref="T:PostSharp.CodeModel.TypeSignatures.IntrinsicTypeSignature" /> for a given module.
            </summary>
      <param name="intrinsic">
        <see cref="P:PostSharp.CodeModel.TypeSignatures.IntrinsicTypeSignature.IntrinsicType" /> for which the type signature is required.</param>
      <param name="module">Module in which the instance should be valid.</param>
      <returns>An <see cref="T:PostSharp.CodeModel.TypeSignatures.IntrinsicTypeSignature" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignatures.IntrinsicTypeSignature.BelongsToClassification(PostSharp.CodeModel.TypeClassifications)" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.IntrinsicTypeSignature.ContainsGenericArguments" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.IntrinsicTypeSignature.MapGenericArguments(PostSharp.CodeModel.GenericMap)" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.IntrinsicTypeSignature.ToString" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.IntrinsicTypeSignature.GetValueSize(PostSharp.CodeModel.PlatformInfo)" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.IntrinsicTypeSignature.GetSystemType(System.Type[],System.Type[])" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.IntrinsicTypeSignature.GetReflectionWrapper(System.Type[],System.Type[])" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.IntrinsicTypeSignature.WriteReflectionTypeName(System.Text.StringBuilder,PostSharp.CodeModel.ReflectionNameOptions)" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.IntrinsicTypeSignature.Translate(PostSharp.CodeModel.ModuleDeclaration)" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.IntrinsicTypeSignature.Is(PostSharp.CodeModel.ITypeSignature,PostSharp.CodeModel.IntrinsicType)">
      <summary>
            Determines whether a type signature is a given intrinsic.
            </summary>
      <param name="typeSignature">A type signature.</param>
      <param name="intrinsic">An intrinsic.</param>
      <returns>
        <b>true</b> if <paramref name="typeSignature" /> is the given intrinsic,
            otherwise <b>false</b>.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignatures.IntrinsicTypeSignature.GetCanonicalHashCode" />
    <member name="P:PostSharp.CodeModel.TypeSignatures.IntrinsicTypeSignature.IntrinsicType">
      <summary>
            Gets the instrinsic type.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeSignatures.IntrinsicTypeSignature.ElementType" />
    <member name="P:PostSharp.CodeModel.TypeSignatures.IntrinsicTypeSignature.Module" />
    <member name="T:PostSharp.CodeModel.TypeSignatures.MethodPointerTypeSignature">
      <summary>
            Represents the type of a method pointer.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignatures.MethodPointerTypeSignature.#ctor(PostSharp.CodeModel.MethodSignature)">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.TypeSignatures.MethodPointerTypeSignature" />.
            </summary>
      <param name="method">Signature of the method referenced by a pointer of this type.</param>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignatures.MethodPointerTypeSignature.Visit(System.String,PostSharp.Collections.Visitor{PostSharp.CodeModel.ITypeSignature})" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.MethodPointerTypeSignature.WriteReflectionTypeName(System.Text.StringBuilder,PostSharp.CodeModel.ReflectionNameOptions)" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.MethodPointerTypeSignature.BelongsToClassification(PostSharp.CodeModel.TypeClassifications)" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.MethodPointerTypeSignature.ContainsGenericArguments" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.MethodPointerTypeSignature.MapGenericArguments(PostSharp.CodeModel.GenericMap)" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.MethodPointerTypeSignature.ToString" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.MethodPointerTypeSignature.GetValueSize(PostSharp.CodeModel.PlatformInfo)" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.MethodPointerTypeSignature.GetSystemType(System.Type[],System.Type[])" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.MethodPointerTypeSignature.GetReflectionWrapper(System.Type[],System.Type[])" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.MethodPointerTypeSignature.Translate(PostSharp.CodeModel.ModuleDeclaration)" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.MethodPointerTypeSignature.GetCanonicalHashCode" />
    <member name="P:PostSharp.CodeModel.TypeSignatures.MethodPointerTypeSignature.Signature">
      <summary>
            Gets the signature of the method referenced by a pointer of the current type.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeSignatures.MethodPointerTypeSignature.ElementType" />
    <member name="P:PostSharp.CodeModel.TypeSignatures.MethodPointerTypeSignature.Module" />
    <member name="T:PostSharp.CodeModel.TypeSignatures.PinnedTypeSignature">
      <summary>
            Represents the type of a pinned pointer.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignatures.PinnedTypeSignature.#ctor(PostSharp.CodeModel.ITypeSignature)">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.TypeSignatures.PinnedTypeSignature" />.
            </summary>
      <param name="pointerType">Type of the underlying pointer.</param>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignatures.PinnedTypeSignature.ToString" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.PinnedTypeSignature.WriteReflectionTypeName(System.Text.StringBuilder,PostSharp.CodeModel.ReflectionNameOptions)" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.PinnedTypeSignature.BelongsToClassification(PostSharp.CodeModel.TypeClassifications)" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.PinnedTypeSignature.ContainsGenericArguments" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.PinnedTypeSignature.MapGenericArguments(PostSharp.CodeModel.GenericMap)" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.PinnedTypeSignature.GetValueSize(PostSharp.CodeModel.PlatformInfo)" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.PinnedTypeSignature.GetSystemType(System.Type[],System.Type[])" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.PinnedTypeSignature.GetReflectionWrapper(System.Type[],System.Type[])" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.PinnedTypeSignature.Translate(PostSharp.CodeModel.ModuleDeclaration)" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.PinnedTypeSignature.GetCanonicalHashCode" />
    <member name="P:PostSharp.CodeModel.TypeSignatures.PinnedTypeSignature.ElementType">
      <summary>
            Gets the underlying pointer type.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeSignatures.PinnedTypeSignature.Module" />
    <member name="T:PostSharp.CodeModel.TypeSignatures.PointerTypeSignature">
      <summary>
            Represents the type of a pointer (managed or unmanaged).
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignatures.PointerTypeSignature.#ctor(PostSharp.CodeModel.ITypeSignature,System.Boolean)">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.TypeSignatures.PointerTypeSignature" />.
            </summary>
      <param name="managed">Determines whether the pointer is managed.</param>
      <param name="innerType">Type of the instance referenced to by the pointer.</param>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSignatures.PointerTypeSignature.ToString" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.PointerTypeSignature.WriteReflectionTypeName(System.Text.StringBuilder,PostSharp.CodeModel.ReflectionNameOptions)" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.PointerTypeSignature.BelongsToClassification(PostSharp.CodeModel.TypeClassifications)" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.PointerTypeSignature.ContainsGenericArguments" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.PointerTypeSignature.MapGenericArguments(PostSharp.CodeModel.GenericMap)" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.PointerTypeSignature.GetValueSize(PostSharp.CodeModel.PlatformInfo)" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.PointerTypeSignature.GetReflectionWrapper(System.Type[],System.Type[])" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.PointerTypeSignature.GetSystemType(System.Type[],System.Type[])" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.PointerTypeSignature.Translate(PostSharp.CodeModel.ModuleDeclaration)" />
    <member name="M:PostSharp.CodeModel.TypeSignatures.PointerTypeSignature.GetCanonicalHashCode" />
    <member name="P:PostSharp.CodeModel.TypeSignatures.PointerTypeSignature.IsManaged">
      <summary>
            Determines whether the pointer is managed.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeSignatures.PointerTypeSignature.ElementType">
      <summary>
            Gets the type of the instance referenced to by pointers of this type.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeSignatures.PointerTypeSignature.Module" />
    <member name="T:PostSharp.CodeWeaver.ITypedExceptionAdvice">
      <summary>
            Exposes a method that allows advices of join points 
            <see cref="F:PostSharp.CodeWeaver.JoinPointKinds.AfterMethodBodyException" />
            to specify which exceptions should be caught.
            </summary>
      <remarks>
            If an advice is applied on a join point of type <see cref="F:PostSharp.CodeWeaver.JoinPointKinds.AfterMethodBodyException" />
            but does not implement this interface, all exceptions
            will be caught.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeWeaver.ITypedExceptionAdvice.GetExceptionType(PostSharp.CodeWeaver.WeavingContext)">
      <summary>
            Gets the type of exceptions that should be caughts for
            advices applied on join points of kind <see cref="F:PostSharp.CodeWeaver.JoinPointKinds.AfterMethodBodyException" />.
            </summary>
      <param name="context">The weaving context.</param>
      <returns>A <see cref="T:System.Type" /> (derived from <see cref="T:System.Exception" />),
            or <b>null</b> if any <see cref="T:System.Exception" /> is to be caught.</returns>
    </member>
    <member name="T:PostSharp.CodeWeaver.IBeforeStaticConstructorAdvice">
      <summary>
            Interface optionally implemented by advices on join points <see cref="F:PostSharp.CodeWeaver.JoinPointKinds.BeforeStaticConstructor" />,
            allowing to specify if the <b>BeforeFieldInit</b> class-level specifier is supported by this advice. An
            advice should return <b>true</b> if it only initializes static fields. The default, if the interface is
            not specified, is that this specifier is not specified.
            </summary>
    </member>
    <member name="P:PostSharp.CodeWeaver.IBeforeStaticConstructorAdvice.IsBeforeFieldInitSupported">
      <summary>
            Determines whether the advice is compatible with the <b>BeforeFieldInit</b>
            class-level specifier.
            </summary>
    </member>
    <member name="T:PostSharp.CodeWeaver.JoinPoint">
      <summary>
            A join point is a location in the code tree.
            </summary>
    </member>
    <member name="M:PostSharp.CodeWeaver.JoinPoint.ToString" />
    <member name="P:PostSharp.CodeWeaver.JoinPoint.Position">
      <summary>
            Current position w.r.t. the location (<see cref="F:PostSharp.CodeWeaver.JoinPointPosition.Before" />,
            <see cref="F:PostSharp.CodeWeaver.JoinPointPosition.InsteadOf" />, <see cref="F:PostSharp.CodeWeaver.JoinPointPosition.After" />).
            </summary>
    </member>
    <member name="P:PostSharp.CodeWeaver.JoinPoint.Instruction">
      <summary>
            Gets the current instruction.
            </summary>
    </member>
    <member name="P:PostSharp.CodeWeaver.JoinPoint.JoinPointKind">
      <summary>
            Kind of join point.
            </summary>
    </member>
    <member name="P:PostSharp.CodeWeaver.JoinPoint.ExceptionHandler">
      <summary>
            Current exception handler.
            </summary>
    </member>
    <member name="T:PostSharp.CodeWeaver.JoinPointPosition">
      <summary>
            Position of point points w.r.t. locations.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.JoinPointPosition.Before">
      <summary>
            Before the location.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.JoinPointPosition.After">
      <summary>
            After the location.
            </summary>
    </member>
    <member name="F:PostSharp.CodeWeaver.JoinPointPosition.InsteadOf">
      <summary>
            Instead of the current instruction.
            </summary>
    </member>
    <member name="T:PostSharp.CodeWeaver.WeavingContext">
      <summary>
            Context of the current join point.
            </summary>
    </member>
    <member name="M:PostSharp.CodeWeaver.WeavingContext.Dispose" />
    <member name="P:PostSharp.CodeWeaver.WeavingContext.IsThisInitialized">
      <summary>
            Determines whether the <b>this</b> pointer is initialized.
            </summary>
    </member>
    <member name="P:PostSharp.CodeWeaver.WeavingContext.Field">
      <summary>
            Gets the field being woven.
            </summary>
      <remarks>
            This property only meaningful in the context of
            <b>field-level</b> advices, i.e. advices that
            have been added with the <see cref="M:PostSharp.CodeWeaver.Weaver.AddFieldLevelAdvice(PostSharp.CodeWeaver.IAdvice,PostSharp.CodeWeaver.JoinPointKinds,System.Collections.Generic.IEnumerable{PostSharp.CodeModel.IField})" />.
            </remarks>
    </member>
    <member name="P:PostSharp.CodeWeaver.WeavingContext.FieldValueLocal">
      <summary>
            Gets the local variable in which the field value is stored.
            </summary>
      <remarks>
            This property only meaningful in the context of
            <b>field-level</b> advices, i.e. advices that
            have been added with the <see cref="M:PostSharp.CodeWeaver.Weaver.AddFieldLevelAdvice(PostSharp.CodeWeaver.IAdvice,PostSharp.CodeWeaver.JoinPointKinds,System.Collections.Generic.IEnumerable{PostSharp.CodeModel.IField})" />.
            </remarks>
    </member>
    <member name="P:PostSharp.CodeWeaver.WeavingContext.Method">
      <summary>
            Gets the current method.
            </summary>
    </member>
    <member name="P:PostSharp.CodeWeaver.WeavingContext.InstructionBlock">
      <summary>
            Gets the current instruction block.
            </summary>
    </member>
    <member name="P:PostSharp.CodeWeaver.WeavingContext.ReturnValueVariable">
      <summary>
            Gets the variable containing at runtime the return value, in join points of type
            <see cref="F:PostSharp.CodeWeaver.JoinPointKinds.AfterMethodBodyAlways" /> and 
            <see cref="F:PostSharp.CodeWeaver.JoinPointKinds.AfterMethodBodyException" /></summary>
    </member>
    <member name="P:PostSharp.CodeWeaver.WeavingContext.OnSuccessBranchTarget">
      <summary>
            Gets the <see cref="T:PostSharp.CodeModel.InstructionSequence" /> containing the current on-success handler
            in the chain.
            </summary>
      <seealso cref="P:PostSharp.CodeWeaver.WeavingContext.LeaveBranchTarget" />
    </member>
    <member name="P:PostSharp.CodeWeaver.WeavingContext.LeaveBranchTarget">
      <summary>
            Gets the <see cref="T:PostSharp.CodeModel.InstructionSequence" /> containing the next (i.e. immediately outer)
            on-success handler in the chain.
            </summary>
      <seealso cref="P:PostSharp.CodeWeaver.WeavingContext.OnSuccessBranchTarget" />
    </member>
    <member name="P:PostSharp.CodeWeaver.WeavingContext.ExceptionHandler">
      <summary>
            Gets the current exception handler.
            </summary>
    </member>
    <member name="P:PostSharp.CodeWeaver.WeavingContext.InstructionWriter">
      <summary>
            Gets an instance of <see cref="P:PostSharp.CodeWeaver.WeavingContext.InstructionWriter" /> shared by all advices.
            </summary>
    </member>
    <member name="P:PostSharp.CodeWeaver.WeavingContext.JoinPoint">
      <summary>
            Gets the current join point.
            </summary>
    </member>
    <member name="P:PostSharp.CodeWeaver.WeavingContext.WeavingHelper">
      <summary>
            Gets a <see cref="P:PostSharp.CodeWeaver.WeavingContext.WeavingHelper" />, which provides utility functions
            typically used during weaving.
            </summary>
    </member>
    <member name="P:PostSharp.CodeWeaver.WeavingContext.InstructionReader">
      <summary>
            Gets the <see cref="T:PostSharp.CodeModel.InstructionReader" /> located at
            the current instruction.
            </summary>
      <remarks>
            This property is exposed to implement some unrecommendable workarounds.
            Prefer the <b>JoinPoint.Instruction</b> property to get the current instruction.
            <b>You are supposed to leave the <see cref="P:PostSharp.CodeWeaver.WeavingContext.InstructionReader" /> at the
            same position as you received it!</b></remarks>
    </member>
    <member name="T:PostSharp.Collections.ExtensibleArray`1">
      <summary>
            Auto-extensible array composed of extends,
            with full thread safety and low lock retention.
            </summary>
      <typeparam name="T">Type of elements.</typeparam>
    </member>
    <member name="M:PostSharp.Collections.ExtensibleArray`1.#ctor(System.Int32)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Collections.ExtensibleArray`1" />
            with default extend size.
            </summary>
      <param name="initialCapacity">Initial array capacity.</param>
    </member>
    <member name="M:PostSharp.Collections.ExtensibleArray`1.#ctor(System.Int32,System.Int32)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Collections.ExtensibleArray`1" />
            and specifies the size of extends and the initial capacity.
            </summary>
      <param name="extendSize">Size of extends.</param>
      <param name="initialCapacity">Initial capacity (number of items, not extends).</param>
    </member>
    <member name="M:PostSharp.Collections.ExtensibleArray`1.GetEnumerator" />
    <member name="P:PostSharp.Collections.ExtensibleArray`1.Item(System.Int32)">
      <summary>
            Gets or sets an array item.
            </summary>
      <param name="index">Index.</param>
      <returns>The item at position <paramref name="index" />.</returns>
    </member>
    <member name="P:PostSharp.Collections.ExtensibleArray`1.UpperBound">
      <summary>
            Gives the array upper bound. 
            </summary>
      <remarks>
            The array is guaranteed to contain less than
            <see cref="P:PostSharp.Collections.ExtensibleArray`1.UpperBound" /> items.
            </remarks>
    </member>
    <member name="T:PostSharp.Collections.IMultiDictionary`2">
      <summary>
            Specifies a dictionary possibly associating many items to a single key.
            </summary>
      <typeparam name="K">Type of keys.</typeparam>
      <typeparam name="V">Type of values.</typeparam>
    </member>
    <member name="M:PostSharp.Collections.IMultiDictionary`2.Add(`0,`1)">
      <summary>
            Adds a key-value pair in the dictionary.
            </summary>
      <param name="key">Key.</param>
      <param name="value">Value.</param>
    </member>
    <member name="M:PostSharp.Collections.IMultiDictionary`2.ContainsKey(`0)">
      <summary>
            Determines whether the dictionary contains at least one value
            associated to a given key.
            </summary>
      <param name="key">Key.</param>
      <returns>
        <b>true</b> if the dictionary contains at least one value
            associated with <paramref name="key" />, otherwise <b>false</b>.</returns>
    </member>
    <member name="P:PostSharp.Collections.IMultiDictionary`2.Keys">
      <summary>
            Gets the collection of keys.
            </summary>
    </member>
    <member name="P:PostSharp.Collections.IMultiDictionary`2.Item(`0)">
      <summary>
            Gets the list of values associated with a given key.
            </summary>
      <param name="key">Key.</param>
      <returns>The list of values associated with <paramref name="key" />.</returns>
    </member>
    <member name="T:PostSharp.Collections.MarshalByRefCollection`1">
      <summary>
            Implementation of generic <see cref="T:System.Collections.Generic.ICollection`1" /> marshalled by reference.
            </summary>
      <typeparam name="T">Type of items.</typeparam>
    </member>
    <member name="M:PostSharp.Collections.MarshalByRefCollection`1.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Collections.MarshalByRefCollection`1" /> with a <see cref="T:System.Collections.Generic.List`1" />
            as the underlying implementation.
            </summary>
    </member>
    <member name="M:PostSharp.Collections.MarshalByRefCollection`1.#ctor(System.Collections.Generic.ICollection{`0})">
      <summary>
            Initializes a new <see cref="T:PostSharp.Collections.MarshalByRefCollection`1" /> and specifies the
            underlying implementation.
            </summary>
      <param name="implementation">The underlying implementation,
            or the collection to wrap.</param>
    </member>
    <member name="M:PostSharp.Collections.MarshalByRefCollection`1.Add(`0)" />
    <member name="M:PostSharp.Collections.MarshalByRefCollection`1.Clear" />
    <member name="M:PostSharp.Collections.MarshalByRefCollection`1.Contains(`0)" />
    <member name="M:PostSharp.Collections.MarshalByRefCollection`1.CopyTo(`0[],System.Int32)" />
    <member name="M:PostSharp.Collections.MarshalByRefCollection`1.Remove(`0)" />
    <member name="M:PostSharp.Collections.MarshalByRefCollection`1.GetEnumerator" />
    <member name="P:PostSharp.Collections.MarshalByRefCollection`1.Count" />
    <member name="P:PostSharp.Collections.MarshalByRefCollection`1.IsReadOnly" />
    <member name="T:PostSharp.Collections.MarshalByRefDictionary`2">
      <summary>
            Implementation of generic <see cref="T:System.Collections.Generic.IDictionary`2" /> marshalled by reference.
            </summary>
      <typeparam name="V">Type of values.</typeparam>
      <typeparam name="K">Type of keys.</typeparam>
    </member>
    <member name="M:PostSharp.Collections.MarshalByRefDictionary`2.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Collections.MarshalByRefDictionary`2" /> with a <see cref="T:System.Collections.Generic.Dictionary`2" />
            as the underlying implementation.
            </summary>
    </member>
    <member name="M:PostSharp.Collections.MarshalByRefDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
      <summary>
            Initializes a new <see cref="T:PostSharp.Collections.MarshalByRefDictionary`2" /> and specifies the
            underlying implementation.
            </summary>
      <param name="implementation">The underlying implementation,
            or the collection to wrap.</param>
    </member>
    <member name="M:PostSharp.Collections.MarshalByRefDictionary`2.Add(`0,`1)" />
    <member name="M:PostSharp.Collections.MarshalByRefDictionary`2.ContainsKey(`0)" />
    <member name="M:PostSharp.Collections.MarshalByRefDictionary`2.Remove(`0)" />
    <member name="M:PostSharp.Collections.MarshalByRefDictionary`2.TryGetValue(`0,`1@)" />
    <member name="M:PostSharp.Collections.MarshalByRefDictionary`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})" />
    <member name="M:PostSharp.Collections.MarshalByRefDictionary`2.Clear" />
    <member name="M:PostSharp.Collections.MarshalByRefDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})" />
    <member name="M:PostSharp.Collections.MarshalByRefDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)" />
    <member name="M:PostSharp.Collections.MarshalByRefDictionary`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})" />
    <member name="M:PostSharp.Collections.MarshalByRefDictionary`2.GetEnumerator" />
    <member name="P:PostSharp.Collections.MarshalByRefDictionary`2.Keys" />
    <member name="P:PostSharp.Collections.MarshalByRefDictionary`2.Values" />
    <member name="P:PostSharp.Collections.MarshalByRefDictionary`2.Item(`0)" />
    <member name="P:PostSharp.Collections.MarshalByRefDictionary`2.Count" />
    <member name="P:PostSharp.Collections.MarshalByRefDictionary`2.IsReadOnly" />
    <member name="T:PostSharp.Collections.MultiDictionary`2">
      <summary>
            Associates many values to a single key.
            </summary>
      <typeparam name="TKey">Type of keys.</typeparam>
      <typeparam name="TValue">Type of values.</typeparam>
      <remarks>
        <para>
            The default implementation of this <see cref="T:PostSharp.Collections.MultiDictionary`2" /> uses
            a <see cref="T:System.Collections.Generic.Dictionary`2" />. 
            However, it is possible to use other implementations by deriving this
            class and overriding the <see cref="M:PostSharp.Collections.MultiDictionary`2.InternalCreateDictionary(System.Int32)" />, <see cref="M:PostSharp.Collections.MultiDictionary`2.InternalTryGetValue(`0,PostSharp.Collections.MultiDictionary{`0,`1}.LinkedListHeader@)" />
            methods. The underlying implementation can be accessed by derived classes 
            thanks to the <see cref="P:PostSharp.Collections.MultiDictionary`2.Implementation" />
            property.
            </para>
        <para>
            The creation of the underlying dictionary is defered to the first element
            addition. This allows to have empty dictionaries at relatively low cost.
            </para>
      </remarks>
    </member>
    <member name="M:PostSharp.Collections.MultiDictionary`2.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Collections.MultiDictionary`2" /> with default capacity.
            </summary>
    </member>
    <member name="M:PostSharp.Collections.MultiDictionary`2.#ctor(System.Int32)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Collections.MultiDictionary`2" /> and sets the
            initial capacity of the first-level dictionary (number of keys).
            </summary>
      <param name="capacity">Initial capacity of unique keys.</param>
    </member>
    <member name="M:PostSharp.Collections.MultiDictionary`2.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Initializes a new <see cref="T:PostSharp.Collections.MultiDictionary`2" />, sets the initial
            capacity of the first-level dictionary (number of keys) and
            gives a non-default comparer of equality of keys,
            </summary>
      <param name="capacity">Initial capacity of unique keys.</param>
      <param name="comparer">Equality comparer for keys.</param>
    </member>
    <member name="M:PostSharp.Collections.MultiDictionary`2.Add(`0,`1)" />
    <member name="M:PostSharp.Collections.MultiDictionary`2.AddRange(System.Collections.Generic.ICollection{System.Collections.Generic.KeyValuePair{`0,`1}})">
      <summary>
            Adds a collection of values in the current dictionary.
            </summary>
      <param name="values">A collection of key-value pairs.</param>
    </member>
    <member name="M:PostSharp.Collections.MultiDictionary`2.Merge(PostSharp.Collections.MultiDictionary{`0,`1})">
      <summary>
            Merges a <see cref="T:PostSharp.Collections.MultiDictionary`2" /> into the current instance.
            </summary>
      <param name="values">Dictionary to be merged</param>
    </member>
    <member name="M:PostSharp.Collections.MultiDictionary`2.ContainsKey(`0)">
      <summary>
            Determines whether the dictionary contains at least one value
            associated to a given key.
            </summary>
      <param name="key">Key.</param>
      <returns>
        <b>true</b> if the dictionary contains at least one value
            associated with <paramref name="key" />, otherwise <b>false</b>.</returns>
    </member>
    <member name="M:PostSharp.Collections.MultiDictionary`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})" />
    <member name="M:PostSharp.Collections.MultiDictionary`2.Clear" />
    <member name="M:PostSharp.Collections.MultiDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})" />
    <member name="M:PostSharp.Collections.MultiDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)" />
    <member name="M:PostSharp.Collections.MultiDictionary`2.GetCountByKey(`0)">
      <summary>
            Gets the number of items registered under a given key.
            </summary>
      <param name="key">Key.</param>
      <returns>The number of items registered under <paramref name="key" />.</returns>
    </member>
    <member name="M:PostSharp.Collections.MultiDictionary`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})" />
    <member name="M:PostSharp.Collections.MultiDictionary`2.Remove(`0,`1)" />
    <member name="M:PostSharp.Collections.MultiDictionary`2.GetEnumerator" />
    <member name="P:PostSharp.Collections.MultiDictionary`2.Capacity">
      <summary>
            Gets or sets the expected number of keys.
            </summary>
    </member>
    <member name="P:PostSharp.Collections.MultiDictionary`2.Keys">
      <summary>
            Gets the collection of keys.
            </summary>
    </member>
    <member name="P:PostSharp.Collections.MultiDictionary`2.Item(`0)">
      <summary>
            Gets the list of values associated with a given key.
            </summary>
      <param name="key">Key.</param>
      <returns>The list of values associated with <paramref name="key" />.</returns>
    </member>
    <member name="P:PostSharp.Collections.MultiDictionary`2.Count" />
    <member name="P:PostSharp.Collections.MultiDictionary`2.IsReadOnly" />
    <member name="T:PostSharp.Collections.MultiDictionaryFactory`2">
      <summary>
            Factory for <see cref="T:PostSharp.Collections.MultiDictionary`2" />.
            </summary>
      <typeparam name="TKey">Type of keys.</typeparam>
      <typeparam name="TValue">Type of values.</typeparam>
    </member>
    <member name="F:PostSharp.Collections.MultiDictionaryFactory`2.Default">
      <summary>
            Default instance, using the default equality comparer.
            </summary>
    </member>
    <member name="M:PostSharp.Collections.MultiDictionaryFactory`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Initializes a new <see cref="T:PostSharp.Collections.MultiDictionaryFactory`2" /> and specifies the equality comparer.
            </summary>
      <param name="comparer">Equality comparer.</param>
    </member>
    <member name="M:PostSharp.Collections.MultiDictionaryFactory`2.CreateCollection" />
    <member name="M:PostSharp.Collections.MultiDictionaryFactory`2.CreateCollection(System.Int32)" />
    <member name="M:PostSharp.Collections.MultiDictionaryFactory`2.EnsureCapacity(System.Collections.Generic.ICollection{System.Collections.Generic.KeyValuePair{`0,`1}},System.Int32)" />
    <member name="T:PostSharp.Collections.Pair`2">
      <summary>
            Typed pair of values.
            </summary>
      <typeparam name="T1">Type of the first value.</typeparam>
      <typeparam name="T2">Type of the second value.</typeparam>
    </member>
    <member name="M:PostSharp.Collections.Pair`2.#ctor(`0,`1)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Collections.Pair`2" /> of values.
            </summary>
      <param name="first">First value.</param>
      <param name="second">Second value.</param>
    </member>
    <member name="M:PostSharp.Collections.Pair`2.Equals(PostSharp.Collections.Pair{`0,`1})" />
    <member name="M:PostSharp.Collections.Pair`2.Equals(System.Object)" />
    <member name="M:PostSharp.Collections.Pair`2.op_Equality(PostSharp.Collections.Pair{`0,`1},PostSharp.Collections.Pair{`0,`1})">
      <summary>
            Determines whether two instances are equal.
            </summary>
      <param name="left">A pair.</param>
      <param name="right">AA pair.</param>
      <returns>
        <b>true</b> if both instances are equal, otherwise <b>false</b>.</returns>
    </member>
    <member name="M:PostSharp.Collections.Pair`2.op_Inequality(PostSharp.Collections.Pair{`0,`1},PostSharp.Collections.Pair{`0,`1})">
      <summary>
            Determines whether two instances are different.
            </summary>
      <param name="left">A pair.</param>
      <param name="right">A pair.</param>
      <returns>
        <b>true</b> if both instances are different, otherwise <b>false</b>.</returns>
    </member>
    <member name="M:PostSharp.Collections.Pair`2.GetHashCode" />
    <member name="P:PostSharp.Collections.Pair`2.First">
      <summary>
            Gets the first value.
            </summary>
    </member>
    <member name="P:PostSharp.Collections.Pair`2.Second">
      <summary>
            Gets the second value.
            </summary>
    </member>
    <member name="T:PostSharp.Collections.Set`1">
      <summary>
            Collection with uniqueness constraint and with read complexity in O(1).
            </summary>
      <typeparam name="T">Name of elements.</typeparam>
    </member>
    <member name="M:PostSharp.Collections.Set`1.#ctor(System.Int32)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Collections.Set`1" /> and specifies the initial capacity.
            </summary>
      <param name="capacity">Initial capacity.</param>
    </member>
    <member name="M:PostSharp.Collections.Set`1.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Collections.Set`1" /> with default capacity.
            </summary>
    </member>
    <member name="M:PostSharp.Collections.Set`1.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Initializes a new <see cref="T:PostSharp.Collections.Set`1" /> and specifies the initial capacity
            and the comparer.
            </summary>
      <param name="capacity">Initial capacity.</param>
      <param name="comparer">Comparer.</param>
    </member>
    <member name="M:PostSharp.Collections.Set`1.Add(`0)" />
    <member name="M:PostSharp.Collections.Set`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Adds a range of new items to the current set.
            </summary>
      <param name="items">Collection of items to be added. None of these
            items can be already be a part of the collection.</param>
    </member>
    <member name="M:PostSharp.Collections.Set`1.AddIfAbsent(`0)">
      <summary>
            Adds an item to the set if this set does not yet contain this item.
            </summary>
      <param name="item">The item to add.</param>
      <returns>
        <b>true</b> if the item was added, or <b>false</b> if the
            item was already present.</returns>
    </member>
    <member name="M:PostSharp.Collections.Set`1.Union(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Merge another collection in the current set.
            </summary>
      <param name="items">Collection of items (eventually with
            duplicates or items already present in the current collection).</param>
    </member>
    <member name="M:PostSharp.Collections.Set`1.Difference(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Removes a set of items from the current set.
            </summary>
      <param name="items">Collection of items to be removed from the current set.</param>
    </member>
    <member name="M:PostSharp.Collections.Set`1.Clear" />
    <member name="M:PostSharp.Collections.Set`1.Contains(`0)" />
    <member name="M:PostSharp.Collections.Set`1.CopyTo(`0[],System.Int32)" />
    <member name="M:PostSharp.Collections.Set`1.Remove(`0)" />
    <member name="M:PostSharp.Collections.Set`1.GetEnumerator" />
    <member name="M:PostSharp.Collections.Set`1.GetUnion(PostSharp.Collections.Set{`0})">
      <summary>
            Gets the union of the current set with another.
            </summary>
      <param name="set">Second set.</param>
      <returns>A new set which the union between the current set and <paramref name="set" />.</returns>
    </member>
    <member name="M:PostSharp.Collections.Set`1.GetIntersection(PostSharp.Collections.Set{`0})">
      <summary>
            Gets the intersection of the current set with another.
            </summary>
      <param name="set">Second set.</param>
      <returns>A new set which the intersection between the current set and <paramref name="set" />.</returns>
    </member>
    <member name="M:PostSharp.Collections.Set`1.GetDifference(PostSharp.Collections.Set{`0})">
      <summary>
            Gets the difference of the current set with another.
            </summary>
      <param name="set">Second set.</param>
      <returns>A new set which the difference between the current set and <paramref name="set" />.</returns>
    </member>
    <member name="M:PostSharp.Collections.Set`1.CreateSiblingInstance(System.Int32)">
      <summary>
            Creates a well-typed instance; used by for operations
            <see cref="M:PostSharp.Collections.Set`1.GetUnion(PostSharp.Collections.Set{`0})" />, <see cref="M:PostSharp.Collections.Set`1.GetIntersection(PostSharp.Collections.Set{`0})" />
            and <see cref="M:PostSharp.Collections.Set`1.GetDifference(PostSharp.Collections.Set{`0})" /> to create the new set.
            </summary>
      <param name="capacity">Capacity of the new set.</param>
      <returns>A new set of capacity <paramref name="capacity" />.</returns>
    </member>
    <member name="P:PostSharp.Collections.Set`1.Count" />
    <member name="P:PostSharp.Collections.Set`1.IsReadOnly" />
    <member name="T:PostSharp.Collections.Singleton`1">
      <summary>
            Wraps a single value into a list. A singleton contains zero or one value.
            </summary>
      <typeparam name="V">Value type.</typeparam>
    </member>
    <member name="M:PostSharp.Collections.Singleton`1.#ctor(`0)">
      <summary>
            Initializes a new read-only <see cref="T:PostSharp.Collections.Singleton`1" /> containing one element
            </summary>
      <param name="value">Value.</param>
    </member>
    <member name="M:PostSharp.Collections.Singleton`1.#ctor(`0,System.Boolean)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Collections.Singleton`1" /> containing one element
            and specifies whether the collection should be read-only.
            </summary>
      <param name="value">Initial value.</param>
      <param name="readOnly">
        <b>true</b> the singleton is read-only, <b>false</b>
            if the value can be removed or overwritten.</param>
    </member>
    <member name="M:PostSharp.Collections.Singleton`1.IndexOf(`0)" />
    <member name="M:PostSharp.Collections.Singleton`1.Insert(System.Int32,`0)" />
    <member name="M:PostSharp.Collections.Singleton`1.RemoveAt(System.Int32)" />
    <member name="M:PostSharp.Collections.Singleton`1.Add(`0)" />
    <member name="M:PostSharp.Collections.Singleton`1.Clear" />
    <member name="M:PostSharp.Collections.Singleton`1.Contains(`0)" />
    <member name="M:PostSharp.Collections.Singleton`1.CopyTo(`0[],System.Int32)" />
    <member name="M:PostSharp.Collections.Singleton`1.Remove(`0)" />
    <member name="M:PostSharp.Collections.Singleton`1.GetEnumerator" />
    <member name="P:PostSharp.Collections.Singleton`1.Item(System.Int32)" />
    <member name="P:PostSharp.Collections.Singleton`1.Count" />
    <member name="P:PostSharp.Collections.Singleton`1.IsReadOnly" />
    <member name="T:PostSharp.Collections.SingletonEnumerator`1">
      <summary>
            Enumerator that returns a single value.
            </summary>
      <typeparam name="T">Value type.</typeparam>
    </member>
    <member name="M:PostSharp.Collections.SingletonEnumerator`1.#ctor(`0)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Collections.SingletonEnumerator`1" /></summary>
      <param name="value">Value returned by the <see cref="P:PostSharp.Collections.SingletonEnumerator`1.Current" /> property.</param>
    </member>
    <member name="M:PostSharp.Collections.SingletonEnumerator`1.Dispose" />
    <member name="M:PostSharp.Collections.SingletonEnumerator`1.MoveNext" />
    <member name="M:PostSharp.Collections.SingletonEnumerator`1.Reset" />
    <member name="P:PostSharp.Collections.SingletonEnumerator`1.Current" />
    <member name="T:PostSharp.Collections.SortedMultiDictionary`2">
      <summary>
        <see cref="T:PostSharp.Collections.MultiDictionary`2" /> where keys are ordered.
            </summary>
      <typeparam name="TKey">Type of keys.</typeparam>
      <typeparam name="TValue">Type of values.</typeparam>
    </member>
    <member name="M:PostSharp.Collections.SortedMultiDictionary`2.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Collections.SortedMultiDictionary`2" /> with default capacity.
            </summary>
    </member>
    <member name="M:PostSharp.Collections.SortedMultiDictionary`2.#ctor(System.Int32)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Collections.SortedMultiDictionary`2" /> and sets the initial capacity.
            </summary>
      <param name="capacity">Initial capacity of unique keys.</param>
    </member>
    <member name="T:PostSharp.Collections.SortedMultiDictionaryFactory`2">
      <summary>
            Factory for <see cref="T:PostSharp.Collections.SortedMultiDictionary`2" />.
            </summary>
      <typeparam name="TKey">Type of keys.</typeparam>
      <typeparam name="TValue">Type of values.</typeparam>
    </member>
    <member name="F:PostSharp.Collections.SortedMultiDictionaryFactory`2.Default">
      <summary>
            Singleton instance.
            </summary>
    </member>
    <member name="M:PostSharp.Collections.SortedMultiDictionaryFactory`2.CreateCollection" />
    <member name="M:PostSharp.Collections.SortedMultiDictionaryFactory`2.CreateCollection(System.Int32)" />
    <member name="M:PostSharp.Collections.SortedMultiDictionaryFactory`2.EnsureCapacity(System.Collections.Generic.ICollection{System.Collections.Generic.KeyValuePair{`0,`1}},System.Int32)" />
    <member name="T:PostSharp.Collections.Specialized.StringSet">
      <summary>
            Set of strings.
            </summary>
    </member>
    <member name="M:PostSharp.Collections.Specialized.StringSet.#ctor(System.Int32)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Collections.Specialized.StringSet" /> and specifies the initial capacity.
            </summary>
      <param name="capacity">Initial capacity.</param>
    </member>
    <member name="M:PostSharp.Collections.Specialized.StringSet.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Collections.Specialized.StringSet" /> with default initial capacity.
            </summary>
    </member>
    <member name="T:PostSharp.ExceptionHelper">
      <summary>
            Provides methods that retrieve exception messages from an embedded 
            resource and throws an exception.
            </summary>
    </member>
    <member name="M:PostSharp.ExceptionHelper.#ctor(System.Resources.ResourceManager)">
      <summary>
            Initializes a new <see cref="T:PostSharp.ExceptionHelper" />.
            </summary>
      <param name="resourceManager">Resources containing message definitions.</param>
    </member>
    <member name="M:PostSharp.ExceptionHelper.AssertArgumentNotNull(System.Object,System.String)">
      <summary>
            Throws an <see cref="T:System.ArgumentNullException" /> if a reference is null.
            </summary>
      <param name="value">An object reference.</param>
      <param name="parameterName">Parameter name.</param>
    </member>
    <member name="M:PostSharp.ExceptionHelper.AssumeNotNull(System.Object)">
      <summary>
            Tells the static analyser that the given reference is trusted to be non-null.
            </summary>
      <param name="value">An object reference.</param>
    </member>
    <member name="M:PostSharp.ExceptionHelper.AssertArgumentNotNull(System.Void*,System.String)">
      <summary>
            Throws an <see cref="T:System.ArgumentNullException" /> if a pointer is null.
            </summary>
      <param name="value">A pointer.</param>
      <param name="parameterName">Parameter name.</param>
    </member>
    <member name="M:PostSharp.ExceptionHelper.AssertArgumentNotEmptyOrNull(System.String,System.String)">
      <summary>
            Throws an <see cref="T:System.ArgumentNullException" /> if a string reference is null
            or if the referenced string is emptu.
            </summary>
      <param name="value">A string reference.</param>
      <param name="parameterName">Parameter name.</param>
    </member>
    <member name="M:PostSharp.ExceptionHelper.AssertValidOperation(System.Boolean,System.String,System.Object[])">
      <summary>
            Conditionally throws an <see cref="T:System.InvalidOperationException" /> (message
            withparameters).
            </summary>
      <param name="condition">
        <b>false</b> to throw the exception, otherwise <b>true</b>.</param>
      <param name="messageKey">Key of the resource string containing the message.
            The message may contain arguments like {0}, {1}, ...</param>
      <param name="arguments">Arguments of the formatting string.</param>
    </member>
    <member name="M:PostSharp.ExceptionHelper.CreateInvalidOperationException(System.String,System.Object[])">
      <summary>
            Creates an <see cref="T:System.InvalidOperationException" />.
            </summary>
      <param name="messageKey">Key of the resource string containing the message.
            The message may contain arguments like {0}, {1}, ...</param>
      <param name="arguments">Arguments of the formatting string.</param>
    </member>
    <member name="M:PostSharp.ExceptionHelper.CreateFileNotFoundException(System.String,System.String,System.Object[])">
      <summary>
            Creates an <see cref="T:System.IO.FileNotFoundException" />.
            </summary>
      <param name="fileName">Path of the file that was not found.</param>
      <param name="messageKey">Key of the resource string containing the message.
            The message may contain arguments like {0}, {1}, ...</param>
      <param name="arguments">Arguments of the formatting string.</param>
    </member>
    <member name="M:PostSharp.ExceptionHelper.CreateBindingException(System.String,System.Object[])">
      <summary>
            Creates an <see cref="T:PostSharp.CodeModel.BindingException" />.
            </summary>
      <param name="messageKey">Key of the resource string containing the message.
            The message may contain arguments like {0}, {1}, ...</param>
      <param name="arguments">Arguments of the formatting string.</param>
    </member>
    <member name="M:PostSharp.ExceptionHelper.CreateBindingException(System.String,System.Exception,System.Object[])">
      <summary>
            Creates an <see cref="T:PostSharp.CodeModel.BindingException" /> and includes an inner exception.
            </summary>
      <param name="messageKey">Key of the resource string containing the message.
            The message may contain arguments like {0}, {1}, ...</param>
      <param name="innerException">The exception that is wrapped by the new exception.</param>
      <param name="arguments">Arguments of the formatting string.</param>
    </member>
    <member name="M:PostSharp.ExceptionHelper.CreateArgumentException(System.String,System.String,System.Object[])">
      <summary>
            Creates an <see cref="T:System.ArgumentException" />.
            </summary>
      <param name="parameterName">Name of the incorrect parameter.</param>
      <param name="messageKey">Key of the resource string containing the message.
            The message may contain arguments like {0}, {1}, ...</param>
      <param name="arguments">Arguments of the formatting string.</param>
    </member>
    <member name="M:PostSharp.ExceptionHelper.AssertValidArgument(System.Boolean,System.String,System.String,System.Object[])">
      <summary>
            Throws an <see cref="T:System.ArgumentException" /> if a condition is not fulfilled.
            </summary>
      <param name="condition">Condition. Should be true, otherwise an exception is thrown.</param>
      <param name="parameterName">Name of the tested parameter.</param>
      <param name="messageKey">Key of the resource string containing the message.
            The message may contain arguments like {0}, {1}, ...</param>
      <param name="arguments">Arguments of the formatting string.</param>
    </member>
    <member name="M:PostSharp.ExceptionHelper.GetMessage(System.String)">
      <summary>
            Gets an exception message.
            </summary>
      <param name="messageKey">Key of the resource string containing the message.</param>
      <returns>The message corresponding to <paramref name="messageKey" />. The text
            may be a formatting string containing parameters like {0}, {1}, ...</returns>
    </member>
    <member name="M:PostSharp.ExceptionHelper.GetMessage(System.String,System.Object[])">
      <summary>
            Gets an exception message from resources and format it using arguments.
            </summary>
      <param name="messageKey">Key of the resource string containing the message.</param>
      <param name="arguments">Arguments of the formatting string.</param>
      <returns>The message corresponding to <paramref name="messageKey" /> formatted using <paramref name="arguments" />.</returns>
    </member>
    <member name="M:PostSharp.ExceptionHelper.CreateInvalidEnumerationValueException(System.Object,System.String)">
      <summary>
            Creates an <see cref="T:PostSharp.AssertionFailedException" /> with a message telling
            that an enumeration contained an unexpected value.
            </summary>
      <param name="value">Enumeration value.</param>
      <param name="location">Name of the variable or field containing the enumeration value.</param>
      <returns>An <see cref="T:PostSharp.AssertionFailedException" />.</returns>
    </member>
    <member name="M:PostSharp.ExceptionHelper.CreateAssertionFailedException(System.String,System.Object[])">
      <summary>
            Creates an <see cref="T:PostSharp.AssertionFailedException" /> and reads the message from
            the resource manager.
            </summary>
      <param name="messageKey">Key of the resource string containing the message.
            The message may contain arguments like {0}, {1}, ...</param>
      <param name="arguments">Arguments of the formatting string.</param>
      <returns>An <see cref="T:PostSharp.AssertionFailedException" />.</returns>
    </member>
    <member name="M:PostSharp.ExceptionHelper.Assert(System.Boolean,System.String,System.Object[])">
      <summary>
            Throws an <see cref="T:PostSharp.AssertionFailedException" /> if a condition is not fulfilled.
            </summary>
      <param name="condition">Condition. Should be true, otherwise an exception is thrown.</param>
      <param name="messageKey">Key of the resource string containing the message.
            The message may contain arguments like {0}, {1}, ...</param>
      <param name="arguments">Arguments of the formatting string.</param>
    </member>
    <member name="T:PostSharp.CodeModel.InstructionWriter">
      <summary>
            writer a linear stream of instructions into an <see cref="T:PostSharp.CodeModel.InstructionSequence" />.
            </summary>
      <remarks>
            After having been instantiated, the <see cref="T:PostSharp.CodeModel.InstructionWriter" /> should
            be associated to an <see cref="T:PostSharp.CodeModel.InstructionSequence" /> using the 
            <see cref="M:PostSharp.CodeModel.InstructionWriter.AttachInstructionSequence(PostSharp.CodeModel.InstructionSequence)" />. After all instructions have been written,
            the <see cref="M:PostSharp.CodeModel.InstructionWriter.DetachInstructionSequence" /> method should be called. 
            </remarks>
    </member>
    <member name="T:PostSharp.ModuleWriter.InstructionEmitter">
      <summary>
            Provides the base operations for emitting IL instructions. This abstract class
            does not specify to which kind of target instructions are written. This is specific
            to classes deriving <see cref="T:PostSharp.ModuleWriter.InstructionEmitter" />.
            </summary>
    </member>
    <member name="M:PostSharp.ModuleWriter.InstructionEmitter.FindBranchingOpCode(PostSharp.CodeModel.OpCodeNumber,PostSharp.CodeModel.OpCodeNumber@,PostSharp.CodeModel.OpCodeNumber@)">
      <summary>
            Given an arbitrary branching opcode, looks up the corresponding near and
            far opcodes.
            </summary>
      <param name="opCode">An arbitrary branching opcode (short or long).</param>
      <param name="nearOpCode">The near variant of <paramref name="opCode" />.</param>
      <param name="farOpCode">The far variant of <paramref name="opCode" />.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.InstructionEmitter.InternalEmitSymbolSequencePoint(PostSharp.CodeModel.SymbolSequencePoint)">
      <summary>
            Emits a symbol sequence point.
            </summary>
      <param name="sequencePoint">A <see cref="T:PostSharp.CodeModel.SymbolSequencePoint" />.</param>
      <remarks>
            This method is called internally after preconditions have been checked. Derived
            classes should not check preconditions.
            </remarks>
    </member>
    <member name="M:PostSharp.ModuleWriter.InstructionEmitter.InternalEmitPrefix(PostSharp.CodeModel.InstructionPrefixes)">
      <summary>
            Emits a prefix without operand.
            </summary>
      <param name="prefix">A combination of prefixes.</param>
      <remarks>
            This method is called internally after preconditions have been checked. Derived
            classes should not check preconditions.
            </remarks>
    </member>
    <member name="M:PostSharp.ModuleWriter.InstructionEmitter.InternalEmitPrefixType(PostSharp.CodeModel.OpCodeNumber,PostSharp.CodeModel.ITypeSignature)">
      <summary>
            Emits a prefix with an <see cref="T:PostSharp.CodeModel.IType" /> operand.
            </summary>
      <param name="prefix">A single prefix (without operand).</param>
      <param name="type">An <see cref="T:PostSharp.CodeModel.IType" />.</param>
      <remarks>
            This method is called internally after preconditions have been checked. Derived
            classes should not check preconditions.
            </remarks>
    </member>
    <member name="M:PostSharp.ModuleWriter.InstructionEmitter.InternalEmitInstruction(PostSharp.CodeModel.OpCodeNumber)">
      <summary>
            Emits an instruction without operand.
            </summary>
      <param name="code">The instruction opcode.</param>
      <remarks>
            This method is called internally after preconditions have been checked. Derived
            classes should not check preconditions.
            </remarks>
    </member>
    <member name="M:PostSharp.ModuleWriter.InstructionEmitter.InternalEmitInstructionField(PostSharp.CodeModel.OpCodeNumber,PostSharp.CodeModel.IField)">
      <summary>
            Emits an instruction with an <see cref="T:PostSharp.CodeModel.IField" /> operand.
            </summary>
      <param name="code">The instruction code.</param>
      <param name="field">The <see cref="T:PostSharp.CodeModel.IField" /> operand.</param>
      <remarks>
            This method is called internally after preconditions have been checked. Derived
            classes should not check preconditions.
            </remarks>
    </member>
    <member name="M:PostSharp.ModuleWriter.InstructionEmitter.InternalEmitInstructionByte(PostSharp.CodeModel.OpCodeNumber,System.Byte)">
      <summary>
            Emits an instruction with a <see cref="T:System.Byte" /> operand.
            </summary>
      <param name="code">The instruction code.</param>
      <param name="operand">The <see cref="T:System.Byte" /> operand.</param>
      <remarks>
            This method is called internally after preconditions have been checked. Derived
            classes should not check preconditions.
            </remarks>
    </member>
    <member name="M:PostSharp.ModuleWriter.InstructionEmitter.InternalEmitInstructionInt64(PostSharp.CodeModel.OpCodeNumber,System.Int64)">
      <summary>
            Emits an instruction with an <see cref="T:System.Int64" /> operand.
            </summary>
      <param name="code">The instruction code.</param>
      <param name="operand">The <see cref="T:System.Int64" /> operand.</param>
      <remarks>
            This method is called internally after preconditions have been checked. Derived
            classes should not check preconditions.
            </remarks>
    </member>
    <member name="M:PostSharp.ModuleWriter.InstructionEmitter.InternalEmitInstructionInt32(PostSharp.CodeModel.OpCodeNumber,System.Int32)">
      <summary>
            Emits an instruction with an <see cref="T:System.Int64" /> operand.
            </summary>
      <param name="code">The instruction code.</param>
      <param name="operand">The <see cref="T:System.Int64" /> operand.</param>
      <remarks>
            This method is called internally after preconditions have been checked. Derived
            classes should not check preconditions.
            </remarks>
    </member>
    <member name="M:PostSharp.ModuleWriter.InstructionEmitter.InternalEmitInstructionInt16(PostSharp.CodeModel.OpCodeNumber,System.Int16)">
      <summary>
            Emits an instruction with an <see cref="T:System.Int16" /> operand.
            </summary>
      <param name="code">The instruction code.</param>
      <param name="operand">The <see cref="T:System.Int16" /> operand.</param>
      <remarks>
            This method is called internally after preconditions have been checked. Derived
            classes should not check preconditions.
            </remarks>
    </member>
    <member name="M:PostSharp.ModuleWriter.InstructionEmitter.InternalEmitInstructionSingle(PostSharp.CodeModel.OpCodeNumber,System.Single)">
      <summary>
            Emits an instruction with an <see cref="T:System.Single" /> operand.
            </summary>
      <param name="code">The instruction code.</param>
      <param name="operand">The <see cref="T:System.Single" /> operand.</param>
      <remarks>
            This method is called internally after preconditions have been checked. Derived
            classes should not check preconditions.
            </remarks>
    </member>
    <member name="M:PostSharp.ModuleWriter.InstructionEmitter.InternalEmitInstructionDouble(PostSharp.CodeModel.OpCodeNumber,System.Double)">
      <summary>
            Emits an instruction with an <see cref="T:System.Double" /> operand.
            </summary>
      <param name="code">The instruction code.</param>
      <param name="operand">The <see cref="T:System.Double" /> operand.</param>
      <remarks>
            This method is called internally after preconditions have been checked. Derived
            classes should not check preconditions.
            </remarks>
    </member>
    <member name="M:PostSharp.ModuleWriter.InstructionEmitter.InternalEmitInstructionString(PostSharp.CodeModel.OpCodeNumber,PostSharp.CodeModel.LiteralString)">
      <summary>
            Emits an instruction with an string operand.
            </summary>
      <param name="code">The instruction code.</param>
      <param name="operand">The string operand.</param>
      <remarks>
            This method is called internally after preconditions have been checked. Derived
            classes should not check preconditions.
            </remarks>
    </member>
    <member name="M:PostSharp.ModuleWriter.InstructionEmitter.InternalEmitInstructionMethod(PostSharp.CodeModel.OpCodeNumber,PostSharp.CodeModel.IMethod)">
      <summary>
            Emits an instruction with an <see cref="T:PostSharp.CodeModel.IMethod" /> operand.
            </summary>
      <param name="code">The instruction code.</param>
      <param name="method">The <see cref="T:PostSharp.CodeModel.IMethod" /> operand.</param>
      <remarks>
            This method is called internally after preconditions have been checked. Derived
            classes should not check preconditions.
            </remarks>
    </member>
    <member name="M:PostSharp.ModuleWriter.InstructionEmitter.InternalEmitSwitchInstruction(PostSharp.CodeModel.InstructionSequence[])">
      <summary>
            Emits a <see cref="F:PostSharp.CodeModel.OpCodeNumber.Switch" /> instruction.
            </summary>
      <param name="switchTargets">An array of instruction sequences (<see cref="T:PostSharp.CodeModel.InstructionSequence" />)
            which are the targets of the switch instruction.</param>
      <remarks>
            This method is called internally after preconditions have been checked. Derived
            classes should not check preconditions.
            </remarks>
    </member>
    <member name="M:PostSharp.ModuleWriter.InstructionEmitter.InternalEmitInstructionType(PostSharp.CodeModel.OpCodeNumber,PostSharp.CodeModel.ITypeSignature)">
      <summary>
            Emits an instruction with an <see cref="T:PostSharp.CodeModel.IType" /> operand.
            </summary>
      <param name="code">The instruction code.</param>
      <param name="type">The <see cref="T:PostSharp.CodeModel.IType" /> operand.</param>
      <remarks>
            This method is called internally after preconditions have been checked. Derived
            classes should not check preconditions.
            </remarks>
    </member>
    <member name="M:PostSharp.ModuleWriter.InstructionEmitter.InternalEmitInstructionParameter(PostSharp.CodeModel.OpCodeNumber,PostSharp.CodeModel.ParameterDeclaration,System.Reflection.Emit.OperandType)">
      <summary>
            Emits an instruction with an <see cref="T:PostSharp.CodeModel.ParameterDeclaration" /> operand.
            </summary>
      <param name="code">The instruction code.</param>
      <param name="parameter">The <see cref="T:PostSharp.CodeModel.ParameterDeclaration" /> operand.</param>
      <param name="operandType">
        <see cref="F:System.Reflection.Emit.OperandType.InlineVar" /> or <see cref="F:System.Reflection.Emit.OperandType.ShortInlineVar" />.</param>
      <remarks>
        <para>
            The <paramref name="operandType" /> parameter is determined by 
            <see cref="M:PostSharp.ModuleWriter.InstructionEmitter.EmitInstructionParameter(PostSharp.CodeModel.OpCodeNumber,PostSharp.CodeModel.ParameterDeclaration)" /> in order to avoid multiples evaluations
            of the operand size.
            </para>
        <para>
            This method is called internally after preconditions have been checked. Derived
            classes should not check preconditions.
            </para>
      </remarks>
    </member>
    <member name="M:PostSharp.ModuleWriter.InstructionEmitter.InternalEmitInstructionLocalVariable(PostSharp.CodeModel.OpCodeNumber,PostSharp.CodeModel.LocalVariableSymbol,System.Reflection.Emit.OperandType)">
      <summary>
            Emits an instruction with an <see cref="T:PostSharp.CodeModel.LocalVariableSymbol" /> operand.
            </summary>
      <param name="code">The instruction code.</param>
      <param name="localVariableSymbol">The <see cref="T:PostSharp.CodeModel.LocalVariableSymbol" /> operand.</param>
      <param name="operandType">
        <see cref="F:System.Reflection.Emit.OperandType.InlineVar" /> or <see cref="F:System.Reflection.Emit.OperandType.ShortInlineVar" />.</param>
      <remarks>
        <para>
            The <paramref name="operandType" /> parameter is determined by 
            <see cref="M:PostSharp.ModuleWriter.InstructionEmitter.EmitInstructionLocalVariable(PostSharp.CodeModel.OpCodeNumber,PostSharp.CodeModel.LocalVariableSymbol)" /> in order to avoid multiples evaluations
            of the operand size.
            </para>
        <para>
            This method is called internally after preconditions have been checked. Derived
            classes should not check preconditions.
            </para>
      </remarks>
    </member>
    <member name="M:PostSharp.ModuleWriter.InstructionEmitter.InternalEmitInstructionSignature(PostSharp.CodeModel.OpCodeNumber,PostSharp.CodeModel.StandaloneSignatureDeclaration)">
      <summary>
            Emits an instruction with an <see cref="T:PostSharp.CodeModel.StandaloneSignatureDeclaration" /> operand.
            </summary>
      <param name="code">The instruction code.</param>
      <param name="signature">The <see cref="T:PostSharp.CodeModel.StandaloneSignatureDeclaration" /> operand.</param>
      <remarks>
            This method is called internally after preconditions have been checked. Derived
            classes should not check preconditions.
            </remarks>
    </member>
    <member name="M:PostSharp.ModuleWriter.InstructionEmitter.InternalEmitBranchingInstruction(PostSharp.CodeModel.OpCodeNumber,PostSharp.CodeModel.OpCodeNumber,PostSharp.CodeModel.InstructionSequence)">
      <summary>
            Emits a branching instruction.
            </summary>
      <param name="nearCode">Near opcode of the instruction (to be ignored in <see cref="P:PostSharp.ModuleWriter.InstructionEmitter.ForceFarBranchingOperands" />
            is <b>true</b>).</param>
      <param name="farCode">Far opcode of the instruction.</param>
      <param name="sequence">Target <see cref="T:PostSharp.CodeModel.InstructionSequence" />.</param>
      <returns>The address distance (or <see cref="F:PostSharp.ModuleWriter.AddressDistance.Far" /> if 
            <see cref="P:PostSharp.ModuleWriter.InstructionEmitter.ForceFarBranchingOperands" /> is true.</returns>
      <remarks>
            This method is called internally after preconditions have been checked. Derived
            classes should not check preconditions.
            </remarks>
    </member>
    <member name="M:PostSharp.ModuleWriter.InstructionEmitter.EmitPrefix(PostSharp.CodeModel.InstructionPrefixes)">
      <summary>
            Emits a prefix without operand.
            </summary>
      <param name="prefix">A combination of prefixes.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.InstructionEmitter.EmitPrefixType(PostSharp.CodeModel.OpCodeNumber,PostSharp.CodeModel.ITypeSignature)">
      <summary>
            Emits a prefix with an <see cref="T:PostSharp.CodeModel.IType" /> operand.
            </summary>
      <param name="prefix">A single prefix (not a combination).</param>
      <param name="type">The <see cref="T:PostSharp.CodeModel.IType" /> operand.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.InstructionEmitter.EmitInstruction(PostSharp.CodeModel.OpCodeNumber)">
      <summary>
            Emits an instruction without operand.
            </summary>
      <param name="code">The instruction opcode.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.InstructionEmitter.EmitInstructionField(PostSharp.CodeModel.OpCodeNumber,PostSharp.CodeModel.IField)">
      <summary>
            Emits an instruction with an <see cref="T:PostSharp.CodeModel.IField" /> operand.
            </summary>
      <param name="code">The instruction opcode.</param>
      <param name="field">The <see cref="T:PostSharp.CodeModel.IField" /> operand.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.InstructionEmitter.EmitInstructionByte(PostSharp.CodeModel.OpCodeNumber,System.Byte)">
      <summary>
            Emits an instruction with a <see cref="T:System.Byte" /> operand.
            </summary>
      <param name="code">The instruction opcode.</param>
      <param name="operand">The <see cref="T:System.Byte" /> operand.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.InstructionEmitter.EmitInstructionInt64(PostSharp.CodeModel.OpCodeNumber,System.Int64)">
      <summary>
            Emits an instruction with an <see cref="T:System.Int64" /> operand.
            </summary>
      <param name="code">The instruction opcode.</param>
      <param name="operand">The <see cref="T:System.Int64" /> operand.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.InstructionEmitter.EmitInstructionInt32(PostSharp.CodeModel.OpCodeNumber,System.Int32)">
      <summary>
            Emits an instruction with an <see cref="T:System.Int32" /> operand.
            </summary>
      <param name="code">The instruction opcode.</param>
      <param name="operand">The <see cref="T:System.Int32" /> operand.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.InstructionEmitter.EmitInstructionInt16(PostSharp.CodeModel.OpCodeNumber,System.Int16)">
      <summary>
            Emits an instruction with an <see cref="T:System.Int16" /> operand.
            </summary>
      <param name="code">The instruction opcode.</param>
      <param name="operand">The <see cref="T:System.Int16" /> operand.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.InstructionEmitter.EmitInstructionSingle(PostSharp.CodeModel.OpCodeNumber,System.Single)">
      <summary>
            Emits an instruction with a <see cref="T:System.Single" /> operand.
            </summary>
      <param name="code">The instruction opcode.</param>
      <param name="operand">The <see cref="T:System.Single" /> operand.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.InstructionEmitter.EmitInstructionDouble(PostSharp.CodeModel.OpCodeNumber,System.Double)">
      <summary>
            Emits an instruction with a <see cref="T:System.Double" /> operand.
            </summary>
      <param name="code">The instruction opcode.</param>
      <param name="operand">The <see cref="T:System.Double" /> operand.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.InstructionEmitter.EmitInstructionString(PostSharp.CodeModel.OpCodeNumber,PostSharp.CodeModel.LiteralString)">
      <summary>
            Emits an instruction with a string operand.
            </summary>
      <param name="code">The instruction opcode.</param>
      <param name="operand">The string operand.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.InstructionEmitter.EmitInstructionMethod(PostSharp.CodeModel.OpCodeNumber,PostSharp.CodeModel.IMethod)">
      <summary>
            Emits an instruction with an <see cref="T:PostSharp.CodeModel.IMethod" /> operand.
            </summary>
      <param name="code">The instruction opcode.</param>
      <param name="method">The <see cref="T:PostSharp.CodeModel.IMethod" /> operand.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.InstructionEmitter.EmitSwitchInstruction(PostSharp.CodeModel.InstructionSequence[])">
      <summary>
            Emits a <see cref="F:PostSharp.CodeModel.OpCodeNumber.Switch" /> instruction.
            </summary>
      <param name="switchTargets">An array of instruction sequences (<see cref="T:PostSharp.CodeModel.InstructionSequence" />)
            which are the targets of the switch instruction.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.InstructionEmitter.EmitInstructionType(PostSharp.CodeModel.OpCodeNumber,PostSharp.CodeModel.ITypeSignature)">
      <summary>
            Emits an instruction with an <see cref="T:PostSharp.CodeModel.IType" /> operand.
            </summary>
      <param name="code">The instruction opcode.</param>
      <param name="type">The <see cref="T:PostSharp.CodeModel.IType" /> operand.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.InstructionEmitter.EmitInstructionParameter(PostSharp.CodeModel.OpCodeNumber,PostSharp.CodeModel.ParameterDeclaration)">
      <summary>
            Emits an instruction with a <see cref="T:PostSharp.CodeModel.ParameterDeclaration" /> operand.
            </summary>
      <param name="code">The instruction opcode.</param>
      <param name="parameter">The <see cref="T:PostSharp.CodeModel.ParameterDeclaration" /> operand.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.InstructionEmitter.EmitInstructionLocalVariable(PostSharp.CodeModel.OpCodeNumber,PostSharp.CodeModel.LocalVariableSymbol)">
      <summary>
            Emits an instruction with a <see cref="T:PostSharp.CodeModel.LocalVariableSymbol" /> operand.
            </summary>
      <param name="code">The instruction opcode.</param>
      <param name="localVariableSymbol">The <see cref="T:PostSharp.CodeModel.LocalVariableSymbol" /> operand.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.InstructionEmitter.EmitBranchingInstruction(PostSharp.CodeModel.OpCodeNumber,PostSharp.CodeModel.InstructionSequence)">
      <summary>
            Emits a branching instruction.
            </summary>
      <param name="code">The instruction code.</param>
      <param name="sequence">The target <see cref="T:PostSharp.CodeModel.InstructionSequence" />.</param>
      <returns>The distance of <paramref name="sequence" /> w.r.t. the current instruction.</returns>
    </member>
    <member name="M:PostSharp.ModuleWriter.InstructionEmitter.EmitInstructionSignature(PostSharp.CodeModel.OpCodeNumber,PostSharp.CodeModel.StandaloneSignatureDeclaration)">
      <summary>
            Emits an instruction with a <see cref="T:PostSharp.CodeModel.StandaloneSignatureDeclaration" /> operand.
            </summary>
      <param name="code">The instruction opcode.</param>
      <param name="signature">The <see cref="T:PostSharp.CodeModel.StandaloneSignatureDeclaration" /> operand.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.InstructionEmitter.EmitSymbolSequencePoint(PostSharp.CodeModel.SymbolSequencePoint)">
      <summary>
            Emits a symbol sequence point.
            </summary>
      <param name="sequencePoint">A <see cref="T:PostSharp.CodeModel.SymbolSequencePoint" />, or <b>null</b>.</param>
      <remarks>
            This method does nothing if <paramref name="sequencePoint" /> is null.
            </remarks>
    </member>
    <member name="M:PostSharp.ModuleWriter.InstructionEmitter.EmitInstructionLoadIndirect(PostSharp.CodeModel.ITypeSignature)">
      <summary>
            Emits the proper "load indirect" instruction as a function of the operand type.
            </summary>
      <param name="type">Operand type.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.InstructionEmitter.EmitInstructionStoreElement(PostSharp.CodeModel.ITypeSignature)">
      <summary>
            Emits the proper instruction that stores an array element for a given <see cref="T:PostSharp.CodeModel.ITypeSignature" />.
            </summary>
      <param name="type">Type of elements of the array.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.InstructionEmitter.EmitInstructionStoreIndirect(PostSharp.CodeModel.ITypeSignature)">
      <summary>
            Emits the proper "store indirect" instruction as a function of the operand type.
            </summary>
      <param name="type">Operand type.</param>
    </member>
    <member name="P:PostSharp.ModuleWriter.InstructionEmitter.MethodBody">
      <summary>
            Gets or sets the method body assigned to the current <see cref="T:PostSharp.ModuleWriter.InstructionEmitter" />.
            </summary>
    </member>
    <member name="P:PostSharp.ModuleWriter.InstructionEmitter.ForceFarBranchingOperands">
      <summary>
            Determines whether far branching instructions should be unconditionnally used.
            </summary>
      <remarks>
            When this property is <b>true</b>, this class will not try to emit different
            instructions according to the address distance. This may be only used when
            (1) one does not emit final IL code, (2) near and far instructions are
            considered equivalently and (3) the reader is aware that near instructions
            expect a large operand. This is typically the case when we emit temporary IL
            code and the operand is an <see cref="T:PostSharp.CodeModel.InstructionSequence" /> token.
            </remarks>
    </member>
    <member name="P:PostSharp.ModuleWriter.InstructionEmitter.CheckEnabled">
      <summary>
            Determines whether operand types should be checked at runtime.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.InstructionWriter.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.InstructionWriter" />.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.InstructionWriter.AttachInstructionSequence(PostSharp.CodeModel.InstructionSequence)">
      <summary>
            Attaches the current <see cref="T:PostSharp.CodeModel.InstructionWriter" /> to an <see cref="T:PostSharp.CodeModel.InstructionSequence" />.
            </summary>
      <param name="sequence">An <see cref="T:PostSharp.CodeModel.InstructionSequence" /> that is attached
            to a method.</param>
      <exception cref="T:System.ArgumentNullException">
            	The <paramref name="sequence" /> parameter is null.
            </exception>
      <exception cref="T:System.ArgumentException">
            	The <paramref name="sequence" /> is not attached to a method.
            </exception>
      <exception cref="T:System.InvalidOperationException">
            This <see cref="T:PostSharp.CodeModel.InstructionWriter" /> has already an active <see cref="T:PostSharp.CodeModel.InstructionSequence" />.
            </exception>
    </member>
    <member name="M:PostSharp.CodeModel.InstructionWriter.DetachInstructionSequence">
      <overloads>Detaches the current <see cref="T:PostSharp.CodeModel.InstructionWriter" /> from
            the active <see cref="T:PostSharp.CodeModel.InstructionSequence" />.</overloads>
      <summary>
            Detaches the current <see cref="T:PostSharp.CodeModel.InstructionWriter" /> from the active
            <see cref="T:PostSharp.CodeModel.InstructionSequence" /> and commits the changes.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.InstructionWriter.DetachInstructionSequence(System.Boolean)">
      <summary>
            Detaches the current <see cref="T:PostSharp.CodeModel.InstructionWriter" /> form the active
            <see cref="T:PostSharp.CodeModel.InstructionSequence" /> by specifying whether the
            changes should be committed or rolled back.
            </summary>
      <param name="commit">
        <b>true</b> if the changes should ne
            committed, or <b>false</b> of they should be rolled back.</param>
      <exception cref="T:System.InvalidOperationException">	
            	This <see cref="T:PostSharp.CodeModel.InstructionWriter" /> has no active
            	<see cref="T:PostSharp.CodeModel.InstructionSequence" />.
            </exception>
    </member>
    <member name="M:PostSharp.CodeModel.InstructionWriter.Dispose" />
    <member name="P:PostSharp.CodeModel.InstructionWriter.CurrentInstructionSequence">
      <summary>
            Gets the current instruction sequence.
            </summary>
      <value>
            The current instruction sequence, or <b>null</b> if the current writer
            is not attached to any sequence.
            </value>
    </member>
    <member name="T:PostSharp.Extensibility.Configuration.DependencyConfiguration">
      <summary>
            Represents a dependency between task types.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Configuration.DependencyConfiguration.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.Configuration.DependencyConfiguration" />.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Configuration.DependencyConfiguration.ToString" />
    <member name="P:PostSharp.Extensibility.Configuration.DependencyConfiguration.Parent">
      <summary>
            Gets the parent task type (<see cref="T:PostSharp.Extensibility.Configuration.TaskTypeConfiguration" />).
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.DependencyConfiguration.Required">
      <summary>
            Indicates whether this dependency is required.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.DependencyConfiguration.TaskType">
      <summary>
            Gets or sets the name of the task type to which the declaring type task
            is dependent.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.DependencyConfiguration.Position">
      <summary>
            Gets or sets the position of the dependent task type (before or after
            the current task type).
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.DependencyConfiguration.OwnerTaskType">
      <summary>
            Gets the name of the task owning the current dependency.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.DependencyConfiguration.PrecedingTaskType">
      <summary>
            Gets the name of the preceding task type in the current dependency.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.DependencyConfiguration.SucceedingTaskType">
      <summary>
            Gets the name of the succeeding task type in the current dependency.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.Configuration.DependencyConfigurationCollection">
      <summary>
            Collection of dependencies (<see cref="T:PostSharp.Extensibility.Configuration.DependencyConfiguration" />).
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Configuration.DependencyConfigurationCollection.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.Configuration.DependencyConfigurationCollection" /></summary>
    </member>
    <member name="T:PostSharp.Extensibility.Configuration.DependencyPosition">
      <summary>
            Enumerates the relative position of dependencies (<see cref="F:PostSharp.Extensibility.Configuration.DependencyPosition.Before" /> 
            or <see cref="F:PostSharp.Extensibility.Configuration.DependencyPosition.After" />).
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.Configuration.DependencyPosition.Default">
      <summary>
            Default = <see cref="F:PostSharp.Extensibility.Configuration.DependencyPosition.Before" />.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.Configuration.DependencyPosition.Before">
      <summary>
            Before.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.Configuration.DependencyPosition.After">
      <summary>
            After.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.Configuration.NameValuePair">
      <summary>
            Simple name-value pair of strings.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Configuration.NameValuePair.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.Configuration.NameValuePair" />.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.NameValuePair.Value">
      <summary>
            Gets or sets the value.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.NameValuePair.Name">
      <summary>
            Gets or sets the name.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.Configuration.NameValuePairCollection">
      <summary>
            Collection of name-value pairs (<see cref="T:PostSharp.Extensibility.Configuration.NameValuePair" />).
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Configuration.NameValuePairCollection.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.Configuration.NameValuePairCollection" />.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.Configuration.PlatformConfiguration">
      <summary>
            Configures a target platform.
            </summary>
      <remarks>
            A target platform is primarly defined by an implementation class,
            and optionally by some parameters.
            </remarks>
    </member>
    <member name="M:PostSharp.Extensibility.Configuration.PlatformConfiguration.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.Configuration.PlatformConfiguration" />.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.PlatformConfiguration.Implementation">
      <summary>
            Gets or sets the full name of the type implementing <see cref="T:PostSharp.PlatformAbstraction.TargetPlatformAdapter" />.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.PlatformConfiguration.Name">
      <summary>
            Gets or sets the platform name (primary identifier).
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.PlatformConfiguration.Parameters">
      <summary>
            Gets or sets the collection of platform parameters.
            </summary>
      <remarks>
            Parameters are passed to the implementation of <see cref="T:PostSharp.PlatformAbstraction.TargetPlatformAdapter" />
            during instantiation.
            </remarks>
    </member>
    <member name="T:PostSharp.Extensibility.Configuration.PlatformConfigurationCollection">
      <summary>
            Collection of platform configurations (<see cref="T:PostSharp.Extensibility.Configuration.PlatformConfiguration" />).
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Configuration.PlatformConfigurationCollection.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.Configuration.PlatformConfigurationCollection" />.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.Configuration.PlatformConfigurationDictionary">
      <summary>
            Dictionary of platform configurations (<see cref="T:PostSharp.Extensibility.Configuration.PlatformConfiguration" />) by name.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Configuration.PlatformConfigurationDictionary.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.Configuration.PlatformConfigurationDictionary" />.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.Configuration.PlugInConfiguration">
      <summary>
            Plug-in-level configuration.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Configuration.PlugInConfiguration.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.Configuration.PlugInConfiguration" />.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.Configuration.ProjectConfiguration">
      <summary>
            Project-level configuration.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Configuration.ProjectConfiguration.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.Configuration.ProjectConfiguration" />.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Configuration.ProjectConfiguration.LoadProject(System.String)">
      <summary>
            Loads the project configuration from a file.
            </summary>
      <param name="fileName">Complete location of the project file.</param>
      <returns>A <see cref="T:PostSharp.Extensibility.Configuration.ProjectConfiguration" /> resulting from the
            deserialization of the content of the file at <paramref name="fileName" />.</returns>
      <remarks>
            Errors are logged to the <see cref="T:PostSharp.Extensibility.Messenger" /> attached to the current thread.
            </remarks>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.ProjectConfiguration.ReferenceDirectory">
      <summary>
            Gets or sets the directory according to which relative paths are resolved. By default, 
            relative paths are resolved according to the directory that contains 
            the project file. You may use the <c>{$WorkingDirectory}</c> property if
            you want to resolve paths according to the working directory.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.ProjectConfiguration.TasksElement">
      <summary>
            Gets or sets the serialized collection of tasks.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.Configuration.XmlElementCollection">
      <summary>
            Collection of XML elements.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Configuration.XmlElementCollection.#ctor">
      <summary>
            Intializes a new <see cref="T:PostSharp.Extensibility.Configuration.XmlElementCollection" />.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.Configuration.PropertyConfiguration">
      <summary>
            Specifies a property assignment.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Configuration.PropertyConfiguration.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.Configuration.PropertyConfiguration" />.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.PropertyConfiguration.Value">
      <summary>
            Gets or sets the property value.
            </summary>
      <value>
            An expression.
            </value>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.PropertyConfiguration.Name">
      <summary>
            Gets or sets the property name (primary key).
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.Configuration.PropertyConfigurationCollection">
      <summary>
            Collection of property definitions.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Configuration.PropertyConfigurationCollection.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.Configuration.PropertyConfigurationCollection" />.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.Configuration.TaskTypeConfiguration">
      <summary>
            Configures a task type.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Configuration.TaskTypeConfiguration.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.Configuration.TaskTypeConfiguration" />.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Configuration.TaskTypeConfiguration.CreateInstance(PostSharp.Extensibility.Project)">
      <summary>
            Creates a empty task instance of the current task type.
            </summary>
      <param name="project">Actual configuration.</param>
      <returns>A <see cref="T:PostSharp.Extensibility.Task" />.</returns>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.TaskTypeConfiguration.Phase">
      <summary>
            Gets the name of the base to which tasks of this type belong.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.TaskTypeConfiguration.Name">
      <summary>
            Gets or sets the name of the XML element for this task type.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.TaskTypeConfiguration.Implementation">
      <summary>
            Gets or sets the name of the type implementing the <see cref="T:PostSharp.Extensibility.Task" />.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.TaskTypeConfiguration.Dependencies">
      <summary>
            Gets or sets the collection of dependencies of this
            task type.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Configuration.TaskTypeConfiguration.Parameters">
      <summary>
            Gets or sets the collection of task type parameters.
            </summary>
      <remarks>
            Parameters can be used by the implementation of the <see cref="T:PostSharp.Extensibility.Task" /> type.
            </remarks>
    </member>
    <member name="T:PostSharp.Extensibility.Configuration.TaskTypeConfigurationCollection">
      <summary>
            Collection of task type configurations (<see cref="T:PostSharp.Extensibility.Configuration.TaskTypeConfiguration" />).
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Configuration.TaskTypeConfigurationCollection.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.Configuration.TaskTypeConfigurationCollection" />.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.Configuration.TaskTypeConfigurationDictionary">
      <summary>
            Dictionary mapping the name of a <see cref="T:PostSharp.Extensibility.Configuration.TaskTypeConfiguration" /> to its
            corresponding instance.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Configuration.TaskTypeConfigurationDictionary.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.Configuration.TaskTypeConfigurationDictionary" />.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.DefaultPostSharpHost">
      <summary>
            Default implementation of <see cref="T:PostSharp.Extensibility.IPostSharpHost" /> for the runtime usage scenario.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.IPostSharpHost">
      <summary>
            Describes the semantics of a PostSharp Host. The host is conceptually the component that
            instantiates and uses <see cref="T:PostSharp.Extensibility.IPostSharpObject" />, the principal entry point for
            the Platform Infrastructure. The <see cref="T:PostSharp.Extensibility.IPostSharpObject" /> implementation uses this
            interface when it needs to get information from the host.
            </summary>
      <remarks>
        <para>Classes implementing <see cref="T:PostSharp.Extensibility.IPostSharpHost" /> should be derived from 
            <see cref="T:System.MarshalByRefObject" /> if the <see cref="T:PostSharp.Extensibility.IPostSharpObject" /> is set up to
            use its own application domain.
            </para>
        <para>
            If a host has default behavior, it is not required to implement its own <see cref="T:PostSharp.Extensibility.IPostSharpHost" />.
            The default behavior is typically the compile-time use case, when all modules to be transformed are 
            passed to the <see cref="M:PostSharp.Extensibility.IPostSharpObject.InvokeProjects(PostSharp.Extensibility.ProjectInvocation[])" /> method. Modules that are discovered 
            at runtime (like dependencies) are not processed.
            </para>
      </remarks>
    </member>
    <member name="M:PostSharp.Extensibility.IPostSharpHost.ResolveAssemblyReference(System.Reflection.AssemblyName)">
      <summary>
            Returns the location and the loag arguments of an assembly known by name.
            </summary>
      <param name="assemblyName">Assembly name.</param>
      <returns>The full path of the assembly, or <b>null</b> if the host does not want
            to intervene in the default binding mechanism of the PostSharp Platform.</returns>
      <remarks>
            This method is called whenever an assembly reference has to be resolved inside the
            PostSharp Code Object Model, and this assembly has neither been resolved yet neither
            been passed to the <see cref="M:PostSharp.Extensibility.IPostSharpObject.InvokeProjects(PostSharp.Extensibility.ProjectInvocation[])" /> method.
            </remarks>
    </member>
    <member name="M:PostSharp.Extensibility.IPostSharpHost.GetProjectInvocationParameters(System.String,System.String,System.Reflection.AssemblyName)">
      <summary>
            Determines whether and how a module should be processed by PostSharp.
            </summary>
      <param name="assemblyFileName">Location of the considered assembly. This is merely the location
            returned by the <see cref="M:PostSharp.Extensibility.IPostSharpHost.ResolveAssemblyReference(System.Reflection.AssemblyName)" /> method.</param>
      <param name="moduleName">Name of the considered module.</param>
      <param name="assemblyName">Complete name of the assembly.</param>
      <returns>A <see cref="T:PostSharp.Extensibility.ProjectInvocationParameters" /> object if this module has to be
            processed, or <b>null</b> if the module should not be processed.</returns>
    </member>
    <member name="M:PostSharp.Extensibility.IPostSharpHost.RenameAssembly(System.Reflection.AssemblyName,System.Reflection.AssemblyName)">
      <summary>
            Notifies the host that an assembly has been renamed. This happens if the 
            <see cref="T:PostSharp.Extensibility.PostSharpObjectSettings" />.<see cref="P:PostSharp.Extensibility.PostSharpObjectSettings.OverwriteAssemblyNames" />
            flag has been set.
            </summary>
      <param name="oldAssemblyName">Original assembly name.</param>
      <param name="newAssemblyName">New assembly name.</param>
      <remarks>
            The assembly renaming is used in the runtime usage scenario in order to (1) remove
            strong names and (2) make sure that the unprocessed assembly is not loaded 'accidentally'
            by the default system binder (for instance because the transformed assembly lays in the GAC).
            See <see cref="P:PostSharp.Extensibility.PostSharpObjectSettings.OverwriteAssemblyNames" /> for details.
            </remarks>
    </member>
    <member name="F:PostSharp.Extensibility.DefaultPostSharpHost.Instance">
      <summary>
            Singleton instance.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.DefaultPostSharpHost.#ctor">
      <summary>
            Protected constructor. 
            </summary>
      <remarks>
            It makes no sense to have many instances of the <see cref="T:PostSharp.Extensibility.DefaultPostSharpHost" />,
            but we want to make it possible to inherit this class.
            </remarks>
    </member>
    <member name="M:PostSharp.Extensibility.DefaultPostSharpHost.ResolveAssemblyReference(System.Reflection.AssemblyName)">
      <summary>
            Returns the location and the loag arguments of an assembly known by name.
            </summary>
      <param name="assemblyName">Assembly name.</param>
      <returns>The full path of the assembly, or <b>null</b> if the host does not want
            to intervene in the default binding mechanism of the PostSharp Platform.</returns>
      <remarks>
            This method is called whenever an assembly reference has to be resolved inside the
            PostSharp Code Object Model, and this assembly has neither been resolved yet neither
            been passed to the <see cref="M:PostSharp.Extensibility.IPostSharpObject.InvokeProjects(PostSharp.Extensibility.ProjectInvocation[])" /> method.
            </remarks>
    </member>
    <member name="M:PostSharp.Extensibility.DefaultPostSharpHost.GetProjectInvocationParameters(System.String,System.String,System.Reflection.AssemblyName)">
      <summary>
            Determines whether and how a module should be processed by PostSharp.
            </summary>
      <param name="assemblyFileName">Location of the considered assembly. This is merely the location
            returned by the <see cref="M:PostSharp.Extensibility.IPostSharpHost.ResolveAssemblyReference(System.Reflection.AssemblyName)" /> method.</param>
      <param name="moduleName">Name of the considered module.</param>
      <param name="assemblyName">Complete name of the assembly.</param>
      <returns>A <see cref="T:PostSharp.Extensibility.ProjectInvocationParameters" /> object if this module has to be
            processed, or <b>null</b> if the module should not be processed.</returns>
    </member>
    <member name="M:PostSharp.Extensibility.DefaultPostSharpHost.RenameAssembly(System.Reflection.AssemblyName,System.Reflection.AssemblyName)">
      <summary>
            Notifies the host that an assembly has been renamed. This happens if the 
            <see cref="T:PostSharp.Extensibility.PostSharpObjectSettings" />.<see cref="P:PostSharp.Extensibility.PostSharpObjectSettings.OverwriteAssemblyNames" />
            flag has been set.
            </summary>
      <param name="oldAssemblyName">Original assembly name.</param>
      <param name="newAssemblyName">New assembly name.</param>
      <remarks>
            The assembly renaming is used in the runtime usage scenario in order to (1) remove
            strong names and (2) make sure that the unprocessed assembly is not loaded 'accidentally'
            by the default system binder (for instance because the transformed assembly lays in the GAC).
            See <see cref="P:PostSharp.Extensibility.PostSharpObjectSettings.OverwriteAssemblyNames" /> for details.
            </remarks>
    </member>
    <member name="T:PostSharp.Extensibility.IPostSharpDomainManager">
      <summary>
            Interface of PostSharp with a hypothetical unmanaged bootstrapper,
            typically implemented by the application domain manager.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.IPostSharpDomainManager.Initialize(System.Boolean)">
      <summary>
            Initializes PostSharp.
            </summary>
      <param name="assemblyResolve">
        <b>true</b> if PostSharp should handle the
            <b>AppDomain.AssemblyResolve</b> event itself, <b>false</b> if it is done by
            the unmanaged host.</param>
    </member>
    <member name="M:PostSharp.Extensibility.IPostSharpDomainManager.Start(System.String[])">
      <summary>
            Starts the PostSharp command line.
            </summary>
      <param name="args">Command line arguments.</param>
      <returns>Exit code.</returns>
    </member>
    <member name="M:PostSharp.Extensibility.IPostSharpDomainManager.FindAssembly(System.String)">
      <summary>
            Finds an assembly given its name.
            </summary>
      <param name="assemblyName">Assembly name.</param>
      <returns>Assembly location, or <b>null</b> if the
            assembly could not be found.</returns>
    </member>
    <member name="T:PostSharp.Extensibility.IPostSharpObject">
      <summary>
            Defines the semantics of the <b>PostSharp Object</b>, the entry point of the
            Platform Infrastructure. Use the <see cref="M:PostSharp.Extensibility.PostSharpObject.CreateInstance(PostSharp.Extensibility.PostSharpObjectSettings)" /> method
            to create an instance of the PostSharp Object.
            </summary>
      <remarks>
        <para>This object is disposable. Seriously! Be sure to call the <see cref="M:System.IDisposable.Dispose" /> method
            when you do not need PostSharp any more, otherwise the private application domain
            won't be unloaded.
            </para>
        <para>
            All assemblies loaded in the scope of one instance of <see cref="T:PostSharp.Extensibility.IPostSharpObject" />
            and all projects will share a unique instance of the <see cref="T:PostSharp.CodeModel.Domain" /> class. If this
            behavior is not wished, you should use many instances of <see cref="T:PostSharp.Extensibility.IPostSharpObject" />.
            </para>
      </remarks>
    </member>
    <member name="M:PostSharp.Extensibility.IPostSharpObject.InvokeProject(PostSharp.Extensibility.ProjectInvocation)">
      <summary>
            Requests the processing of a single PostSharp project.
            </summary>
      <param name="projectInvocation">Parameters for the PostSharp invocation.</param>
    </member>
    <member name="M:PostSharp.Extensibility.IPostSharpObject.InvokeProjects(PostSharp.Extensibility.ProjectInvocation[])">
      <summary>
            Requests the processing of PostSharp projects. Each project and its parameters
            are described in a <see cref="T:PostSharp.Extensibility.ProjectInvocation" /> object.
            </summary>
      <param name="projectInvocations">An array in which each element is a request
            to execute a PostSharp project.</param>
      <remarks>
            One source assembly may be processed only once in the lifetime of a <see cref="T:PostSharp.Extensibility.IPostSharpObject" />.
            </remarks>
    </member>
    <member name="M:PostSharp.Extensibility.IPostSharpObject.ProcessAssemblies(PostSharp.Extensibility.ModuleLoadStrategy[])">
      <summary>
            Requests the processing of assemblies by PostSharp. The projects to be executed and their
            paramaters are not yet known. They will be requested through the 
            <see cref="M:PostSharp.Extensibility.IPostSharpHost.GetProjectInvocationParameters(System.String,System.String,System.Reflection.AssemblyName)" /> method of the
            <see cref="T:PostSharp.Extensibility.IPostSharpHost" /> interface.
            </summary>
      <param name="modules">Array of assemblies to be processed.</param>
    </member>
    <member name="P:PostSharp.Extensibility.IPostSharpObject.AppDomain">
      <summary>
            Gets the <see cref="P:PostSharp.Extensibility.IPostSharpObject.AppDomain" /> in which the PostSharp Object lives.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.MessageSinkAccessor">
      <summary>
            Gives access to a remove <see cref="T:PostSharp.Extensibility.IMessageSink" />.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.RemotingAccessor`1">
      <summary>
            Automatically manages the lifetime of a remote object.
            </summary>
      <typeparam name="T">Type of the remove object.</typeparam>
      <remarks>
            This type automates the use of <see cref="T:System.Runtime.Remoting.Lifetime.ClientSponsor" /> for
            remote objects. It starts sponsoring the remove object when the
            <see cref="T:PostSharp.Extensibility.RemotingAccessor`1" /> instance is created, and stops 
            sponsoring when the <see cref="T:PostSharp.Extensibility.RemotingAccessor`1" /> is disposed or
            finalized. It helps implementing consistent remote sponsoring
            without effort.
            </remarks>
    </member>
    <member name="M:PostSharp.Extensibility.RemotingAccessor`1.#ctor(`0,System.Boolean)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.RemotingAccessor`1" />.
            </summary>
      <param name="remoteObject">An existing remote object (marshalle by reference).</param>
      <param name="ownsRemoteObject">
        <b>true</b> if the remote object should be disposed
            when the accessor is disposed, otherwise <b>false</b>.</param>
    </member>
    <member name="M:PostSharp.Extensibility.RemotingAccessor`1.AssertNotDisposed">
      <summary>
            Throws an exception if the current instance has already been disposed.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.RemotingAccessor`1.Dispose(System.Boolean)">
      <summary>
            Disposes the current instance.
            </summary>
      <param name="disposing">
        <b>false</b> if the method is called by the
            destructor, otherwise <b>true</b>.</param>
    </member>
    <member name="M:PostSharp.Extensibility.RemotingAccessor`1.Dispose" />
    <member name="M:PostSharp.Extensibility.RemotingAccessor`1.Finalize">
      <summary>
            Destructor.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.RemotingAccessor`1.GetHashCode" />
    <member name="M:PostSharp.Extensibility.RemotingAccessor`1.ToString" />
    <member name="P:PostSharp.Extensibility.RemotingAccessor`1.Value">
      <summary>
            Gets the remote object.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.RemotingAccessor`1.IsDisposed">
      <summary>
            Determines whether the current instance has been disposed.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.MessageSinkAccessor.#ctor(PostSharp.Extensibility.IMessageSink,System.Boolean)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.MessageSinkAccessor" /></summary>
      <param name="remoteSink">A message sink implementing <see cref="T:System.MarshalByRefObject" />.</param>
      <param name="ownRemoteSink">
        <b>true</b> if <paramref name="remoteSink" /> should be disposed
            when the accessor is disposed, otherwise <b>false</b>.</param>
    </member>
    <member name="M:PostSharp.Extensibility.MessageSinkAccessor.Write(PostSharp.Extensibility.Message)">
      <summary>
            Writes a message to the sink.
            </summary>
      <param name="message">A message.</param>
    </member>
    <member name="T:PostSharp.Extensibility.Messenger">
      <summary>
            Publish-subcribe channel for error messages (<see cref="E:PostSharp.Extensibility.Messenger.Message" />).
            </summary>
      <remarks>
            Each thread has its own instance of the <see cref="T:PostSharp.Extensibility.Messenger" /> class.
            Message emitters should use the <see cref="M:PostSharp.Extensibility.Messenger.Write(PostSharp.Extensibility.Message)" /> method, 
            consumers should susbcribe to the <see cref="E:PostSharp.Extensibility.Messenger.Message" /> event or
            implement the <see cref="T:PostSharp.Extensibility.IMessageSink" /> interface and
            register it using the <see cref="M:PostSharp.Extensibility.Messenger.AddRemoteSink(PostSharp.Extensibility.IMessageSink,System.Boolean)" /> method.
            </remarks>
    </member>
    <member name="M:PostSharp.Extensibility.Messenger.Initialize">
      <summary>
            Forces to initialize the static <see cref="T:PostSharp.Extensibility.Messenger" /> instance.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Messenger.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.Messenger" />.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Messenger.AddRemoteSink(PostSharp.Extensibility.IMessageSink,System.Boolean)">
      <summary>
            Adds a remote message sink to the current <see cref="T:PostSharp.Extensibility.Messenger" />.
            </summary>
      <param name="sink">A message sink that resides in another application domain.</param>
      <param name="ownSink">
        <b>true</b> if the current <see cref="T:PostSharp.Extensibility.Messenger" /> should
            dispose <paramref name="sink" /> when the <see cref="T:PostSharp.Extensibility.Messenger" /> is disposed, otherwise
            <b>false</b>.</param>
      <remarks>
        <para>All message sinks registered by this method shall be called when a message
            will be written into the current <see cref="T:PostSharp.Extensibility.Messenger" /></para>
      </remarks>
    </member>
    <member name="M:PostSharp.Extensibility.Messenger.RemoveRemoteSink(PostSharp.Extensibility.IMessageSink)">
      <summary>
            Removes a remote message sink from the current <see cref="T:PostSharp.Extensibility.Messenger" />.
            </summary>
      <param name="sink">A message sink that resides in another application domain.</param>
      <returns>
        <b>true</b> if <paramref name="sink" /> has been removed, otherwise <b>false</b>.</returns>
    </member>
    <member name="M:PostSharp.Extensibility.Messenger.DisableMessage(System.String)">
      <summary>
            Disables a message given its identifier.
            </summary>
      <param name="messageId">Identifier of the message to be disabled.</param>
      <remarks>
            Disabling a message means ignoring it. You can disable only information and warning messages, 
            not errors.
            </remarks>
    </member>
    <member name="M:PostSharp.Extensibility.Messenger.EscalateMessage(System.String)">
      <summary>
            Escalates a message, given its identifier.
            </summary>
      <param name="messageId">Identifier of the message to be escalated.</param>
      <remarks>
            Disabling a message means changing its severify to <b>Error</b>.
            </remarks>
    </member>
    <member name="M:PostSharp.Extensibility.Messenger.Write(PostSharp.Extensibility.Message)">
      <summary>
            Emits a message.
            </summary>
      <param name="message">A <see cref="E:PostSharp.Extensibility.Messenger.Message" />.</param>
      <exception cref="T:PostSharp.Extensibility.MessageException">The message severity is <see cref="F:PostSharp.Extensibility.SeverityType.Fatal" />.</exception>
    </member>
    <member name="M:PostSharp.Extensibility.Messenger.Dispose" />
    <member name="E:PostSharp.Extensibility.Messenger.Message">
      <summary>
            Event raised when a message is emitted.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Messenger.Current">
      <summary>
            Gets the <see cref="T:PostSharp.Extensibility.Messenger" /> associated with the current thread.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Messenger.FatalCount">
      <summary>
            Gets the number of emitted fatal error messages.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Messenger.ErrorCount">
      <summary>
            Gets the current number of emitted error messages.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Messenger.WarningCount">
      <summary>
            Gets the current number of emitted warning messages.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Messenger.InfoCount">
      <summary>
            Gets the current number of emitted info messages.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Messenger.MaxErrorCount">
      <summary>
            Gets or sets the maximal number of errors before a fatal error
            is emitted.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.MessageEventArgs">
      <summary>
            Arguments of the <see cref="E:PostSharp.Extensibility.Messenger.Message" /> event.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.MessageEventArgs.#ctor(PostSharp.Extensibility.Message)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.MessageEventArgs" />.
            </summary>
      <param name="message">A <see cref="P:PostSharp.Extensibility.MessageEventArgs.Message" />.</param>
    </member>
    <member name="P:PostSharp.Extensibility.MessageEventArgs.Message">
      <summary>
            Gets the <see cref="P:PostSharp.Extensibility.MessageEventArgs.Message" /> signaled by the event.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.ModuleLoadDirectFromFileStrategy">
      <summary>
            Implementation of <see cref="T:PostSharp.Extensibility.ModuleLoadStrategy" /> that loads a module
            directly from disk, without using Reflection before.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.ModuleLoadStrategy">
      <summary>
            Abstract strategy determining how a module should be loaded
            (typically by name, <see cref="T:PostSharp.Extensibility.ModuleLoadReflectionFromNameStrategy" />;
            or by file path, <see cref="T:PostSharp.Extensibility.ModuleLoadReflectionFromFileStrategy" />).
            </summary>
      <seealso cref="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)" />
      <seealso cref="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)" />
    </member>
    <member name="M:PostSharp.Extensibility.ModuleLoadStrategy.Load(PostSharp.CodeModel.Domain)">
      <summary>
            Loads the assembly into the current <see cref="T:System.AppDomain" />.
            </summary>
      <returns>The loaded assembly.</returns>
    </member>
    <member name="M:PostSharp.Extensibility.ModuleLoadDirectFromFileStrategy.#ctor(System.String,System.Boolean)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.ModuleLoadDirectFromFileStrategy" />
            and specifies whether the module should be loaded using lazy loading.
            </summary>
      <param name="fileName">Full path of the module.</param>
      <param name="lazyLoading">
        <b>true</b> if the module should be loaded using lazy loading,
            otherwise <b>false</b>.</param>
    </member>
    <member name="M:PostSharp.Extensibility.ModuleLoadDirectFromFileStrategy.#ctor(System.String)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.ModuleLoadDirectFromFileStrategy" />
            that will not load the module using lazy loading.
            </summary>
      <param name="fileName">Full path of the module.</param>
    </member>
    <member name="M:PostSharp.Extensibility.ModuleLoadDirectFromFileStrategy.Load(PostSharp.CodeModel.Domain)" />
    <member name="T:PostSharp.Extensibility.ModuleLoadReflectionFromFileStrategy">
      <summary>
            Implementation of <see cref="T:PostSharp.Extensibility.ModuleLoadStrategy" />
            loading the assembly by file location, using the <b>Assembly.LoadFile</b> method.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.ModuleLoadReflectionStrategy">
      <summary>
            Abstract implementation of <see cref="T:PostSharp.Extensibility.ModuleLoadStrategy" /> that first 
            loads the assembly using reflection.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.ModuleLoadReflectionStrategy.LoadAssembly">
      <summary>
            Loads the assembly using reflection.
            </summary>
      <returns />
    </member>
    <member name="M:PostSharp.Extensibility.ModuleLoadReflectionStrategy.Load(PostSharp.CodeModel.Domain)" />
    <member name="P:PostSharp.Extensibility.ModuleLoadReflectionStrategy.Evidence">
      <summary>
            Gets or sets the <see cref="P:PostSharp.Extensibility.ModuleLoadReflectionStrategy.Evidence" /> with which the assembly should be loaded.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.ModuleLoadReflectionFromFileStrategy.#ctor(System.String)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.ModuleLoadReflectionFromFileStrategy" />.
            </summary>
      <param name="fileName">Full physical path of the assembly.</param>
    </member>
    <member name="M:PostSharp.Extensibility.ModuleLoadReflectionFromFileStrategy.LoadAssembly" />
    <member name="M:PostSharp.Extensibility.ModuleLoadReflectionFromFileStrategy.ToString" />
    <member name="P:PostSharp.Extensibility.ModuleLoadReflectionFromFileStrategy.FileName">
      <summary>
            Gets the full physical path of the assembly.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.ModuleLoadReflectionFromNameStrategy">
      <summary>
            Implementation of <see cref="T:PostSharp.Extensibility.ModuleLoadStrategy" />
            loading the assembly by name, using the <b>Assembly.Load</b> method.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.ModuleLoadReflectionFromNameStrategy.#ctor(System.String)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.ModuleLoadReflectionFromNameStrategy" />.
            </summary>
      <param name="name">Assembly name.</param>
    </member>
    <member name="M:PostSharp.Extensibility.ModuleLoadReflectionFromNameStrategy.LoadAssembly" />
    <member name="M:PostSharp.Extensibility.ModuleLoadReflectionFromNameStrategy.ToString" />
    <member name="P:PostSharp.Extensibility.ModuleLoadReflectionFromNameStrategy.Name">
      <summary>
            Gets the assembly name.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.PostSharpDomainManager">
      <summary>
            Entry point of PostSharp with a hypothetical unmanaged bootstrapper,
            implementing an <see cref="T:System.AppDomainManager" />.
            </summary>
      <remarks>
            The unmanaged bootstrapper should case this object to <see cref="T:PostSharp.Extensibility.IPostSharpDomainManager" />,
            which is a COM interface.
            </remarks>
    </member>
    <member name="M:PostSharp.Extensibility.PostSharpDomainManager.InitializeNewDomain(System.AppDomainSetup)" />
    <member name="M:PostSharp.Extensibility.PostSharpDomainManager.Initialize(System.Boolean)">
      <summary>
            Initializes PostSharp.
            </summary>
      <param name="assemblyResolve">
        <b>true</b> if PostSharp should handle the
            <b>AppDomain.AssemblyResolve</b> event itself, <b>false</b> if it is done by
            the unmanaged host.</param>
    </member>
    <member name="M:PostSharp.Extensibility.PostSharpDomainManager.Start(System.String[])">
      <summary>
            Starts the PostSharp command line.
            </summary>
      <param name="args">Command line arguments.</param>
      <returns>Exit code.</returns>
    </member>
    <member name="M:PostSharp.Extensibility.PostSharpDomainManager.FindAssembly(System.String)">
      <summary>
            Finds an assembly given its name.
            </summary>
      <param name="assemblyName">Assembly name.</param>
      <returns>Assembly location, or <b>null</b> if the
            assembly could not be found.</returns>
    </member>
    <member name="T:PostSharp.Extensibility.PostSharpLocalHost">
      <summary>
            Object that stands between the <see cref="P:PostSharp.Extensibility.PostSharpLocalHost.PostSharpObject" /> and the remote host 
            (<see cref="T:PostSharp.Extensibility.IPostSharpHost" />). Lays in the PostSharp AppDomain.
            Typically derived by a host when some processings have to be done in the PostSharp AppDomain
            instead of the host AppDomain.
            </summary>
      <remarks>
            The default implementation of all methods just calls the remote host.
            </remarks>
      <note>
            Derived classes should have a default constructor.
            </note>
    </member>
    <member name="M:PostSharp.Extensibility.PostSharpLocalHost.Initialize">
      <summary>
            Initializes the current instance. 
            </summary>
      <remarks>
            This method is called just after the object is instantiated and the properties
            <see cref="P:PostSharp.Extensibility.PostSharpLocalHost.RemoteHost" /> and <see cref="P:PostSharp.Extensibility.PostSharpLocalHost.PostSharpObject" /> have been initialized.
            </remarks>
    </member>
    <member name="M:PostSharp.Extensibility.PostSharpLocalHost.ResolveAssemblyReference(PostSharp.CodeModel.IAssemblyName)">
      <summary>
            Returns the location and the loag arguments of an assembly known by name.
            </summary>
      <param name="assemblyName">Assembly name.</param>
      <returns>An <see cref="T:PostSharp.Extensibility.ModuleLoadStrategy" /> object containing principally the
            location of the assembly to load, or <b>null</b> if the host does not want
            to intervene in the default binding mechanism of the PostSharp Platform.</returns>
      <remarks>
            This method is called whenever an assembly reference has to be resolved inside the
            PostSharp Code Object Model, and this assembly has neither been resolved yet neither
            been passed to the <see cref="M:PostSharp.Extensibility.IPostSharpObject.InvokeProjects(PostSharp.Extensibility.ProjectInvocation[])" /> method.
            </remarks>
    </member>
    <member name="M:PostSharp.Extensibility.PostSharpLocalHost.GetProjectInvocationParameters(PostSharp.CodeModel.ModuleDeclaration)">
      <summary>
            Determines whether and how a module should be processed by PostSharp.
            </summary>
      <param name="module">Module that is being considered.</param>
      <returns>A <see cref="T:PostSharp.Extensibility.ProjectInvocationParameters" /> object if this module has to be
            processed, or <b>null</b> if the module should not be processed.</returns>
    </member>
    <member name="M:PostSharp.Extensibility.PostSharpLocalHost.RenameAssembly(PostSharp.CodeModel.AssemblyManifestDeclaration)">
      <summary>
            Notifies the host that an assembly has been renamed. This happens if the 
            <see cref="T:PostSharp.Extensibility.PostSharpObjectSettings" />.<see cref="P:PostSharp.Extensibility.PostSharpObjectSettings.OverwriteAssemblyNames" />
            flag has been set.
            </summary>
      <param name="assemblyManifest">The assembly manifest where the 
            <see cref="P:PostSharp.CodeModel.AssemblyManifestDeclaration.OverwrittenName" /> is different than
            the <b>Name</b> property.</param>
      <remarks>
            The assembly renaming is used in the runtime usage scenario in order to (1) remove
            strong names and (2) make sure that the unprocessed assembly is not loaded 'accidentally'
            by the default system binder (for instance because the transformed assembly lays in the GAC).
            See <see cref="P:PostSharp.Extensibility.PostSharpObjectSettings.OverwriteAssemblyNames" /> for details.
            </remarks>
    </member>
    <member name="M:PostSharp.Extensibility.PostSharpLocalHost.Dispose(System.Boolean)">
      <summary>
            Disposes the current object.
            </summary>
      <param name="disposing">
        <b>true</b> if the current method is called because the object
            is being disposed explicitely, <b>false</b> if it is called because of the
            destructor.</param>
    </member>
    <member name="M:PostSharp.Extensibility.PostSharpLocalHost.Dispose">
      <summary>
            Frees the resources consumed by the current object.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.PostSharpLocalHost.Finalize">
      <summary>
            Destructor.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.PostSharpLocalHost.RemoteHost">
      <summary>
            Gets the remote host (i.e. the <see cref="T:PostSharp.Extensibility.IPostSharpHost" /> located in the
            host AppDomain) associated to to the current instance.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.PostSharpLocalHost.PostSharpObject">
      <summary>
            Gets the <see cref="P:PostSharp.Extensibility.PostSharpLocalHost.PostSharpObject" /> associated to the current instance.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.PostSharpLocalHost.IsDisposed">
      <summary>
            Determines whether the current instance has been disposed.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.PostSharpObject">
      <summary>
            Implementation of <see cref="T:PostSharp.Extensibility.IPostSharpObject" />. The principal entry point of the
            PostSharp Platform.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.PostSharpObject.CreateInstance(PostSharp.Extensibility.PostSharpObjectSettings)">
      <summary>
            Creates a PostSharp Object using the default host implementation.
            </summary>
      <param name="settings">Settings of the PostSharp Object.</param>
      <returns>A PostSharp Object, the entry point of the PostSharp Platform Infrastructure.</returns>
      <remarks>
        <para>The default host implementation covers the compile-time usage scenario: projects are executed
            only when explicitely invoked by the <see cref="M:PostSharp.Extensibility.IPostSharpObject.InvokeProjects(PostSharp.Extensibility.ProjectInvocation[])" /> methods,
            never when they are 'discovered' at runtime.
            </para>
        <para>
            Note that, in every case, the host should register to the <see cref="E:PostSharp.Extensibility.Messenger.Message" />
            event of the <see cref="T:PostSharp.Extensibility.Messenger" /> object, in the current <see cref="P:PostSharp.Extensibility.PostSharpObject.AppDomain" />.
            </para>
      </remarks>
    </member>
    <member name="M:PostSharp.Extensibility.PostSharpObject.CreateInstance(PostSharp.Extensibility.PostSharpObjectSettings,PostSharp.Extensibility.IPostSharpHost)">
      <summary>
            Creates a PostSharp Object and specifies the host implementation.
            </summary>
      <param name="settings">Settings of the PostSharp Object.</param>
      <param name="host">An implementation of <see cref="T:PostSharp.Extensibility.IPostSharpHost" /> derived from
            <see cref="T:System.MarshalByRefObject" />, or <b>null</b> to use the default host implementation.
            </param>
      <returns>A PostSharp Object, the entry point of the PostSharp Platform Infrastructure.</returns>
      <remarks>
        <para>The default host implementation covers the compile-time usage scenario: projects are executed
            only when explicitely invoked by the <see cref="M:PostSharp.Extensibility.IPostSharpObject.InvokeProjects(PostSharp.Extensibility.ProjectInvocation[])" /> methods,
            never when they are 'discovered' at runtime.
            </para>
        <para>
            Note that, in every case, the host should register to the <see cref="E:PostSharp.Extensibility.Messenger.Message" />
            event of the <see cref="T:PostSharp.Extensibility.Messenger" /> object, in the current <see cref="P:PostSharp.Extensibility.PostSharpObject.AppDomain" />.
            </para>
      </remarks>
    </member>
    <member name="M:PostSharp.Extensibility.PostSharpObject.Dispose" />
    <member name="M:PostSharp.Extensibility.PostSharpObject.ProcessAssemblies(PostSharp.Extensibility.ModuleLoadStrategy[])">
      <summary>
            Requests the processing of assemblies by PostSharp. The projects to be executed and their
            paramaters are not yet known. They will be requested through the 
            <see cref="M:PostSharp.Extensibility.IPostSharpHost.GetProjectInvocationParameters(System.String,System.String,System.Reflection.AssemblyName)" /> method of the
            <see cref="T:PostSharp.Extensibility.IPostSharpHost" /> interface.
            </summary>
      <param name="modules">Array of assemblies to be processed.</param>
    </member>
    <member name="M:PostSharp.Extensibility.PostSharpObject.InvokeProject(PostSharp.Extensibility.ProjectInvocation)">
      <summary>
            Requests the processing of a single PostSharp project.
            </summary>
      <param name="projectInvocation">Parameters for the PostSharp invocation.</param>
    </member>
    <member name="M:PostSharp.Extensibility.PostSharpObject.InvokeProjects(PostSharp.Extensibility.ProjectInvocation[])">
      <summary>
            Requests the processing of PostSharp projects. Each project and its parameters
            are described in a <see cref="T:PostSharp.Extensibility.ProjectInvocation" /> object.
            </summary>
      <param name="projectInvocations">An array in which each element is a request
            to execute a PostSharp project.</param>
      <remarks>
            One source assembly may be processed only once in the lifetime of a <see cref="T:PostSharp.Extensibility.IPostSharpObject" />.
            </remarks>
    </member>
    <member name="P:PostSharp.Extensibility.PostSharpObject.AppDomain">
      <summary>
            Gets the <see cref="P:PostSharp.Extensibility.IPostSharpObject.AppDomain" /> in which the PostSharp Object lives.
            </summary>
    </member>
    <member name="E:PostSharp.Extensibility.PostSharpObject.PhaseExecuting">
      <summary>
            Event raised <i>before</i> a phase is executed on a group of projects,
            if the project execution mode is <see cref="F:PostSharp.Extensibility.ProjectExecutionOrder.Phased" />.
            </summary>
    </member>
    <member name="E:PostSharp.Extensibility.PostSharpObject.PhaseExecuted">
      <summary>
            Event raised <i>after</i> a phase has been executed on a group of projects,
            if the project execution mode is <see cref="F:PostSharp.Extensibility.ProjectExecutionOrder.Phased" />.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.PostSharpObject.Domain">
      <summary>
            Gets the <see cref="P:PostSharp.Extensibility.PostSharpObject.Domain" /> in which all modules are loaded and processed.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.PostSharpObject.CurrentProject">
      <summary>
            Gets the currently executing project.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.PhaseExecutedEventArgs">
      <summary>
            Arguments of the events <see cref="E:PostSharp.Extensibility.PostSharpObject.PhaseExecuting" />
            and <see cref="E:PostSharp.Extensibility.PostSharpObject.PhaseExecuted" />.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.PhaseExecutedEventArgs.Phase">
      <summary>
            Name of the phase.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.PhaseExecutedEventArgs.Projects">
      <summary>
            List of projects in the group being now executed, in 
            deep-first order of dependency relationships.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.PostSharpObjectSettings">
      <summary>
            Specifies how the PostSharp Object (<see cref="T:PostSharp.Extensibility.IPostSharpObject" />) should be instantiated
            and should behave.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.PostSharpObjectSettings.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.PostSharpObjectSettings" /> and set default values.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.PostSharpObjectSettings.CreatePrivateAppDomain">
      <summary>
            Determines whether the PostSharp Object should be created in a new <see cref="T:System.AppDomain" />.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.PostSharpObjectSettings.AppDomainSetup">
      <summary>
            The <see cref="P:PostSharp.Extensibility.PostSharpObjectSettings.AppDomainSetup" /> object used to create the private <see cref="T:System.AppDomain" />.
            Ignored if the property <see cref="P:PostSharp.Extensibility.PostSharpObjectSettings.CreatePrivateAppDomain" /> is false.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.PostSharpObjectSettings.PermissionSet">
      <summary>
            A default permission set that is granted to all assemblies loaded 
            into the new application domain that do not have specific grants. 
            Ignored if the property <see cref="P:PostSharp.Extensibility.PostSharpObjectSettings.CreatePrivateAppDomain" /> is false.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.PostSharpObjectSettings.Evidence">
      <summary>
            Evidence mapped through the security policy to establish a top-of-stack permission set 
            of the new <see cref="T:System.AppDomain" />. Ignored if the property <see cref="P:PostSharp.Extensibility.PostSharpObjectSettings.CreatePrivateAppDomain" /> is false.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.PostSharpObjectSettings.SearchDirectories">
      <summary>
            Gets the set of directories in which assemblies have to be searched.
            </summary>
      <remarks>
            This search path is useful when assemblies and their dependencies are loaded,
            <i>before</i> projects are executed. In order to specify the path of
            PostSharp plug-ins, it is preferable to use the standard search path facility of
            projects.
            </remarks>
    </member>
    <member name="P:PostSharp.Extensibility.PostSharpObjectSettings.DisabledMessages">
      <summary>
            Gets the set of messages that should be disabled.
            </summary>
      <remarks>
        <para>Populate the set with the identifier of messages to be disabled.
            You cannot disable errors or fatal errors.</para>
      </remarks>
    </member>
    <member name="P:PostSharp.Extensibility.PostSharpObjectSettings.OverwriteAssemblyNames">
      <summary>
            Determines whether the name of processed assemblies should be
            automatically modified.
            </summary>
      <remarks>
        <para>You will typically use <b>false</b> in the compile-time scenario
            and <b>true</b> in the runtime scenario.</para>
        <para>A <b>true</b> value instructs the PostSharp Object to suppress
            public keys from and to append a tilde to names of transformed
            assemblies. Removing public keys is required (unless you can resign
            assemblies after processing), otherwise the VRE will refuse to
            load transformed assemblies. Changing assembly names make sure
            that the system Assembly Binder does not load the original assembly
            and call 'our' custom binder.</para>
      </remarks>
    </member>
    <member name="P:PostSharp.Extensibility.PostSharpObjectSettings.LocalHostImplementation">
      <summary>
            Gets or sets the assembly-qualified name of the implementation
            of the local host. This type should be derived from <see cref="T:PostSharp.Extensibility.PostSharpLocalHost" />
            and have a default constructor.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.PostSharpObjectSettings.ProjectExecutionOrder">
      <summary>
            Gets or sets the project execution order. Determines whether projects
            should be executed sequentially or per phase.
            </summary>
      <seealso cref="T:PostSharp.Extensibility.ProjectExecutionOrder" />
    </member>
    <member name="P:PostSharp.Extensibility.PostSharpObjectSettings.DomainTags">
      <summary>
            Gets the collection of domainTags set on the PostSharp Object.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.PostSharpObjectSettings.Settings">
      <summary>
            Gets or sets the PostSharp settings (overwriting the ones in <b>PostSharp-Library.config</b>).
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.PostSharpObjectSettings.DisableReflection">
      <summary>
            Determines whether user code is allowed to be loaded in the CLR. 
            </summary>
      <remarks>
            The value should typically be <b>true</b> for assemblies linked against the full .NET Framework,
            and <b>false</b> for assemblies linked against the Compact Framework or Silverlight.
            </remarks>
    </member>
    <member name="T:PostSharp.Extensibility.ProjectExecutionOrder">
      <summary>
            Determines in which order tasks of projects should be executed. This is
            relevant only when the <see cref="M:PostSharp.Extensibility.PostSharpObject.InvokeProjects(PostSharp.Extensibility.ProjectInvocation[])" /> method
            is called with many projects <i>or</i> if many projects are executed
            together due to recursive processing.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.ProjectExecutionOrder.Default">
      <summary>
            Default execution order: <see cref="F:PostSharp.Extensibility.ProjectExecutionOrder.Sequential" />.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.ProjectExecutionOrder.Sequential">
      <summary>
            Projects are executed atomically. All tasks of all phases of one project are executed,
            then the next projects are executed.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.ProjectExecutionOrder.Phased">
      <summary>
            Groups of projects are executed per phase. Tasks of one phases of all projects are executed,
            then the next phases are are executed for all projects.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.CommandLineReturnCode">
      <summary>
            Return codes of <see cref="T:PostSharp.Extensibility.CommandLineProgram" />.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.CommandLineReturnCode.Success">
      <summary>
            Success.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.CommandLineReturnCode.InvalidCommandLine">
      <summary>
            Invalid command line.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.CommandLineReturnCode.Error">
      <summary>
            Error (emitted as a <see cref="T:PostSharp.Extensibility.Message" />).
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.CommandLineReturnCode.Exception">
      <summary>
            Unhandled exception.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.CommandLineReturnCode.DisappointingMessages">
      <summary>
            An expected message was not emitted.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.CommandLineProgram">
      <summary>
            Implementation of the command-line utility.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.CommandLineProgram.Main(System.String[])">
      <summary>
            Invokes the command-line utility.
            </summary>
      <param name="args">Command-line arguments.</param>
      <returns>Return code.</returns>
    </member>
    <member name="T:PostSharp.Extensibility.Project">
      <summary>
            Contains the actual configuration of the application or project at a
            given time in the project loading process, i.e. with resolved
            properties and references.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Project.AddPlugIn(System.String)">
      <summary>
            Adds and load a plugin in the current project.
            </summary>
      <param name="shortName">Name of the plug-in (without directory or extension)</param>
      <returns>
        <b>true</b> if the plug-in was just added, <b>false</b> if it was
            already loaded.</returns>
    </member>
    <member name="M:PostSharp.Extensibility.Project.CreateInstance(System.String,PostSharp.CodeModel.Domain,PostSharp.Extensibility.ModuleLoadStrategy,PostSharp.Extensibility.PropertyCollection,PostSharp.Extensibility.TagCollection)">
      <summary>
            Creates a new <see cref="T:PostSharp.Extensibility.Project" /> instance and assigns it to
            a module that has not already been loaded.
            </summary>
      <param name="projectFileName">The location of the project file to be executed.</param>
      <param name="domain">The <see cref="T:PostSharp.CodeModel.Domain" /> into which the module has to be loaded.</param>
      <param name="moduleLoadStrategy">Specifies how the assembly should be loaded.</param>
      <param name="properties">Collection of properties for the project execution.</param>
      <param name="tags">Collection of tags to be applied to the project, or <b>null</b>
            if no tag has to be applied.</param>
      <returns>
        <b>true</b> if the project was successful, otherwise <b>false</b>.</returns>
    </member>
    <member name="M:PostSharp.Extensibility.Project.CreateInstance(System.String,PostSharp.CodeModel.ModuleDeclaration,PostSharp.Extensibility.PropertyCollection,PostSharp.Extensibility.TagCollection)">
      <summary>
            Creates a new <see cref="T:PostSharp.Extensibility.Project" /> and assigns it to
            a module has already been loaded as a <see cref="T:PostSharp.CodeModel.ModuleDeclaration" />.
            </summary>
      <param name="projectFileName">Location of the project file to be executed.</param>
      <param name="properties">Collection of properties for the project execution.</param>
      <param name="module">Module that needs to be processed.</param>
      <param name="tags">Collection of tags to be applied to the project, or <b>null</b>
            if no tag has to be applied.</param>
      <returns>
        <b>true</b> if the project was successful, otherwise <b>false</b>.</returns>
    </member>
    <member name="M:PostSharp.Extensibility.Project.AddPath(System.String)">
      <summary>
            Add a directory to the project search path.
            </summary>
      <param name="path">A directory name.</param>
    </member>
    <member name="M:PostSharp.Extensibility.Project.GetFullPath(System.String)">
      <summary>
            Gets the full path of a path that may be given either absolutely either relatively.
            </summary>
      <param name="path">Path that may be given either absolutely, either relatively to the reference directory
            of the current project. This path may contain expressions.</param>
      <returns>The full path corresponding to <paramref name="path" />, or <b>null</b> if <paramref name="path" />
            contained an expression that could not be resolved.</returns>
    </member>
    <member name="M:PostSharp.Extensibility.Project.Evaluate(System.String)">
      <summary>
            Evaluates an expression.
            </summary>
      <param name="expression">An expression.</param>
      <returns>The expression value.</returns>
    </member>
    <member name="M:PostSharp.Extensibility.Project.ExecutePhase(System.String)">
      <summary>
            Executes a single phase of the project.
            </summary>
      <param name="phase">Name of the phase to be executed.</param>
      <returns>
        <b>true</b> if the execution was successfull, otherwise <b>false</b>.</returns>
    </member>
    <member name="M:PostSharp.Extensibility.Project.Execute">
      <summary>
            Executes the current project.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Project.GetTag(System.Guid)">
      <summary>
            Gets a tag associated with the current declaration.
            </summary>
      <param name="guid">Tag identifier.</param>
      <returns>An object, or <b>null</b> if no tag of type <paramref name="guid" />
            is associated to the current declaration.</returns>
    </member>
    <member name="M:PostSharp.Extensibility.Project.SetTag(System.Guid,System.Object)">
      <summary>
            Set a tag to the current declaration.
            </summary>
      <param name="guid">Tag identifier.</param>
      <param name="value">Tag value.</param>
    </member>
    <member name="M:PostSharp.Extensibility.Project.Dispose" />
    <member name="P:PostSharp.Extensibility.Project.Platforms">
      <summary>
            Gets the directory of platforms indexed by name.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Project.Properties">
      <summary>
            Gets the collection of properties.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Project.TaskTypes">
      <summary>
            Gets the directory of task types indexed by name.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Project.Phases">
      <summary>
            Gets the collection of phases.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Project.PlugIns">
      <summary>
            Gets the collection of plug-ins included at this point.
            </summary>
      <remarks>
            This collection contains the full paths of loaded plug-ins. This is to avoid
            cycles in references.
            </remarks>
    </member>
    <member name="P:PostSharp.Extensibility.Project.ProjectConfiguration">
      <summary>
            Gets the project configuration element.
            </summary>
      <value>
            A <see cref="P:PostSharp.Extensibility.Project.ProjectConfiguration" />, or <b>null</b> if no project has been loaded.
            </value>
    </member>
    <member name="P:PostSharp.Extensibility.Project.Module">
      <summary>
            Gets the target <see cref="T:PostSharp.CodeModel.ModuleDeclaration" /> in its current state.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Project.Tasks">
      <summary>
            Gets the collection of project tasks,
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Project.Platform">
      <summary>
            Gets the target platform.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Project.StrongNames">
      <summary>
            Gets the mappings between assembly friendly names and the corresponding strong names.
            </summary>
      <remarks>
            This dictionary is used to automatically map short names to strong names in case
            a short name is found in a configuration file.
            </remarks>
    </member>
    <member name="P:PostSharp.Extensibility.Project.ApplicationConfiguration">
      <summary>
            Gets the application-level configuration.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Project.IsDisposed">
      <summary>
            Determines whether the current instance has been disposed.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.ProjectInvocation">
      <summary>
            Request to execute a <see cref="T:PostSharp.Extensibility.Project" />.
            </summary>
      <remarks>
            When invoking a project, one should give (1) the project to execute, (2) the module
            that should be processed and (3) some user-defined properties. The two last elements
            are encapsulates by the <see cref="T:PostSharp.Extensibility.ProjectInvocationParameters" /> class. The
            <see cref="T:PostSharp.Extensibility.ProjectInvocation" /> class encapsulates both the module identity and a
            <see cref="T:PostSharp.Extensibility.ProjectInvocationParameters" /> object.
            </remarks>
    </member>
    <member name="M:PostSharp.Extensibility.ProjectInvocation.#ctor(PostSharp.Extensibility.ProjectInvocationParameters,PostSharp.Extensibility.ModuleLoadStrategy)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.ProjectInvocation" /> and informs to process
            the default module (manifest module) of the given assembly.
            </summary>
      <param name="invocationParameters">Identity of the project to be executed and
            their parameters.</param>
      <param name="moduleLoadStrategy">Identity of the assembly to be loaded.</param>
    </member>
    <member name="P:PostSharp.Extensibility.ProjectInvocation.ModuleLoadStrategy">
      <summary>
            Gets the identity of the assembly and the arguments with which it should be loaded.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.ProjectInvocation.InvocationParameters">
      <summary>
            Gets the identity of the project and the parameters with which it should be executed.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.ProjectInvocationParameters">
      <summary>
            Determines how an already-given module should be processed. Encapsulates a project identity
            and the properties with which it should be executed.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.ProjectInvocationParameters.#ctor(System.String)">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.ProjectInvocationParameters" />.
            </summary>
      <param name="projectConfigurationFile">Location of the project file.</param>
    </member>
    <member name="P:PostSharp.Extensibility.ProjectInvocationParameters.Properties">
      <summary>
            Gets the collection of properties with which the project should be executed.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.ProjectInvocationParameters.ProjectConfigurationFile">
      <summary>
            Gets the location of the project configuration file.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.ProjectInvocationParameters.ProcessDependenciesFirst">
      <summary>
            Determines whether the dependencies of this module should be processed before.
            </summary>
      <remarks>
            If this property is <b>true</b>, the PostSharp Object will call the 
            <see cref="M:PostSharp.Extensibility.IPostSharpHost.GetProjectInvocationParameters(System.String,System.String,System.Reflection.AssemblyName)" /> for each dependency.
            </remarks>
    </member>
    <member name="P:PostSharp.Extensibility.ProjectInvocationParameters.Tags">
      <summary>
            Gets the collection of tags that needs to be passed to the
            <see cref="T:PostSharp.Extensibility.Project" />.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.ProjectInvocationParameters.PreventOverwriteAssemblyNames">
      <summary>
            If <b>true</b>, the name of this assembly won't be overwritten.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.PropertyCollection">
      <summary>
            Collection of properties.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.PropertyCollection.Merge(PostSharp.Extensibility.PropertyCollection)">
      <summary>
            Merge another collection of properties into the current collection.
            </summary>
      <param name="properties">Another collection of properties.</param>
    </member>
    <member name="P:PostSharp.Extensibility.PropertyCollection.Item(System.String)">
      <summary>
            Gets or sets a property.
            </summary>
      <param name="key">Property name.</param>
      <returns>The property value, or <b>null</b> if the property is not defined.</returns>
    </member>
    <member name="T:PostSharp.Collections.SimpleLinkedListNode`1">
      <summary>
            Minimalist implementation of a one-direction linked list.
            </summary>
      <typeparam name="T">Type of values.</typeparam>
      <remarks>There is no node implementing the <i>list</i>. Everything
            is a <i>node</i>. When using the <see cref="T:System.Collections.Generic.IEnumerable`1" /> interface,
            you get an enumeration of the current node and all the next nodes.</remarks>
    </member>
    <member name="M:PostSharp.Collections.SimpleLinkedListNode`1.#ctor(`0,PostSharp.Collections.SimpleLinkedListNode{`0})">
      <summary>
            Initializes a new node.
            </summary>
      <param name="value">Node value.</param>
      <param name="next">Next node.</param>
    </member>
    <member name="M:PostSharp.Collections.SimpleLinkedListNode`1.GetLast">
      <summary>
            Gets the last node in the list.
            </summary>
      <returns>The last node in the list.</returns>
    </member>
    <member name="M:PostSharp.Collections.SimpleLinkedListNode`1.GetEnumerator(PostSharp.Collections.SimpleLinkedListNode{`0})">
      <summary>
            Gets an enumerator of the list starting at a given node.
            </summary>
      <param name="node">The first node of the list, or <b>null</b>.</param>
      <returns>An enumerator for <paramref name="node" /> and all following nodex.</returns>
    </member>
    <member name="M:PostSharp.Collections.SimpleLinkedListNode`1.Insert(PostSharp.Collections.SimpleLinkedListNode{`0}@,`0)">
      <summary>
            Inserts a value at the beginning of a list.
            </summary>
      <param name="node">Reference to the head node. May safely be a reference to a <b>null</b> node.</param>
      <param name="value">Value.</param>
    </member>
    <member name="M:PostSharp.Collections.SimpleLinkedListNode`1.Append(PostSharp.Collections.SimpleLinkedListNode{`0}@,`0)">
      <summary>
            Appends a value at the end of a list.
            </summary>
      <param name="node">Reference to a node of the list. May safely be a reference to a <b>null</b> node.</param>
      <param name="value">Value.</param>
    </member>
    <member name="M:PostSharp.Collections.SimpleLinkedListNode`1.Append(PostSharp.Collections.SimpleLinkedListNode{`0}@,PostSharp.Collections.SimpleLinkedListNode{`0})">
      <summary>
            Appends a list at the end of another one.
            </summary>
      <param name="node">Reference of a node of the 'left' list.
            May safely be a reference to a <b>null</b> node.</param>
      <param name="list">Reference to the head of the 'right' list.
            May safely be a <b>null</b> node.</param>
      <remarks>
            The 'right' list (<paramref name="list" />) is cloned, so
            nodes are never shared between lists.
            </remarks>
    </member>
    <member name="M:PostSharp.Collections.SimpleLinkedListNode`1.Remove(PostSharp.Collections.SimpleLinkedListNode{`0}@,`0)">
      <summary>
            Finds a node in a list and removes it.
            </summary>
      <param name="node">Reference to the head node. May safely be a reference to a <b>null</b> node.</param>
      <param name="value">The value to remove.</param>
      <returns>
        <b>true</b> if the node was found and removed, otherwise <b>false</b>.</returns>
    </member>
    <member name="M:PostSharp.Collections.SimpleLinkedListNode`1.GetEnumerator">
      <summary>
            Gets an enumerator for the current and following nodes.
            </summary>
      <returns>An enumerator.</returns>
    </member>
    <member name="M:PostSharp.Collections.SimpleLinkedListNode`1.Clone">
      <summary>
            Clone the current node (but not the value).
            </summary>
      <returns>A copy of the current node.</returns>
    </member>
    <member name="P:PostSharp.Collections.SimpleLinkedListNode`1.Value">
      <summary>
            Gets or sets the node value.
            </summary>
    </member>
    <member name="P:PostSharp.Collections.SimpleLinkedListNode`1.Next">
      <summary>
            Gets the next node.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.TagCollection">
      <summary>
            Collection of tags (see <see cref="T:PostSharp.ITaggable" />). Used to pass tags from the
            host to the <see cref="T:PostSharp.CodeModel.Domain" /> and <see cref="T:PostSharp.Extensibility.Project" /> objects.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.TagCollection.GetTag(System.Guid)">
      <summary>
            Gets a tag associated with the current declaration.
            </summary>
      <param name="guid">Tag identifier.</param>
      <returns>An object, or <b>null</b> if no tag of type <paramref name="guid" />
            is associated to the current declaration.</returns>
    </member>
    <member name="M:PostSharp.Extensibility.TagCollection.SetTag(System.Guid,System.Object)">
      <summary>
            Set a tag to the current declaration.
            </summary>
      <param name="guid">Tag identifier.</param>
      <param name="value">Tag value.</param>
    </member>
    <member name="T:PostSharp.Extensibility.TaskState">
      <summary>
            States of a <see cref="T:PostSharp.Extensibility.Task" />.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.TaskState.Queued">
      <summary>
            Queued. The task has not been executed.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.TaskState.Default">
      <summary>
            Default = <see cref="F:PostSharp.Extensibility.TaskState.Queued" />.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.TaskState.Executing">
      <summary>
            The task is being executed now.
            </summary>
    </member>
    <member name="F:PostSharp.Extensibility.TaskState.Executed">
      <summary>
            The task has already been executed.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.TaskCollection">
      <summary>
            Collection of tasks (<see cref="T:PostSharp.Extensibility.Task" />).
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.TaskCollection.Add(System.String)">
      <summary>
            Adds to the current collection a new task given its name.
            </summary>
      <param name="taskTypeName">Name of the task type.</param>
    </member>
    <member name="M:PostSharp.Extensibility.TaskCollection.AddRange(System.Collections.Generic.IEnumerable{PostSharp.Extensibility.Task})">
      <summary>
            Adds a range of tasks, then resolve dependencies and sort.
            </summary>
      <param name="tasks">A range of tasks.</param>
    </member>
    <member name="M:PostSharp.Extensibility.TaskCollection.Add(PostSharp.Extensibility.Task)">
      <summary>
            Adds a <see cref="T:PostSharp.Extensibility.Task" /> to the collection.
            </summary>
      <param name="item">A <see cref="T:PostSharp.Extensibility.Task" />.</param>
      <remarks>
            This method shall also add all tasks that are required by <paramref name="item" />.
            </remarks>
    </member>
    <member name="M:PostSharp.Extensibility.TaskCollection.Clear">
      <summary>
            Remove all items of th current collection.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.TaskCollection.Contains(PostSharp.Extensibility.Task)">
      <summary>
            Determines whether the current collection contains a given <see cref="T:PostSharp.Extensibility.Task" />.
            </summary>
      <param name="item">A <see cref="T:PostSharp.Extensibility.Task" />.</param>
      <returns>
        <b>true</b> if this collection contains <paramref name="item" />,
            otherwise <b>false</b>.</returns>
    </member>
    <member name="M:PostSharp.Extensibility.TaskCollection.CopyTo(PostSharp.Extensibility.Task[],System.Int32)" />
    <member name="M:PostSharp.Extensibility.TaskCollection.Remove(PostSharp.Extensibility.Task)" />
    <member name="M:PostSharp.Extensibility.TaskCollection.GetEnumerator" />
    <member name="M:PostSharp.Extensibility.TaskCollection.GetInterfaces``1">
      <summary>
            Enumerates all tasks implementing a given interface.
            </summary>
      <typeparam name="T">The interface that tasks have to implement.</typeparam>
      <returns>An enumerator returning all tasks implementing <typeparamref name="T" />.</returns>
    </member>
    <member name="M:PostSharp.Extensibility.TaskCollection.Dispose" />
    <member name="P:PostSharp.Extensibility.TaskCollection.Item(System.String)">
      <summary>
            Gets a <see cref="T:PostSharp.Extensibility.Task" /> given its type name.
            </summary>
      <param name="taskTypeName">Name of the task type.</param>
      <returns>A <see cref="T:PostSharp.Extensibility.Task" />, or <b>null</b> if the task was not found.</returns>
    </member>
    <member name="P:PostSharp.Extensibility.TaskCollection.Count" />
    <member name="P:PostSharp.Extensibility.TaskCollection.IsDisposed">
      <summary>
            Determines whether the collection has been disposed.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.Tasks.AnnotationRepositoryTask">
      <summary>
            Repository of custom attributes applying on a module. Custom attributes
            may come from different sources (sources whould implement the
            <see cref="T:PostSharp.Extensibility.Tasks.IAnnotationProvider" /> interface) and are indexed
            by type.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Tasks.AnnotationRepositoryTask.GetTask(PostSharp.Extensibility.Project)">
      <summary>
            Finds the current task in a <see cref="T:PostSharp.Extensibility.Project" />.
            </summary>
      <param name="project">A <see cref="T:PostSharp.Extensibility.Project" />.</param>
      <returns>The <see cref="T:PostSharp.Extensibility.Tasks.IndexGenericInstancesTask" /> contained in the project,
            or <b>null</b> if this project does not contai the current task.</returns>
    </member>
    <member name="M:PostSharp.Extensibility.Tasks.AnnotationRepositoryTask.Execute" />
    <member name="M:PostSharp.Extensibility.Tasks.AnnotationRepositoryTask.AddAnnotation(PostSharp.CodeModel.IAnnotationInstance)">
      <summary>
            Adds a custom attribute instance to the current repository.
            </summary>
      <param name="instance">A new custom attribute instance.</param>
    </member>
    <member name="M:PostSharp.Extensibility.Tasks.AnnotationRepositoryTask.RemoveAnnotation(PostSharp.CodeModel.IAnnotationInstance)">
      <summary>
            Removes a custom attribute instance from the current repository.
            </summary>
      <param name="instance">The custom attribute instance to remove.</param>
    </member>
    <member name="M:PostSharp.Extensibility.Tasks.AnnotationRepositoryTask.GetAnnotationsOnTarget(PostSharp.CodeModel.MetadataDeclaration)">
      <summary>
            Gets an enumerator of all annotations defined on a target (i.e. on a <see cref="T:PostSharp.CodeModel.MetadataDeclaration" />).
            </summary>
      <param name="target">The declaration whose annotations have to be returned.</param>
      <returns>An enumerator of all annotations defined on <paramref name="target" />.</returns>
    </member>
    <member name="M:PostSharp.Extensibility.Tasks.AnnotationRepositoryTask.GetAnnotationsOfType(System.Type,System.Boolean)">
      <summary>
            Gets all custom attribute instances of a given custom attribute class,
            given a base <see cref="T:System.Type" />.
            </summary>
      <param name="type">Base type of requested custom attribute instances.</param>
      <param name="inherited">Whether instances of types inherited from <paramref name="type" />
            are requested.</param>
      <returns>An enumerator of the requested custom attribute instances.</returns>
    </member>
    <member name="M:PostSharp.Extensibility.Tasks.AnnotationRepositoryTask.GetAnnotationsOfType(PostSharp.CodeModel.TypeDefDeclaration,System.Boolean)">
      <summary>
            Gets all custom attribute instances of a given custom attribute class,
            given a base <see cref="T:PostSharp.CodeModel.TypeDefDeclaration" />.
            </summary>
      <param name="type">Base type of requested custom attribute instances.</param>
      <param name="inherited">Whether instances of types inherited from <paramref name="type" />
            are requested.</param>
      <returns>An enumerator of the requested custom attribute instances.</returns>
    </member>
    <member name="T:PostSharp.Extensibility.Tasks.AutoDetectTask">
      <summary>
            Tasks that detects automatically other tasks required by the module on the base
            of custom attributes annotated with the <see cref="T:PostSharp.Extensibility.RequirePostSharpAttribute" />
            custom attribute.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Tasks.AutoDetectTask.Execute" />
    <member name="T:PostSharp.Extensibility.Tasks.CompileTask">
      <summary>
        <see cref="T:PostSharp.Extensibility.Task" /> that compiles a module into MSIL
            or into binary form.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Tasks.CompileTask.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.Tasks.CompileTask" />.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Tasks.CompileTask.Execute" />
    <member name="P:PostSharp.Extensibility.Tasks.CompileTask.IntermediateDirectory">
      <summary>
            Gets or sets the intermediate directory 
            (where IL and resource files will be written).
            </summary>
      <value>
            A directory path, or <b>null</b> to store
            intermediate files in a temporary directory.
            </value>
    </member>
    <member name="P:PostSharp.Extensibility.Tasks.CompileTask.TargetFile">
      <summary>
            Gets or sets the target location of the binary module.
            </summary>
      <value>
            The location of the target binary module (absolute or relative to the project
            file), or <b>null</b> if the IL code should not be assembled.
            </value>
    </member>
    <member name="P:PostSharp.Extensibility.Tasks.CompileTask.DebugOption">
      <summary>
            Determines how debugging will be supported for
            the target module.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Tasks.CompileTask.SignAssembly">
      <summary>
            Determines whether the assembly should be signed using a digital key.
            If set to <see cref="F:PostSharp.BoolWithDefault.Default" />, the task will look
            for the custom attributes <see cref="T:System.Reflection.AssemblyKeyFileAttribute" />
            and <see cref="T:System.Reflection.AssemblyKeyNameAttribute" />.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Tasks.CompileTask.ForbidSignAssembly">
      <summary>
            If <b>true</b>, the assembly will not be signed. This property
            overwrites the <see cref="P:PostSharp.Extensibility.Tasks.CompileTask.SignAssembly" /> property and the
             custom attributes <see cref="T:System.Reflection.AssemblyKeyFileAttribute" />
            and <see cref="T:System.Reflection.AssemblyKeyNameAttribute" />.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Tasks.CompileTask.PrivateKeyLocation">
      <summary>
            If <see cref="P:PostSharp.Extensibility.Tasks.CompileTask.SignAssembly" /> is <b>true</b>, full path of the key
            file that should be used to sign the assembly. If the key should not
            be taken from a file, but from a key repository, this property
            should start with an '<b>@</b>' sign.
            </summary>
      <remarks>
            The path may be given in the form <c>{Reference Directory}<b>|{Relative Path}</b></c>.
            In this case, the relative path given in the right part of the string is resolved according
            to the reference directory given in the left part. If a full path is given in the right part,
            the reference directory is ignored.
            </remarks>
    </member>
    <member name="P:PostSharp.Extensibility.Tasks.CompileTask.CleanIntermediate">
      <summary>
            Determines whether the intermediate directory should
            be cleaned after compilation.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Tasks.CompileTask.Compatibility">
      <summary>
            Not really supported.
            </summary>
    </member>
    <member name="P:PostSharp.Extensibility.Tasks.CompileTask.Encoding">
      <summary>
            Gets or sets the encoding of the intermediate MSIL file.
            It needs to be supported by ILASM.
            </summary>
    </member>
    <member name="T:PostSharp.Extensibility.Tasks.DisableMessagesTask">
      <summary>
            Tasks that detects <see cref="T:PostSharp.Extensibility.DisablePostSharpMessageAttribute" /> custom attributes and
            disable messages accordingly.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Tasks.DisableMessagesTask.Execute" />
    <member name="T:PostSharp.Extensibility.Tasks.GlobalsTask">
      <summary>
            Performs the transformations required by the <see cref="T:PostSharp.Post" /> class.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Tasks.GlobalsTask.Execute" />
    <member name="M:PostSharp.Extensibility.Tasks.GlobalsTask.ProvideAdvices(PostSharp.CodeWeaver.Weaver)">
      <summary>
            When implemented, adds advices to a <see cref="T:PostSharp.CodeWeaver.Weaver" />, typically
            using the <see cref="M:PostSharp.CodeWeaver.Weaver.AddMethodLevelAdvice(PostSharp.CodeWeaver.IAdvice,System.Collections.Generic.IEnumerable{PostSharp.CodeModel.MethodDefDeclaration},PostSharp.CodeWeaver.JoinPointKinds,System.Collections.Generic.IEnumerable{PostSharp.CodeModel.MetadataDeclaration})" /> and 
            <see cref="M:PostSharp.CodeWeaver.Weaver.AddTypeLevelAdvice(PostSharp.CodeWeaver.IAdvice,PostSharp.CodeWeaver.JoinPointKinds,System.Collections.Generic.IEnumerable{PostSharp.CodeModel.TypeDefDeclaration})" /> methods.
            </summary>
      <param name="codeWeaver">The weaver to which advices should be added.</param>
    </member>
    <member name="T:PostSharp.Extensibility.Tasks.IAnnotationProvider">
      <summary>
            When implemented by a <see cref="T:PostSharp.Extensibility.Task" />, provides custom attribute instances
            to the <see cref="T:PostSharp.Extensibility.Tasks.AnnotationRepositoryTask" /> task.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Tasks.IAnnotationProvider.GetAnnotations">
      <summary>
            Enumerates the custom attribute instances (<see cref="T:PostSharp.CodeModel.IAnnotationInstance" />)
            providen by the current task.
            </summary>
      <returns>An enumerator of custom attributes provided by the current task.</returns>
    </member>
    <member name="T:PostSharp.Extensibility.Tasks.ModuleAnnotationProvider">
      <summary>
            Implementation of <see cref="T:PostSharp.Extensibility.Tasks.IAnnotationProvider" /> that provides the custom
            attribute instances defined in the module (i.e. <see cref="T:PostSharp.CodeModel.CustomAttributeDeclaration" />).
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Tasks.ModuleAnnotationProvider.Execute" />
    <member name="M:PostSharp.Extensibility.Tasks.ModuleAnnotationProvider.GetAnnotations">
      <summary>
            Enumerates the custom attribute instances (<see cref="T:PostSharp.CodeModel.IAnnotationInstance" />)
            providen by the current task.
            </summary>
      <returns>An enumerator of custom attributes provided by the current task.</returns>
    </member>
    <member name="T:PostSharp.Extensibility.Tasks.ImplementationBoundAttributesTask">
      <summary>
            Determines whether a custom attribute is bound to its implementation,
            i.e. provides an index of instances of the <see cref="T:PostSharp.Extensibility.ImplementationBoundAttributeAttribute" />
            custom attribute.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Tasks.ImplementationBoundAttributesTask.GetTask(PostSharp.Extensibility.Project)">
      <summary>
            Gets the <see cref="T:PostSharp.Extensibility.Tasks.ImplementationBoundAttributesTask" /> task in a project.
            </summary>
      <param name="project">Project.</param>
      <returns>The <see cref="T:PostSharp.Extensibility.Tasks.ImplementationBoundAttributesTask" /> if one was found in
            the project, or <b>null</b> otherwise.</returns>
    </member>
    <member name="M:PostSharp.Extensibility.Tasks.ImplementationBoundAttributesTask.Execute" />
    <member name="M:PostSharp.Extensibility.Tasks.ImplementationBoundAttributesTask.IsImplementationBound(PostSharp.CodeModel.IType)">
      <summary>
            Determines whether a custom attribute of a given type is bound to the implementation of the
            semantic to which it was applied.
            </summary>
      <param name="attributeType">Type of the custom attribute.</param>
      <returns>
        <b>true</b> if custom attributes of type <paramref name="attributeType" /> are bound 
            to the implementation of the semantic to which they are applied, or <b>false</b>
            if these custom attributes should be moved to the semantic when semantics are split
            from implementations.</returns>
      <see cref="T:PostSharp.Extensibility.ImplementationBoundAttributeAttribute" />
    </member>
    <member name="T:PostSharp.Extensibility.Tasks.IndexGenericInstancesTask">
      <summary>
            Task that references generic instances as tags in generic definitions.
            </summary>
      <remarks>
        <para>
            This tasks creates the following backlinks:
            </para>
        <list type="table">
          <listheader>
            <term>Parent</term>
            <description>Children</description>
          </listheader>
          <item>
            <term>
              <see cref="T:PostSharp.CodeModel.TypeDefDeclaration" />
            </term>
            <description>
              <see cref="T:PostSharp.CodeModel.TypeSpecDeclaration" />.</description>
          </item>
          <item>
            <term>
              <see cref="T:PostSharp.CodeModel.FieldDefDeclaration" />
            </term>
            <description>
              <see cref="T:PostSharp.CodeModel.FieldRefDeclaration" /> whose declaring type is a <see cref="T:PostSharp.CodeModel.TypeSpecDeclaration" />.</description>
          </item>
          <item>
            <term>
              <see cref="T:PostSharp.CodeModel.MethodDefDeclaration" />
            </term>
            <description>
              <see cref="T:PostSharp.CodeModel.MethodRefDeclaration" /> whose declaring type is a <see cref="T:PostSharp.CodeModel.TypeSpecDeclaration" />;
                        <see cref="T:PostSharp.CodeModel.MethodSpecDeclaration" />.
                    </description>
          </item>
        </list>
      </remarks>
    </member>
    <member name="M:PostSharp.Extensibility.Tasks.IndexGenericInstancesTask.GetGenericInstances(PostSharp.CodeModel.MetadataDeclaration)">
      <summary>
            Get the collection of generic instances of a given generic declaration.
            </summary>
      <param name="item">A generic declaration.</param>
      <returns>The collection of generic instances of <paramref name="item" />, or 
            <b>null</b> if <paramref name="item" /> has no generic instance in
            the given module.</returns>
    </member>
    <member name="M:PostSharp.Extensibility.Tasks.IndexGenericInstancesTask.GetTask(PostSharp.Extensibility.Project)">
      <summary>
            Finds the current task in a <see cref="T:PostSharp.Extensibility.Project" />.
            </summary>
      <param name="project">A <see cref="T:PostSharp.Extensibility.Project" />.</param>
      <returns>The <see cref="T:PostSharp.Extensibility.Tasks.IndexGenericInstancesTask" /> contained in the project,
            or <b>null</b> if this project does not contai the current task.</returns>
    </member>
    <member name="M:PostSharp.Extensibility.Tasks.IndexGenericInstancesTask.Execute" />
    <member name="T:PostSharp.Extensibility.Tasks.IndexTypeDefMemberRefsTask">
      <summary>
            Indexes all <b>MemberRefs</b> (<see cref="T:PostSharp.CodeModel.MemberRefDeclaration" />) owned by a <b>TypeDef</b> (<see cref="T:System.Type" />),
            and relate them to the corresponding <see cref="T:PostSharp.CodeModel.FieldDefDeclaration" /> or <see cref="T:PostSharp.CodeModel.MethodDefDeclaration" />.
            </summary>
      <remarks>
            It is stupid, but some compilers use a <see cref="T:PostSharp.CodeModel.FieldRefDeclaration" /> or a <see cref="T:PostSharp.CodeModel.MethodRefDeclaration" />
            inside the current module, although they could use 
             a <see cref="T:PostSharp.CodeModel.FieldDefDeclaration" /> or a <see cref="T:PostSharp.CodeModel.MethodDefDeclaration" /></remarks>
    </member>
    <member name="M:PostSharp.Extensibility.Tasks.IndexTypeDefMemberRefsTask.Execute" />
    <member name="M:PostSharp.Extensibility.Tasks.IndexTypeDefMemberRefsTask.GetReferences(PostSharp.CodeModel.IMember)">
      <summary>
            Gets the collection of <b>MemberRefs</b> (<see cref="T:PostSharp.CodeModel.MemberRefDeclaration" />) that
            are used to access a given <see cref="T:PostSharp.CodeModel.FieldDefDeclaration" /> or <see cref="T:PostSharp.CodeModel.MethodDefDeclaration" />.
            </summary>
      <param name="member">A <see cref="T:PostSharp.CodeModel.FieldDefDeclaration" /> or a <see cref="T:PostSharp.CodeModel.MethodDefDeclaration" />.</param>
      <returns>The collection of <see cref="T:PostSharp.CodeModel.MemberRefDeclaration" /> referencing <paramref name="member" />.</returns>
    </member>
    <member name="T:PostSharp.Extensibility.Tasks.IndexUsagesTask">
      <summary>
            Tasks that references the uses of fields and methods by methods.
            </summary>
      <remarks>
            Note that this task only indexes references found in IL instructions, not
            in metadata tables.
            </remarks>
    </member>
    <member name="M:PostSharp.Extensibility.Tasks.IndexUsagesTask.Execute(PostSharp.Extensibility.Project)" />
    <member name="M:PostSharp.Extensibility.Tasks.IndexUsagesTask.Execute" />
    <member name="M:PostSharp.Extensibility.Tasks.IndexUsagesTask.GetUsedBy(PostSharp.CodeModel.MetadataDeclaration)">
      <summary>
            Gets the collection of methods that use a given declaration.
            </summary>
      <param name="declaration">A field, method or type.</param>
      <returns>The collection of methods that use <paramref name="declaration" />.</returns>
    </member>
    <member name="M:PostSharp.Extensibility.Tasks.IndexUsagesTask.GetUses(PostSharp.CodeModel.MethodDefDeclaration)">
      <summary>
            Gets the collection of declarations (fields, methods, types) that are used
            by a method.
            </summary>
      <param name="method">A method.</param>
      <returns>The collection of fields, methods and types used by <paramref name="method" />.</returns>
    </member>
    <member name="M:PostSharp.Extensibility.Tasks.IndexUsagesTask.MoveMethodBody(PostSharp.CodeModel.MethodDefDeclaration,PostSharp.CodeModel.MethodDefDeclaration)">
      <summary>
            Method to be called when the body of a method has been moved into another. This methods updates
            the indexes of uses-used by.
            </summary>
      <param name="sourceMethod">Method to which the body orgininally belonged.</param>
      <param name="targetMethod">Method to which the body now belongs.</param>
    </member>
    <member name="T:PostSharp.Extensibility.Tasks.MulticastAttributeTask">
      <summary>
            This task analyze instances of custom attributes derived from <see cref="T:PostSharp.Extensibility.MulticastAttribute" /> and propagate
            them on their target elements in the custom attribute dictionary (<see cref="T:PostSharp.Extensibility.Tasks.AnnotationRepositoryTask" />)
            of this module.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Tasks.MulticastAttributeTask.Execute" />
    <member name="T:PostSharp.Extensibility.Tasks.RemoveTask">
      <summary>
            Task that remove declarations from the module. 
            Typically called immediately before compilation.
            </summary>
      <remarks>
            Declaration removal should be two-phased: first declarations
            should be marked for removal using the <see cref="M:PostSharp.Extensibility.Tasks.RemoveTask.MarkForRemoval(PostSharp.CodeModel.IRemoveable)" />
            method, then they are removed, typically immediately before
            compilation, during task execution.
            </remarks>
    </member>
    <member name="M:PostSharp.Extensibility.Tasks.RemoveTask.GetTask(PostSharp.Extensibility.Project)">
      <summary>
            Finds the <see cref="T:PostSharp.Extensibility.Tasks.RemoveTask" /> task instance in a <see cref="T:PostSharp.Extensibility.Project" />.
            </summary>
      <param name="project">The project.</param>
      <returns>The <see cref="T:PostSharp.Extensibility.Tasks.RemoveTask" /> task instance.</returns>
      <exception cref="T:System.InvalidOperationException">The task <b>Remove</b> is not present in this project.</exception>
    </member>
    <member name="M:PostSharp.Extensibility.Tasks.RemoveTask.MarkForRemoval(PostSharp.CodeModel.IRemoveable)">
      <summary>
            Order a declaration to be removed later by this task.
            </summary>
      <param name="declaration">The declaration that should be removed.</param>
    </member>
    <member name="M:PostSharp.Extensibility.Tasks.RemoveTask.IsMarkedForRemoval(PostSharp.CodeModel.IRemoveable)">
      <summary>
            Determines whether a declaration has been marked for removal.
            </summary>
      <param name="declaration">A declaration.</param>
      <returns>
        <b>true</b> if <paramref name="declaration" /> has been marked for
            removal, otherwise <b>false</b>.</returns>
    </member>
    <member name="M:PostSharp.Extensibility.Tasks.RemoveTask.Execute" />
    <member name="T:PostSharp.Extensibility.Tasks.TypeHierarchyTask">
      <summary>
            Analysis that builds an inheritance tree of all types in the module.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Tasks.TypeHierarchyTask.GetTask(PostSharp.Extensibility.Project)">
      <summary>
            Finds the current task in a <see cref="T:PostSharp.Extensibility.Project" />.
            </summary>
      <param name="project">A <see cref="T:PostSharp.Extensibility.Project" />.</param>
      <returns>The <see cref="T:PostSharp.Extensibility.Tasks.IndexGenericInstancesTask" /> contained in the project,
            or <b>null</b> if this project does not contai the current task.</returns>
    </member>
    <member name="M:PostSharp.Extensibility.Tasks.TypeHierarchyTask.GetDerivedTypesEnumerator(PostSharp.CodeModel.TypeDefDeclaration,System.Boolean,PostSharp.CodeModel.ModuleDeclaration)">
      <summary>
            Gets an enumerator of derived types, given a <see cref="T:PostSharp.CodeModel.TypeDefDeclaration" />,
             with the possibility to include types
            defined outside the module.
            </summary>
      <param name="baseType">The base type.</param>
      <param name="deep">Whether derived types of second and higher level should be
            returned. If <b>false</b>, only direct descendant of <paramref name="baseType" />
            shall be returned.</param>
      <param name="module">If non-null, returns only types defined in this module.
            If null, returns all types.</param>
      <returns>An enumerator of types derived from <paramref name="baseType" />.</returns>
    </member>
    <member name="M:PostSharp.Extensibility.Tasks.TypeHierarchyTask.IndexTypeDefDeclarations">
      <summary>
            Inserts all type declarations (<see cref="T:PostSharp.CodeModel.TypeDefDeclaration" />) in the type hierarchy.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Tasks.TypeHierarchyTask.IndexAllTypeDefinitions">
      <summary>
            Indexes all <see cref="T:PostSharp.CodeModel.TypeDefDeclaration" /> in the current module.
            </summary>
    </member>
    <member name="M:PostSharp.Extensibility.Tasks.TypeHierarchyTask.IndexType(PostSharp.CodeModel.TypeDefDeclaration)">
      <summary>
            Inserts a given <see cref="T:PostSharp.CodeModel.TypeDefDeclaration" /> in the type hierarchy.
            </summary>
      <param name="type" />
    </member>
    <member name="T:PostSharp.Extensibility.Tasks.VerifyTask">
      <summary>
            Executes PEVERIFY on the compilation output.
            </summary>
      <remarks>
            This task is not very useful, because PEVERIFY needs dependencies to be in the
            same directory as the verified assemblies, which is typically not the case
            when PostSharp is executed. It is instead preferable to call PEVERIFY from
            the MSBuild task.
            </remarks>
    </member>
    <member name="M:PostSharp.Extensibility.Tasks.VerifyTask.Execute" />
    <member name="T:PostSharp.ModuleReader.BufferOverflowException">
      <summary>
            Exception thrown by the <see cref="T:PostSharp.ModuleReader.BufferReader" /> class
            when one tries to read more bytes than the buffer 
            actually has.
            </summary>
    </member>
    <member name="M:PostSharp.ModuleReader.BufferOverflowException.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.ModuleReader.BufferOverflowException" />
            with the default message.
            </summary>
    </member>
    <member name="M:PostSharp.ModuleReader.BufferOverflowException.#ctor(System.String)">
      <summary>
            Initializes a new <see cref="T:PostSharp.ModuleReader.BufferOverflowException" /> and
            specifies a message.
            </summary>
      <param name="message">Exception message.</param>
    </member>
    <member name="M:PostSharp.ModuleReader.BufferOverflowException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new <see cref="T:PostSharp.ModuleReader.BufferOverflowException" /> and specifies
            a message and an inner <see cref="T:System.Exception" />.
            </summary>
      <param name="message">Exception message.</param>
      <param name="inner">Inner exception.</param>
    </member>
    <member name="M:PostSharp.ModuleReader.BufferOverflowException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Deserialization constructor.
            </summary>
      <param name="info">Serialization information.</param>
      <param name="context">Streaming context.</param>
    </member>
    <member name="T:PostSharp.NullableBool">
      <summary>
            Three-state boolean: <see cref="F:PostSharp.NullableBool.True" />, <see cref="F:PostSharp.NullableBool.False" /> and <see cref="F:PostSharp.NullableBool.Null" />.
            </summary>
      <remarks>
            As in any three-state logic implementation, the <see cref="F:PostSharp.NullableBool.Null" /> element is absorbing for all operations.
            </remarks>
    </member>
    <member name="M:PostSharp.NullableBool.#ctor(System.Boolean)">
      <summary>
            Initializes a new <see cref="T:PostSharp.NullableBool" /> from a <see cref="T:System.Boolean" />.
            </summary>
      <param name="value">Initial value.</param>
    </member>
    <member name="F:PostSharp.NullableBool.True">
      <summary>
            True.
            </summary>
    </member>
    <member name="F:PostSharp.NullableBool.False">
      <summary>
            False.
            </summary>
    </member>
    <member name="F:PostSharp.NullableBool.Null">
      <summary>
            Null.
            </summary>
    </member>
    <member name="M:PostSharp.NullableBool.Equals(PostSharp.NullableBool)">
      <summary>
            Determines whether the current instance equals another.
            </summary>
      <param name="other">A <see cref="T:PostSharp.NullableBool" />.</param>
      <returns>
        <b>true</b> if both instances are equal or <b>false</b> if they are different or
            at least one is <see cref="F:PostSharp.NullableBool.Null" />.</returns>
    </member>
    <member name="M:PostSharp.NullableBool.Equals(System.Object)">
      <summary>
            Determines whether the current instance equals another.
            </summary>
      <param name="obj">A <see cref="T:PostSharp.NullableBool" />.</param>
      <returns>
        <b>true</b> if both instances are equal or <b>false</b> if they are different or
            at least one is <see cref="F:PostSharp.NullableBool.Null" />.</returns>
    </member>
    <member name="M:PostSharp.NullableBool.GetHashCode" />
    <member name="M:PostSharp.NullableBool.op_True(PostSharp.NullableBool)">
      <summary>
            Determines whether a <see cref="T:PostSharp.NullableBool" /> is <see cref="F:PostSharp.NullableBool.True" />.
            </summary>
      <param name="value">A <see cref="T:PostSharp.NullableBool" />.</param>
      <returns>
        <b>true</b> if <paramref name="value" /> is <see cref="F:PostSharp.NullableBool.True" />,
            false if it is <see cref="F:PostSharp.NullableBool.False" /> or <see cref="F:PostSharp.NullableBool.Null" />.</returns>
    </member>
    <member name="M:PostSharp.NullableBool.op_False(PostSharp.NullableBool)">
      <summary>
            Determines whether a <see cref="T:PostSharp.NullableBool" /> is <see cref="F:PostSharp.NullableBool.False" />.
            </summary>
      <param name="value">A <see cref="T:PostSharp.NullableBool" />.</param>
      <returns>
        <b>true</b> if <paramref name="value" /> is <see cref="F:PostSharp.NullableBool.False" />,
            false if it is <see cref="F:PostSharp.NullableBool.True" /> or <see cref="F:PostSharp.NullableBool.Null" />.</returns>
    </member>
    <member name="M:PostSharp.NullableBool.op_Implicit(System.Boolean)~PostSharp.NullableBool">
      <summary>
            Converts a <see cref="T:System.Boolean" /> into a <see cref="T:PostSharp.NullableBool" />.
            </summary>
      <param name="value">A <see cref="T:System.Boolean" />.</param>
      <returns>
        <see cref="F:PostSharp.NullableBool.True" /> or <see cref="F:PostSharp.NullableBool.False" />.</returns>
    </member>
    <member name="M:PostSharp.NullableBool.op_Implicit(PostSharp.NullableBool)~System.Boolean">
      <summary>
            Converts a <see cref="T:PostSharp.NullableBool" /> into a <see cref="T:System.Boolean" />.
            </summary>
      <param name="value">A <see cref="T:PostSharp.NullableBool" /></param>
      <returns>
        <b>true</b> if <paramref name="value" /> equals <see cref="F:PostSharp.NullableBool.True" />,
            otherwise <b>false</b>.</returns>
    </member>
    <member name="M:PostSharp.NullableBool.op_Equality(PostSharp.NullableBool,PostSharp.NullableBool)">
      <summary>
            Determines whether two instances of <see cref="T:PostSharp.NullableBool" /> are equal.
            </summary>
      <param name="left">A <see cref="T:PostSharp.NullableBool" />.</param>
      <param name="right">A <see cref="T:PostSharp.NullableBool" />.</param>
      <returns>
        <see cref="F:PostSharp.NullableBool.True" /> if both instances are equal, <see cref="F:PostSharp.NullableBool.False" /> if they are different or
            <see cref="F:PostSharp.NullableBool.Null" /> if any of them is <see cref="F:PostSharp.NullableBool.Null" />.</returns>
    </member>
    <member name="M:PostSharp.NullableBool.op_Inequality(PostSharp.NullableBool,PostSharp.NullableBool)">
      <summary>
            Determines whether two instances of <see cref="T:PostSharp.NullableBool" /> are different.
            </summary>
      <param name="left">A <see cref="T:PostSharp.NullableBool" />.</param>
      <param name="right">A <see cref="T:PostSharp.NullableBool" />.</param>
      <returns>
        <see cref="F:PostSharp.NullableBool.True" /> if instances are different, <see cref="F:PostSharp.NullableBool.False" /> if they are equal or
            <see cref="F:PostSharp.NullableBool.Null" /> if any of them is <see cref="F:PostSharp.NullableBool.Null" />.</returns>
    </member>
    <member name="M:PostSharp.NullableBool.op_BitwiseOr(PostSharp.NullableBool,PostSharp.NullableBool)">
      <summary>
            Determines whether any of two instances is <see cref="F:PostSharp.NullableBool.True" />.
            </summary>
      <param name="left">A <see cref="T:PostSharp.NullableBool" />.</param>
      <param name="right">A <see cref="T:PostSharp.NullableBool" />.</param>
      <returns>
        <see cref="F:PostSharp.NullableBool.True" /> if any instance is <see cref="F:PostSharp.NullableBool.True" />, <see cref="F:PostSharp.NullableBool.False" /> if both instances
            is <see cref="F:PostSharp.NullableBool.False" /> or <see cref="F:PostSharp.NullableBool.Null" /> if any instance is <see cref="F:PostSharp.NullableBool.Null" />.
            </returns>
    </member>
    <member name="M:PostSharp.NullableBool.op_BitwiseAnd(PostSharp.NullableBool,PostSharp.NullableBool)">
      <summary>
            Determines whether both instances are <see cref="F:PostSharp.NullableBool.True" />.
            </summary>
      <param name="left">A <see cref="T:PostSharp.NullableBool" />.</param>
      <param name="right">A <see cref="T:PostSharp.NullableBool" />.</param>
      <returns>
        <see cref="F:PostSharp.NullableBool.True" /> if both instances are <see cref="F:PostSharp.NullableBool.True" />, <see cref="F:PostSharp.NullableBool.False" /> if any instance
            is <see cref="F:PostSharp.NullableBool.False" /> or <see cref="F:PostSharp.NullableBool.Null" /> if any instance is <see cref="F:PostSharp.NullableBool.Null" />.
            </returns>
    </member>
    <member name="M:PostSharp.NullableBool.op_LogicalNot(PostSharp.NullableBool)">
      <summary>
            Inverses the value of a <see cref="T:PostSharp.NullableBool" />.
            </summary>
      <param name="value">A <see cref="T:PostSharp.NullableBool" />.</param>
      <returns>
        <see cref="F:PostSharp.NullableBool.True" /> if the instance is <see cref="F:PostSharp.NullableBool.False" />, <see cref="F:PostSharp.NullableBool.False" /> if it is <see cref="F:PostSharp.NullableBool.True" />
            or <see cref="F:PostSharp.NullableBool.Null" /> if it is <see cref="F:PostSharp.NullableBool.Null" />.</returns>
    </member>
    <member name="M:PostSharp.NullableBool.ToString" />
    <member name="P:PostSharp.NullableBool.IsNull">
      <summary>
            Determines whether the current instance is null.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.TypeSignatureCollection">
      <summary>
            Collection of types (<see cref="T:PostSharp.CodeModel.IType" />).
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.SerializedValue">
      <summary>
            Represents a serialized value and stores enough information to
            serialize it back using the exact representation.
            </summary>
      <remarks>
        <para>An instance of this class should be understood as a 'location' that
            can be assigned a value. The location has a type (<see cref="P:PostSharp.CodeModel.SerializedValue.Type" />
            property) and optionally a value (<see cref="P:PostSharp.CodeModel.SerializedValue.Value" /> property).</para>
      </remarks>
      <seealso cref="T:PostSharp.CodeModel.SerializationType" />
    </member>
    <member name="M:PostSharp.CodeModel.SerializedValue.#ctor(PostSharp.CodeModel.SerializationType,System.Object)">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.SerializedValue" />.
            </summary>
      <param name="type">Value type.</param>
      <param name="value">Value.</param>
    </member>
    <member name="M:PostSharp.CodeModel.SerializedValue.Set(PostSharp.CodeModel.SerializationType,System.Object)">
      <summary>
            Set a new value and its type.
            </summary>
      <param name="type">Value type.</param>
      <param name="value">Value.</param>
    </member>
    <member name="M:PostSharp.CodeModel.SerializedValue.GetRuntimeValue">
      <summary>
            Gets the value as required by the runtime.
            </summary>
      <returns>The value typed for use outside PostSharp.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.SerializedValue.EmitLoadValue(PostSharp.ModuleWriter.InstructionEmitter)">
      <summary>
            Emits instructions that load the current value on the stack.
            </summary>
      <param name="writer">Writer.</param>
    </member>
    <member name="M:PostSharp.CodeModel.SerializedValue.GetRuntimeType">
      <summary>
            Gets the runtime, deserialized type of the current <see cref="T:PostSharp.CodeModel.SerializedValue" />.
            </summary>
      <returns>Then runtime type that corresponds to the serialized type of the 
            current <see cref="T:PostSharp.CodeModel.SerializedValue" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.SerializedValue.ToString" />
    <member name="M:PostSharp.CodeModel.SerializedValue.Translate(PostSharp.CodeModel.ModuleDeclaration)">
      <summary>
            Translates the current value so that it is valid in another module.
            </summary>
      <param name="module">The module for which the <see cref="T:PostSharp.CodeModel.SerializedValue" /> should be expressed.</param>
      <returns>A <see cref="T:PostSharp.CodeModel.SerializedValue" /> equivalent to the current instance, but
            expressed for the other <paramref name="module" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.SerializedValue.GetValue(PostSharp.CodeModel.ITypeSignature,System.Object)">
      <summary>
            Gets an instance of <see cref="T:PostSharp.CodeModel.SerializedValue" />.
            </summary>
      <param name="typeSignature">Value type.</param>
      <param name="value">Value.</param>
      <returns>A <see cref="T:PostSharp.CodeModel.SerializedValue" /> encapsulating <paramref name="typeSignature" />
            and <paramref name="value" />.</returns>
    </member>
    <member name="P:PostSharp.CodeModel.SerializedValue.Type">
      <summary>
            Gets the type of the serialized value.
            </summary>
      <remarks>This property is read-only. Use the <see cref="M:PostSharp.CodeModel.SerializedValue.Set(PostSharp.CodeModel.SerializationType,System.Object)" /> method
            to change the type and/or method of this instance.</remarks>
    </member>
    <member name="P:PostSharp.CodeModel.SerializedValue.Value">
      <summary>
            Gets the value of the serialized value.
            </summary>
      <remarks>This property is read-only. Use the <see cref="M:PostSharp.CodeModel.SerializedValue.Set(PostSharp.CodeModel.SerializationType,System.Object)" /> method
            to change the type and/or method of this instance.</remarks>
    </member>
    <member name="T:PostSharp.CodeModel.DataSectionDeclaration">
      <summary>
            Represents a data section, where initial values of fieds are stored.
            </summary>
      <remarks>
        <para>
            Data declarations are owned by the module (<see cref="T:PostSharp.CodeModel.ModuleDeclaration" />)
            on the <see cref="P:PostSharp.CodeModel.ModuleDeclaration.Datas" /> property.
            </para>
        <para>
            Fields (<see cref="T:PostSharp.CodeModel.FieldDefDeclaration" />) with fixed binary layout may be initialized to a value stored
            in a <see cref="T:PostSharp.CodeModel.DataSectionDeclaration" /> by setting the <see cref="P:PostSharp.CodeModel.FieldDefDeclaration.InitialValue" />
            property.
            </para>
      </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.DataSectionDeclaration.#ctor(System.String,System.Byte[],System.Boolean)">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.DataSectionDeclaration" />.
            </summary>
      <param name="name">Data section name (label).</param>
      <param name="data">Raw data.</param>
      <param name="isManaged">
        <b>true</b> if the data section is managed,
            otherwise <b>false</b>.</param>
    </member>
    <member name="M:PostSharp.CodeModel.DataSectionDeclaration.WriteILDefinition(PostSharp.ModuleWriter.ILWriter)">
      <summary>
            Writes the IL definition of the current instance.
            </summary>
      <param name="writer">An <see cref="T:PostSharp.ModuleWriter.ILWriter" />.</param>
    </member>
    <member name="P:PostSharp.CodeModel.DataSectionDeclaration.Name">
      <summary>
            Gets or sets the name of the data section.
            </summary>
      <value>
            The name (value) of the data section.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.DataSectionDeclaration.Value">
      <summary>
            Gets or sets the raw data.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.DataSectionDeclaration.IsManaged">
      <summary>
            Determines whether the data section is managed.
            </summary>
      <value>
        <b>true</b> if the data section is managed, otherwise <b>false</b>.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.DataSectionDeclaration.Ordinal">
      <summary>
            Gets or set the emit order of the data section in the module.
            </summary>
      <value>
            The emit order of the current data section in the containing module.
            </value>
    </member>
    <member name="T:PostSharp.CodeModel.Collections.DataDeclarationCollection">
      <summary>
            Collection of data sections (<see cref="T:PostSharp.CodeModel.DataSectionDeclaration" />.
            </summary>
      <remarks>
            This collection is populated lazily when clients (e.g. fields) are loaded, but it is not
            possible to load all the elements without loading all its clients before. Therefore,
            it is unsafe to enumerate this collection when it belongs to a module that has
            been loaded lazily.
            </remarks>
    </member>
    <member name="T:PostSharp.CodeModel.AssemblyManifestDeclaration">
      <summary>
            Represents an assembly manifest (<see cref="F:PostSharp.CodeModel.TokenType.Assembly" />).
            </summary>
      <remarks>
            The assembly manifest
            is owned by the module (<see cref="T:PostSharp.CodeModel.ModuleDeclaration" />) and is exposed by the
            <see cref="P:PostSharp.CodeModel.ModuleDeclaration.AssemblyManifest" />
            property.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyManifestDeclaration.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.AssemblyManifestDeclaration" />.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyManifestDeclaration.GetTokenType">
      <summary>
            Gets the metadata token type of the current declaration.
            </summary>
      <returns>A <see cref="T:PostSharp.CodeModel.TokenType" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyManifestDeclaration.GetPublicKey">
      <summary>
            Gets the assemby public key.
            </summary>
      <value>
            An array of bytes containing the public key,
            or <b>null</b> if no public key is specified (for instance if
            only the public key token is given).
            </value>
      <returns>An array of bytes containing the public key,
            or <b>null</b> if no public key is specified.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyManifestDeclaration.SetPublicKey(System.Byte[])">
      <summary>
            Sets the public key.
            </summary>
      <param name="value" />
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyManifestDeclaration.GetPublicKeyToken">
      <summary>
            Gets the assembly public key token.
            </summary>
      <returns>An array of bytes containing the public key token,
            or <b>null</b> if no public key is specified.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyManifestDeclaration.WriteILDefinition(PostSharp.ModuleWriter.ILWriter)">
      <summary>
            Writes the IL definition of the current instance.
            </summary>
      <param name="writer">An <see cref="T:PostSharp.ModuleWriter.ILWriter" />.</param>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyManifestDeclaration.ToString" />
    <member name="P:PostSharp.CodeModel.AssemblyManifestDeclaration.Parent">
      <summary>
            Gets the parent <see cref="T:PostSharp.CodeModel.ModuleDeclaration" />.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.AssemblyManifestDeclaration.Culture">
      <summary>
            Gets the name of the assembly culture.
            </summary>
      <value>
            A standard culture name (see <see cref="T:System.Globalization.CultureInfo" />), or
            <b>null</b> to specify the neutral culture.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.AssemblyManifestDeclaration.HashAlgorithm">
      <summary>
            Gets or set the hash algorithm identifier.
            </summary>
      <value>
            The identifier of the algorithm (an <see cref="T:System.Configuration.Assemblies.AssemblyHashAlgorithm" />) used to produce the assembly signature.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.AssemblyManifestDeclaration.Version">
      <summary>
            Gets or set the assembly version.
            </summary>
      <value>
            A <see cref="T:System.Version" />.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.AssemblyManifestDeclaration.PermissionSets">
      <summary>
            Gets the collection of permission sets (<see cref="T:PostSharp.CodeModel.PermissionSetDeclaration" />).
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.AssemblyManifestDeclaration.FullName">
      <summary>
            Gets the assembly full name.
            </summary>
      <value>
            A value of the form: <c>{Name}, Version={Version}, Culture={Culture}|neutral, 
            PublicKey[Token]={PublicKey}</c>.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.AssemblyManifestDeclaration.OverwrittenFullName">
      <summary>
            Gets the full name based on the <see cref="P:PostSharp.CodeModel.AssemblyManifestDeclaration.OverwrittenName" /> instead
            of the normal <see cref="P:PostSharp.CodeModel.NamedDeclaration.Name" />.
            </summary>
      <value>
            A value of the form: <c>{Name}, Version={Version}, Culture={Culture}|neutral</c>
            (in any case without public key), or <b>null</b> if the <see cref="P:PostSharp.CodeModel.AssemblyManifestDeclaration.OverwrittenName" />
            property is <b>null</b>.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.AssemblyManifestDeclaration.Files">
      <summary>
            Gets the collection of manifestFiles (<see cref="T:PostSharp.CodeModel.ManifestFileDeclaration" />) linked to
            the assembly.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.AssemblyManifestDeclaration.Resources">
      <summary>
            Gets the collection of resources (<see cref="T:PostSharp.CodeModel.ManifestResourceDeclaration" />)
            referred to by the assembly.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.AssemblyManifestDeclaration.IsMscorlib">
      <summary>
            Determines whether the current assembly is <b>mscorlib</b>.
            </summary>
      <value>
        <b>true</b> if the current assembly is <b>mscorlib</b>, otherwise <b>false</b>.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.AssemblyManifestDeclaration.OverwrittenName">
      <summary>
            Name of the assembly as it will be <i>emitted</i> during compilation.
            </summary>
      <remarks>
        <para>Overwriting an assembly name allows to change the name of the <i>compiled</i>
            assembly without breaking references in the current domain (because changing
            the <see cref="P:PostSharp.CodeModel.NamedDeclaration.Name" /> would make it impossible to resolve assembly references).</para>
        <para>When the name is overwritten, the public key is automatically ignored
            during compilation.</para>
      </remarks>
      <value>A valid name, or <b>null</b> if the name is not overwritten.</value>
    </member>
    <member name="P:PostSharp.CodeModel.AssemblyManifestDeclaration.ExportedTypes">
      <summary>
            Gets the collection of types exported outside the current assembly but not defined
            inside the current module.
            </summary>
    </member>
    <member name="T:PostSharp.ModuleWriter.AddressDistance">
      <summary>
            Determines whether addresses can be coded on a single signed byte.
            </summary>
    </member>
    <member name="F:PostSharp.ModuleWriter.AddressDistance.Near">
      <summary>
            The address can be coded on a single signed byte.
            </summary>
    </member>
    <member name="F:PostSharp.ModuleWriter.AddressDistance.Far">
      <summary>
            The address has to be coded on a 32-bit signed integer.
            </summary>
    </member>
    <member name="F:PostSharp.ModuleWriter.AddressDistance.Undeterminate">
      <summary>
            It is not known whether the address is <see cref="F:PostSharp.ModuleWriter.AddressDistance.Near" /> or <see cref="F:PostSharp.ModuleWriter.AddressDistance.Far" />.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.ImageAttributes">
      <summary>
            Attributes of a .NET PE module.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.ImageAttributes.ILOnly">
      <summary>
            Always 1 (§23.1).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.ImageAttributes.Requires32Bits">
      <summary>
            Image may only be loaded into a 32-bit process, 
            for instance if there are 32-bit vtablefixups, 
            or casts from native integers to int32. CLI implementations that have 64-bit 
            native integers shall refuse loading binaries with the current flag set.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.ImageAttributes.StrongNameRequired">
      <summary>
            Image has a strong name signature.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.ImageAttributes.TrackDebugData">
      <summary>
             Always 0 (§23.1).
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.MetadataDeclarationTables">
      <summary>
            Exposes the metadata tables. 
            </summary>
      <remarks>
            These provide a by-token access to all 
            metadata declarations of the assembly. This class is accessible
            on the <see cref="P:PostSharp.CodeModel.ModuleDeclaration.Tables" /> property.
            </remarks>
      <devDoc>
            This class is typically used to resolve tokens found in binary IL.
            </devDoc>
    </member>
    <member name="F:PostSharp.CodeModel.MetadataDeclarationTables.TableCount">
      <summary>
            Number of metadata tables.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.MetadataDeclarationTables.GetDeclaration(PostSharp.CodeModel.MetadataToken)">
      <summary>
            Gets the <see cref="T:PostSharp.CodeModel.MetadataDeclaration" /> given its <see cref="T:PostSharp.CodeModel.MetadataToken" />.
            </summary>
      <param name="token">A <see cref="T:PostSharp.CodeModel.MetadataToken" />.</param>
      <returns>The <see cref="T:PostSharp.CodeModel.MetadataDeclaration" /> whose token is <paramref name="token" />,
            or <b>null</b> if <paramref name="token" /> is null.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.MetadataDeclarationTables.AddStronglyReferencedDeclaration(PostSharp.CodeModel.MetadataDeclaration)">
      <summary>
            Adds a <see cref="T:PostSharp.CodeModel.MetadataDeclaration" /> to the proper table.
            </summary>
      <param name="declaration">A <see cref="T:PostSharp.CodeModel.MetadataDeclaration" /> with null
            token.</param>
      <returns>The new <see cref="T:PostSharp.CodeModel.MetadataToken" /> of <paramref name="declaration" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.MetadataDeclarationTables.RemoveDeclaration(PostSharp.CodeModel.MetadataDeclaration)">
      <summary>
            Removes a <see cref="T:PostSharp.CodeModel.MetadataDeclaration" /> from its table.
            </summary>
      <param name="declaration">A <see cref="T:PostSharp.CodeModel.MetadataDeclaration" /> with 
            non null token.</param>
    </member>
    <member name="M:PostSharp.CodeModel.MetadataDeclarationTables.GetType(PostSharp.CodeModel.MetadataToken)">
      <summary>
            Gets the <see cref="T:PostSharp.CodeModel.IType" /> corresponding to a given <see cref="T:PostSharp.CodeModel.MetadataToken" />.
            </summary>
      <param name="token">A <see cref="T:PostSharp.CodeModel.MetadataToken" />.</param>
      <returns>An <see cref="T:PostSharp.CodeModel.IType" />, or <b>null</b> if the current token was not 
            found in the tables.</returns>
      <exception cref="T:System.ArgumentException">The token type is invalid.</exception>
    </member>
    <member name="M:PostSharp.CodeModel.MetadataDeclarationTables.GetField(PostSharp.CodeModel.MetadataToken)">
      <summary>
            Gets the <see cref="T:PostSharp.CodeModel.IField" /> corresponding to a given <see cref="T:PostSharp.CodeModel.MetadataToken" />.
            </summary>
      <param name="token">A <see cref="T:PostSharp.CodeModel.MetadataToken" />.</param>
      <returns>An <see cref="T:PostSharp.CodeModel.IField" />, or <b>null</b> if the current token was not 
            found in the tables.</returns>
      <exception cref="T:System.ArgumentException">The token type is invalid.</exception>
    </member>
    <member name="M:PostSharp.CodeModel.MetadataDeclarationTables.GetMethod(PostSharp.CodeModel.MetadataToken)">
      <summary>
            Gets the <see cref="T:PostSharp.CodeModel.IMethod" /> corresponding to a given <see cref="T:PostSharp.CodeModel.MetadataToken" />.
            </summary>
      <param name="token">A <see cref="T:PostSharp.CodeModel.MetadataToken" />.</param>
      <returns>An <see cref="T:PostSharp.CodeModel.IMethod" />, or <b>null</b> if the current token was not 
            found in the tables.</returns>
      <exception cref="T:System.ArgumentException">The token type is invalid.</exception>
    </member>
    <member name="M:PostSharp.CodeModel.MetadataDeclarationTables.GetMemberRef(PostSharp.CodeModel.MetadataToken)">
      <summary>
            Gets the <see cref="T:PostSharp.CodeModel.MemberRefDeclaration" /> corresponding to a given <see cref="T:PostSharp.CodeModel.MetadataToken" />.
            </summary>
      <param name="token">A <see cref="T:PostSharp.CodeModel.MetadataToken" />.</param>
      <returns>An <see cref="T:PostSharp.CodeModel.MemberRefDeclaration" />, or <b>null</b> if the current token was not 
            found in the tables.</returns>
      <exception cref="T:System.ArgumentException">The token type is invalid.</exception>
    </member>
    <member name="M:PostSharp.CodeModel.MetadataDeclarationTables.GetUserString(PostSharp.CodeModel.MetadataToken)">
      <summary>
            Gets the <see cref="T:PostSharp.CodeModel.LiteralString" /> corresponding to a given <see cref="T:PostSharp.CodeModel.MetadataToken" />.
            </summary>
      <param name="token">A <see cref="T:PostSharp.CodeModel.MetadataToken" />.</param>
      <returns>An <see cref="T:PostSharp.CodeModel.LiteralString" />, or a null <see cref="T:PostSharp.CodeModel.LiteralString" /> if the current token was not 
            found in the tables.</returns>
      <exception cref="T:System.ArgumentException">The token type is invalid.</exception>
    </member>
    <member name="M:PostSharp.CodeModel.MetadataDeclarationTables.GetStandaloneSignature(PostSharp.CodeModel.MetadataToken)">
      <summary>
            Gets the <see cref="T:PostSharp.CodeModel.StandaloneSignatureDeclaration" /> corresponding to a given <see cref="T:PostSharp.CodeModel.MetadataToken" />.
            </summary>
      <param name="token">A <see cref="T:PostSharp.CodeModel.MetadataToken" />.</param>
      <returns>An <see cref="T:PostSharp.CodeModel.StandaloneSignatureDeclaration" />, or <b>null</b> if the current token was not 
            found in the tables.</returns>
      <exception cref="T:System.ArgumentException">The token type is invalid.</exception>
    </member>
    <member name="M:PostSharp.CodeModel.MetadataDeclarationTables.RvaToPointer(System.UInt32)">
      <summary>
            Gets the physical address corresponding to a given RVA.
            </summary>
      <param name="rva">A RVA (offset relative to the first byte of the PE image).</param>
      <returns>A pointer to the location corresponding to <paramref name="rva" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.MetadataDeclarationTables.GetEnumerator(PostSharp.CodeModel.TokenType)">
      <summary>
            Gets an enumerator of all declarations of a
            given <see cref="T:PostSharp.CodeModel.TokenType" />.
            </summary>
      <param name="tokenType">A <see cref="T:PostSharp.CodeModel.TokenType" />.</param>
      <returns>An enumerator.</returns>
    </member>
    <member name="T:PostSharp.CodeModel.MetadataToken">
      <summary>
            Encapsulates a metadata token, which unambigously identifies a <see cref="T:PostSharp.CodeModel.MetadataDeclaration" /> 
            inside a <see cref="T:PostSharp.CodeModel.ModuleDeclaration" />.
            </summary>
      <devDoc>
            These tokens are composed of two parts: the first 8 bits contain the
            <see cref="P:PostSharp.CodeModel.MetadataToken.TokenType" /> and the lower 24 bits contain the 1-based index
            of the declaration in the table corresponding to the token type. A value of 0
            in the lower 24 bits mean that the token is null.
            </devDoc>
    </member>
    <member name="F:PostSharp.CodeModel.MetadataToken.Null">
      <summary>
            Null <see cref="T:PostSharp.CodeModel.MetadataToken" />.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.MetadataToken.Equals(PostSharp.CodeModel.MetadataToken)" />
    <member name="M:PostSharp.CodeModel.MetadataToken.Equals(System.Object)" />
    <member name="M:PostSharp.CodeModel.MetadataToken.GetHashCode" />
    <member name="M:PostSharp.CodeModel.MetadataToken.CompareTo(PostSharp.CodeModel.MetadataToken)" />
    <member name="M:PostSharp.CodeModel.MetadataToken.op_Equality(PostSharp.CodeModel.MetadataToken,PostSharp.CodeModel.MetadataToken)">
      <summary>
            Determines whether two metadata tokens are equal.
            </summary>
      <param name="left">A <see cref="T:PostSharp.CodeModel.MetadataToken" />.</param>
      <param name="right">A <see cref="T:PostSharp.CodeModel.MetadataToken" />.</param>
      <returns>
        <b>true</b> if both tokens are equal, otherwise <b>false</b>.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.MetadataToken.op_Inequality(PostSharp.CodeModel.MetadataToken,PostSharp.CodeModel.MetadataToken)">
      <summary>
            Determines whether two metadata tokens are different.
            </summary>
      <param name="left">A <see cref="T:PostSharp.CodeModel.MetadataToken" />.</param>
      <param name="right">A <see cref="T:PostSharp.CodeModel.MetadataToken" />.</param>
      <returns>
        <b>true</b> if tokens are different, otherwise <b>false</b>.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.MetadataToken.ToString" />
    <member name="P:PostSharp.CodeModel.MetadataToken.IsNull">
      <summary>
            Determines whether the current token is null.
            </summary>
      <value>
        <b>true</b> if the current token is null, otherwise <b>false</b>.
            </value>
    </member>
    <member name="T:PostSharp.CodeModel.InstructionReader">
      <summary>
            Reads a stream of binary IL instructions and debugging sequence points.
            </summary>
      <remarks>
        <para>
            	Each <see cref="T:PostSharp.CodeModel.InstructionReader" /> instance is assigned to
            	a single method. Developers must use the 
            	<see cref="M:PostSharp.CodeModel.MethodBodyDeclaration.CreateInstructionReader" /> method
            	to get an <see cref="T:PostSharp.CodeModel.InstructionReader" /> instance.
            </para>
        <para>
            	When you want to read an instruction block, you first need to <i>enter</i>
            	it using the <see cref="M:PostSharp.CodeModel.InstructionReader.EnterInstructionBlock(PostSharp.CodeModel.InstructionBlock)" /> method. The
            	<see cref="M:PostSharp.CodeModel.InstructionReader.EnterInstructionBlock(PostSharp.CodeModel.InstructionBlock)" /> method expect that the active
            	block of the <see cref="T:PostSharp.CodeModel.InstructionReader" /> is the parent of the block
            	you want to enter, so you have to enter all ascendant blocks, from
            	the root to the leave, like in a stack model. Then you attach the reader
            	to a sequence using <see cref="M:PostSharp.CodeModel.InstructionReader.EnterInstructionSequence(PostSharp.CodeModel.InstructionSequence)" />.
            	To read another sequence, you need first to use 
            	<see cref="M:PostSharp.CodeModel.InstructionReader.LeaveInstructionSequence" />, then
            	again <see cref="M:PostSharp.CodeModel.InstructionReader.EnterInstructionSequence(PostSharp.CodeModel.InstructionSequence)" />. Use
            	<see cref="M:PostSharp.CodeModel.InstructionReader.LeaveInstructionBlock" /> to leave a block.
            </para>
        <para>
            	If you want to enter a specific block without entering all its ancestors,
            	use the <see cref="M:PostSharp.CodeModel.InstructionReader.JumpToInstructionBlock(PostSharp.CodeModel.InstructionBlock)" /> method, which will
            	make the proper calls to <see cref="M:PostSharp.CodeModel.InstructionReader.LeaveInstructionBlock" />
            	and <see cref="M:PostSharp.CodeModel.InstructionReader.EnterInstructionBlock(PostSharp.CodeModel.InstructionBlock)" /> automatically.
            </para>
        <para>
            	When the <see cref="T:PostSharp.CodeModel.InstructionReader" /> has entered an
            	<see cref="T:PostSharp.CodeModel.InstructionSequence" />, you can use it as a classic reader.
            	The <see cref="M:PostSharp.CodeModel.InstructionReader.ReadInstruction" /> reads the next
            	instruction and you can read it on the instance properties of
            	the <see cref="T:PostSharp.CodeModel.InstructionReader" />.
            </para>
      </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.InstructionReader.GetLocalVariableSymbol(System.Int32,System.Boolean)">
      <summary>
            Gets the <see cref="T:PostSharp.CodeModel.LocalVariableSymbol" /> of a local variable given its ordinal
            and optionally creates default symbol is no symbol is associated to the given
            ordinal in the current context.
            </summary>
      <param name="ordinal">The ordinal.</param>
      <param name="createDefault">Determines whether a default 
            <see cref="T:PostSharp.CodeModel.LocalVariableSymbol" /> should be created is none is associated to
            the given ordinal in the current context.</param>
      <returns>The <see cref="T:PostSharp.CodeModel.LocalVariableSymbol" /> of the local variable at
            position <paramref name="ordinal" />, or <b>null</b> if no symbol is associated to
            the given ordinal in the current context and the <paramref name="createDefault" />
            parameter is false.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.InstructionReader.GetLocalVariableSymbol(System.Int32)">
      <summary>
            Gets the <see cref="T:PostSharp.CodeModel.LocalVariableSymbol" /> associated to a given ordinal
            in the current context.
            </summary>
      <param name="ordinal">The ordinal.</param>
      <returns />
    </member>
    <member name="M:PostSharp.CodeModel.InstructionReader.JumpToInstructionBlock(PostSharp.CodeModel.InstructionBlock)">
      <summary>
            Prepares the current <see cref="T:PostSharp.CodeModel.InstructionReader" /> so that it
            can read a specific block, without assumption on
            the current state of the <see cref="T:PostSharp.CodeModel.InstructionReader" />.
            </summary>
      <param name="block">The target <see cref="T:PostSharp.CodeModel.InstructionBlock" />.</param>
      <exception cref="T:System.ArgumentException">The target instruction block
            do not belong to the method body to which the current <see cref="T:PostSharp.CodeModel.InstructionReader" />
            is attached.</exception>
      <remarks>
            For better performances, use <see cref="M:PostSharp.CodeModel.InstructionReader.EnterInstructionBlock(PostSharp.CodeModel.InstructionBlock)" /> and 
            <see cref="M:PostSharp.CodeModel.InstructionReader.LeaveInstructionBlock" />.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.InstructionReader.EnterInstructionBlock(PostSharp.CodeModel.InstructionBlock)">
      <summary>
            Enters an <see cref="T:PostSharp.CodeModel.InstructionBlock" />.
            </summary>
      <remarks>
            Prepares the current <see cref="T:PostSharp.CodeModel.InstructionReader" /> so that it
            can read a specific <see cref="T:PostSharp.CodeModel.InstructionBlock" />, with the assumption that
            the <see cref="T:PostSharp.CodeModel.InstructionReader" /> is in the parent of the block
            to open.
            </remarks>
      <param name="block">The <see cref="T:PostSharp.CodeModel.InstructionBlock" /> to open.</param>
      <exception cref="T:System.InvalidOperationException">
            	The current <see cref="T:PostSharp.CodeModel.InstructionReader" /> is currently at
            	an invalid position. It should be open on the parent 
            	of <paramref name="block" />.
            </exception>
    </member>
    <member name="M:PostSharp.CodeModel.InstructionReader.LeaveInstructionBlock">
      <summary>
            Leaves the active <see cref="T:PostSharp.CodeModel.InstructionBlock" />, and sets the position
            of the current <see cref="T:PostSharp.CodeModel.InstructionReader" /> to
            the parent block of the active block.
            </summary>
      <exception cref="T:System.InvalidOperationException">
            The current <see cref="T:PostSharp.CodeModel.InstructionReader" /> is not positioned in
            an <see cref="T:PostSharp.CodeModel.InstructionBlock" />.
            </exception>
    </member>
    <member name="M:PostSharp.CodeModel.InstructionReader.EnterInstructionSequence(PostSharp.CodeModel.InstructionSequence)">
      <summary>
            Enters an <see cref="T:PostSharp.CodeModel.InstructionSequence" />.
            </summary>
      <remarks>
            Prepares the current <see cref="T:PostSharp.CodeModel.InstructionReader" /> so that it
            can read a specific <see cref="T:PostSharp.CodeModel.InstructionSequence" />, with the assumption that
            the <see cref="T:PostSharp.CodeModel.InstructionReader" /> is in the parent of the sequence
            to open.
            </remarks>
      <param name="sequence">The <see cref="T:PostSharp.CodeModel.InstructionSequence" /> to open.</param>
      <exception cref="T:System.InvalidOperationException">
            	The current <see cref="T:PostSharp.CodeModel.InstructionReader" /> is currently at
            	an invalid position. It should be open on the parent block
            	of <paramref name="sequence" />.
            </exception>
    </member>
    <member name="M:PostSharp.CodeModel.InstructionReader.LeaveInstructionSequence">
      <summary>
            Leaves the active <see cref="T:PostSharp.CodeModel.InstructionSequence" />, and sets the position
            of the current <see cref="T:PostSharp.CodeModel.InstructionReader" /> to
            the parent block of the active sequence.
            </summary>
      <exception cref="T:System.InvalidOperationException">
            The current <see cref="T:PostSharp.CodeModel.InstructionReader" /> is not positioned in
            an <see cref="T:PostSharp.CodeModel.InstructionSequence" />.
            </exception>
    </member>
    <member name="M:PostSharp.CodeModel.InstructionReader.ReadInstruction">
      <summary>
            Reads the next instruction of the active <see cref="T:PostSharp.CodeModel.InstructionSequence" />.
            </summary>
      <returns>
        <b>true</b> if some instruction could be read,
            or <b>false</b> if the end of the instruction sequence was reached.</returns>
      <exception cref="T:System.InvalidOperationException">
            The current <see cref="T:PostSharp.CodeModel.InstructionReader" /> is not positioned in
            an <see cref="T:PostSharp.CodeModel.InstructionSequence" />.
            </exception>
    </member>
    <member name="M:PostSharp.CodeModel.InstructionReader.CreateBookmark">
      <summary>
            Creates a bookmark, thanks to which the current <see cref="T:PostSharp.CodeModel.InstructionReader" />
            can move forward and then return to the current location.
            </summary>
      <returns>A bookmark for the current location.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.InstructionReader.GoToBookmark(PostSharp.CodeModel.InstructionReaderBookmark)">
      <summary>
            Moves the current <see cref="T:PostSharp.CodeModel.InstructionReader" /> to a given bookmark.
            </summary>
      <param name="bookmark">A bookmark that was created for the current <see cref="T:PostSharp.CodeModel.InstructionReader" />
            and for the <see cref="T:PostSharp.CodeModel.InstructionSequence" /> into which the bookmark was created.</param>
    </member>
    <member name="M:PostSharp.CodeModel.InstructionReader.Dispose" />
    <member name="P:PostSharp.CodeModel.InstructionReader.CurrentInstruction">
      <summary>
            Gets the current instruction.
            </summary>
      <remarks>
            You always get the same instance of the <see cref="T:PostSharp.CodeModel.Instruction" /> class, so it is useless
            to "store" it somewhere for later use. Once the cursor has moved, the returned instance
            will be modified.
            </remarks>
    </member>
    <member name="P:PostSharp.CodeModel.InstructionReader.CurrentInstructionSequence">
      <summary>
            Gets the <see cref="T:PostSharp.CodeModel.InstructionSequence" /> on which the current <see cref="T:PostSharp.CodeModel.InstructionReader" />
            is positioned.
            </summary>
      <value>
            An <see cref="T:PostSharp.CodeModel.InstructionSequence" />, or <b>null</b> if the current <see cref="T:PostSharp.CodeModel.InstructionReader" />
            is not positioned at an <see cref="T:PostSharp.CodeModel.InstructionSequence" />.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.InstructionReader.CurrentInstructionBlock">
      <summary>
            Gets the <see cref="T:PostSharp.CodeModel.InstructionBlock" /> on which the current <see cref="T:PostSharp.CodeModel.InstructionReader" />
            is positioned.
            </summary>
      <value>
            An <see cref="T:PostSharp.CodeModel.InstructionBlock" />, or <b>null</b> if the current <see cref="T:PostSharp.CodeModel.InstructionReader" />
            is not positioned at an <see cref="T:PostSharp.CodeModel.InstructionBlock" />.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.InstructionReader.MethodBody">
      <summary>
            Gets the <see cref="T:PostSharp.CodeModel.MethodBodyDeclaration" /> to which the current 
            <see cref="T:PostSharp.CodeModel.InstructionReader" /> is assigned.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.InstructionReader.Module">
      <summary>
            Gets the module to which this <see cref="T:PostSharp.CodeModel.InstructionReader" /> is associates.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.InstructionReader.IsAtEnfOfSequence">
      <summary>
            Determines whether the current instruction is the last of the sequence.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.InstructionReader.IsSymbolResolutionEnabled">
      <summary>
            Determines wether resolution of local variable symbols is enabled for the current reader.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.OpCodeMap">
      <summary>
            Maps <see cref="T:PostSharp.CodeModel.OpCodeNumber" /> to <see cref="T:System.Reflection.Emit.OpCode" /> and provides
            the various properties of opcodes.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.OpCodeMap.AssertValidInstruction(PostSharp.CodeModel.OpCodeNumber)">
      <summary>
            Throws an <see cref="T:System.ArgumentException" /> if an instruction code is incorrect.
            </summary>
      <param name="opCode">An opcode.</param>
    </member>
    <member name="M:PostSharp.CodeModel.OpCodeMap.GetOpCode(PostSharp.CodeModel.OpCodeNumber)">
      <summary>
            Gets the <see cref="T:System.Reflection.Emit.OpCode" /> corresponding to an <see cref="T:PostSharp.CodeModel.OpCodeNumber" />.
            </summary>
      <param name="opCodeNumber">An <see cref="T:PostSharp.CodeModel.OpCodeNumber" />.</param>
      <returns>The <see cref="T:System.Reflection.Emit.OpCode" /> corresponding to <paramref name="opCodeNumber" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.OpCodeMap.GetFlowControl(PostSharp.CodeModel.OpCodeNumber)">
      <summary>
            Gets the <see cref="T:System.Reflection.Emit.FlowControl" /> of a given opcode.
            </summary>
      <param name="opCodeNumber">An <see cref="T:PostSharp.CodeModel.OpCodeNumber" />.</param>
      <returns>The <see cref="T:System.Reflection.Emit.FlowControl" /> corresponding to <paramref name="opCodeNumber" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.OpCodeMap.GetName(PostSharp.CodeModel.OpCodeNumber)">
      <summary>
            Gets the name of a given opcode.
            </summary>
      <param name="opCodeNumber">An <see cref="T:PostSharp.CodeModel.OpCodeNumber" />.</param>
      <returns>The name of the opcode corresponding to <paramref name="opCodeNumber" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.OpCodeMap.GetOpCodeType(PostSharp.CodeModel.OpCodeNumber)">
      <summary>
            Gets the <see cref="T:System.Reflection.Emit.OpCodeType" /> of a given opcode.
            </summary>
      <param name="opCodeNumber">An <see cref="T:PostSharp.CodeModel.OpCodeNumber" />.</param>
      <returns>The <see cref="T:System.Reflection.Emit.OpCodeType" /> corresponding to <paramref name="opCodeNumber" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.OpCodeMap.GetOperandType(PostSharp.CodeModel.OpCodeNumber)">
      <summary>
            Gets the <see cref="T:System.Reflection.Emit.OperandType" /> of a given opcode.
            </summary>
      <param name="opCodeNumber">An <see cref="T:PostSharp.CodeModel.OpCodeNumber" />.</param>
      <returns>The <see cref="T:System.Reflection.Emit.OpCodeType" /> corresponding to <paramref name="opCodeNumber" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.OpCodeMap.GetSize(PostSharp.CodeModel.OpCodeNumber)">
      <summary>
            Gets the size of a given opcode.
            </summary>
      <param name="opCodeNumber">An <see cref="T:PostSharp.CodeModel.OpCodeNumber" />.</param>
      <returns>The size of the opcode corresponding to <paramref name="opCodeNumber" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.OpCodeMap.GetStackBehaviourPop(PostSharp.CodeModel.OpCodeNumber)">
      <summary>
            Gets the <i>pop</i><see cref="T:System.Reflection.Emit.StackBehaviour" /> of a given opcode.
            </summary>
      <param name="opCodeNumber">An <see cref="T:PostSharp.CodeModel.OpCodeNumber" />.</param>
      <returns>The <i>pop</i><see cref="T:System.Reflection.Emit.StackBehaviour" /> corresponding to <paramref name="opCodeNumber" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.OpCodeMap.GetStackBehaviourPush(PostSharp.CodeModel.OpCodeNumber)">
      <summary>
            Gets the <i>push</i><see cref="T:System.Reflection.Emit.StackBehaviour" /> of a given opcode.
            </summary>
      <param name="opCodeNumber">An <see cref="T:PostSharp.CodeModel.OpCodeNumber" />.</param>
      <returns>The <i>push</i><see cref="T:System.Reflection.Emit.StackBehaviour" /> corresponding to <paramref name="opCodeNumber" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.OpCodeMap.IsCompressedOpCode(PostSharp.CodeModel.OpCodeNumber)">
      <summary>
            Determines whether a given opcode is compressed.
            </summary>
      <param name="opCode">An <see cref="T:PostSharp.CodeModel.OpCodeNumber" />.</param>
      <returns>
        <b>true</b> if <paramref name="opCode" /> is in compressed form,
            otherwise <b>false</b>.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.OpCodeMap.GetUncompressedOpCode(PostSharp.CodeModel.OpCodeNumber)">
      <summary>
            Gets the uncompressed opcode corresponding to a compressed opcode.
            </summary>
      <param name="compressedOpCode">The <see cref="T:PostSharp.CodeModel.OpCodeNumber" /> of a compressed
            opcode.</param>
      <returns>An <see cref="T:PostSharp.CodeModel.UncompressedOpCode" />, or a null <see cref="T:PostSharp.CodeModel.UncompressedOpCode" />
            if <paramref name="compressedOpCode" /> is not compressed.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.OpCodeMap.IsParameterOperand(PostSharp.CodeModel.OpCodeNumber)">
      <summary>
            Determines whether an opcode takes a parameter operand.
            </summary>
      <param name="opCode">An <see cref="T:PostSharp.CodeModel.OpCodeNumber" />.</param>
      <returns>
        <b>true</b> if <paramref name="opCode" /> takes a parameter
            operand, <b>false</b> otherwise.</returns>
    </member>
    <member name="T:PostSharp.CodeModel.UncompressedOpCode">
      <summary>
            Uncompressed opcode (i.e. an opcode with its operand).
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.UncompressedOpCode.Equals(PostSharp.CodeModel.UncompressedOpCode)" />
    <member name="M:PostSharp.CodeModel.UncompressedOpCode.GetHashCode" />
    <member name="M:PostSharp.CodeModel.UncompressedOpCode.Equals(System.Object)" />
    <member name="M:PostSharp.CodeModel.UncompressedOpCode.op_Equality(PostSharp.CodeModel.UncompressedOpCode,PostSharp.CodeModel.UncompressedOpCode)">
      <summary>
            Determines whether two <see cref="T:PostSharp.CodeModel.UncompressedOpCode" /> are equal.
            </summary>
      <param name="left">An <see cref="T:PostSharp.CodeModel.UncompressedOpCode" />.</param>
      <param name="right">Another <see cref="T:PostSharp.CodeModel.UncompressedOpCode" />.</param>
      <returns>
        <b>true</b> if both <see cref="T:PostSharp.CodeModel.UncompressedOpCode" /> are
            equal, otherwise <b>false</b>.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.UncompressedOpCode.op_Inequality(PostSharp.CodeModel.UncompressedOpCode,PostSharp.CodeModel.UncompressedOpCode)">
      <summary>
            Determines whether two <see cref="T:PostSharp.CodeModel.UncompressedOpCode" /> are different.
            </summary>
      <param name="left">An <see cref="T:PostSharp.CodeModel.UncompressedOpCode" />.</param>
      <param name="right">Another <see cref="T:PostSharp.CodeModel.UncompressedOpCode" />.</param>
      <returns>
        <b>true</b> if both <see cref="T:PostSharp.CodeModel.UncompressedOpCode" /> are
            different, otherwise <b>false</b>.</returns>
    </member>
    <member name="P:PostSharp.CodeModel.UncompressedOpCode.OpCodeNumber">
      <summary>
            Gets the uncompressed <see cref="P:PostSharp.CodeModel.UncompressedOpCode.OpCodeNumber" />.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.UncompressedOpCode.OperandType">
      <summary>
            Gets the <see cref="P:PostSharp.CodeModel.UncompressedOpCode.OperandType" /> of <see cref="P:PostSharp.CodeModel.UncompressedOpCode.OpCodeNumber" />.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.UncompressedOpCode.Operand">
      <summary>
            Gets the uncompressed operand.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.UncompressedOpCode.IsNull">
      <summary>
            Determines whether the current <see cref="T:PostSharp.CodeModel.UncompressedOpCode" /> is null.
            </summary>
      <remarks>
            A null <see cref="T:PostSharp.CodeModel.UncompressedOpCode" /> means that the original opcode
            was not compressed.
            </remarks>
    </member>
    <member name="T:PostSharp.CodeModel.LocalVariableSymbol">
      <summary>
            Assigns a name to a local variable <see cref="T:PostSharp.CodeModel.LocalVariableDeclaration" />.
            Local variable symbols belong to an <see cref="T:PostSharp.CodeModel.InstructionBlock" />, which
            is in the current case the lexical scope of the variable.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.LocalVariableSymbol.CompareTo(PostSharp.CodeModel.LocalVariableSymbol)" />
    <member name="M:PostSharp.CodeModel.LocalVariableSymbol.Equals(PostSharp.CodeModel.LocalVariableSymbol)" />
    <member name="P:PostSharp.CodeModel.LocalVariableSymbol.LocalVariable">
      <summary>
            Gets or sets the named <see cref="T:PostSharp.CodeModel.LocalVariableDeclaration" />.
            </summary>
      <value>
            A <see cref="T:PostSharp.CodeModel.LocalVariableDeclaration" />.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.LocalVariableSymbol.Name">
      <summary>
            Gets or sets the local variable name.
            </summary>
      <value>
            The local variable name, or <b>null</b> if the local
            variable is not named in the current scope.
            </value>
    </member>
    <member name="T:PostSharp.CodeModel.Collections.LocalVariableSymbolCollection">
      <summary>
            Collection of local variable symbols (<see cref="T:PostSharp.CodeModel.LocalVariableSymbol" />).
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.LocalVariableSymbolCollection.ToArray">
      <summary>
            Copies the current collection into a new array.
            </summary>
      <returns>A new array containing the elements of the current collection.</returns>
    </member>
    <member name="T:PostSharp.CodeModel.ManifestFileDeclaration">
      <summary>
            Represents a file reference (<see cref="F:PostSharp.CodeModel.TokenType.File" />). 
            </summary>
      <remarks>
            File references are owned
            by the <see cref="T:PostSharp.CodeModel.AssemblyManifestDeclaration" />.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.ManifestFileDeclaration.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.ManifestFileDeclaration" />.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.ManifestFileDeclaration.GetTokenType" />
    <member name="M:PostSharp.CodeModel.ManifestFileDeclaration.WriteILDefinition(PostSharp.ModuleWriter.ILWriter)">
      <summary>
            Writes the IL definition of the current instance.
            </summary>
      <param name="writer">An <see cref="T:PostSharp.ModuleWriter.ILWriter" />.</param>
    </member>
    <member name="P:PostSharp.CodeModel.ManifestFileDeclaration.HasMetadata">
      <summary>
            Determines whether the referenced file has CLI metadata.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.ManifestFileDeclaration.Hash">
      <summary>
            Gets or sets the file hash value.
            </summary>
      <value>
            An array of bytes containing the file hash, or <b>null</b> if the hash value
            was not computed.
            </value>
    </member>
    <member name="T:PostSharp.CodeModel.Collections.ManifestFileDeclarationCollection">
      <summary>
            Collection of assembly manifestFiles (<see cref="T:PostSharp.CodeModel.ManifestFileDeclaration" />).
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.ManifestResourceDeclaration">
      <summary>
            Represents a resource referenced by the assembly (<see cref="F:PostSharp.CodeModel.TokenType.ManifestResource" />).
            </summary>
      <remarks>
            Resources
            are owned by a <see cref="T:PostSharp.CodeModel.AssemblyManifestDeclaration" />
            but can be stored physically ("implemented") in the current assemly,
            an external assembly (<see cref="T:PostSharp.CodeModel.AssemblyRefDeclaration" />) or
            a file (<see cref="T:PostSharp.CodeModel.ManifestFileDeclaration" />).
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.ManifestResourceDeclaration.GetTokenType" />
    <member name="M:PostSharp.CodeModel.ManifestResourceDeclaration.WriteILDefinition(PostSharp.ModuleWriter.ILWriter)">
      <summary>
            Writes the IL definition of the current instance.
            </summary>
      <param name="writer">An <see cref="T:PostSharp.ModuleWriter.ILWriter" />.</param>
    </member>
    <member name="P:PostSharp.CodeModel.ManifestResourceDeclaration.FileOffset">
      <summary>
            Gets the offset of the resource in the external file.
            </summary>
      <value>
            A positive integer equal to the offset of the resource in case
            <see cref="P:PostSharp.CodeModel.ManifestResourceDeclaration.Implementation" /> is a <see cref="T:PostSharp.CodeModel.ManifestFileDeclaration" />,
            otherwise 0.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.ManifestResourceDeclaration.IsPublic">
      <summary>
            Determines whether the resource is public.
            </summary>
      <value>
        <b>true</b> if the resource is public, otherwise <b>false</b>.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.ManifestResourceDeclaration.Implementation">
      <summary>
            Gets or sets the resource implementation, i.e. its physical location.
            </summary>
      <value>
            An <see cref="T:PostSharp.CodeModel.IManifestResourceImplementation" /> (<see cref="T:PostSharp.CodeModel.AssemblyRefDeclaration" />,
            <see cref="T:PostSharp.CodeModel.ManifestFileDeclaration" />), or <b>null</b> if the resource is
            stored in its declaring assembly.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.ManifestResourceDeclaration.ContentStream">
      <summary>
            Gets or sets a <see cref="T:System.IO.Stream" /> giving the resource content.
            </summary>
      <value>
            A <see cref="T:System.IO.Stream" /> with <b>Seek</b> capability, or <b>null</b>
            if the resource is not stored in the declaring assembly.
            </value>
    </member>
    <member name="T:PostSharp.CodeModel.Collections.ManifestResourceDeclarationCollection">
      <summary>
            Collection of resources (<see cref="T:PostSharp.CodeModel.ManifestResourceDeclaration" />).
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.MemberKind">
      <summary>
            Enumerates the kinds of type members.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.MemberKind.Type">
      <summary>
            Type.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.MemberKind.Field">
      <summary>
            Field.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.MemberKind.Property">
      <summary>
            Property.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.MemberKind.Method">
      <summary>
            Method.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.MemberKind.Event">
      <summary>
            Event.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.MemberKind.Parameter">
      <summary>
            Method parameter.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.MemberValuePair">
      <summary>
            Represents the fact that a member is assigned a value.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.MemberValuePair.#ctor(PostSharp.CodeModel.MemberKind,System.Int32,System.String,PostSharp.CodeModel.SerializedValue)">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.MemberValuePair" />.
            </summary>
      <param name="memberKind">Member kind (<see cref="F:PostSharp.CodeModel.MemberKind.Field" />,
            <see cref="F:PostSharp.CodeModel.MemberKind.Parameter" /> or <see cref="F:PostSharp.CodeModel.MemberKind.Property" />).</param>
      <param name="memberName">Member name.</param>
      <param name="value">Value.</param>
      <param name="ordinal">Ordinal of this instance in the parent collection.</param>
    </member>
    <member name="M:PostSharp.CodeModel.MemberValuePair.Clone(System.Int32)">
      <summary>
            Clone the current instance, but sets another ordinal.
            </summary>
      <param name="ordinal">The ordinal of the new instance.</param>
      <returns>A clone of the current instance, but with the specified ordinal.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.MemberValuePair.Translate(PostSharp.CodeModel.ModuleDeclaration)">
      <summary>
            Translates the current <see cref="T:PostSharp.CodeModel.MemberValuePair" /> so that it can be used in another module.
            </summary>
      <param name="module">The module into which the translated instance should be expressed.</param>
      <returns>A new <see cref="T:PostSharp.CodeModel.MemberValuePair" /> equivalent to the current one, but expressed
            for the other <paramref name="module" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.MemberValuePair.ToString" />
    <member name="P:PostSharp.CodeModel.MemberValuePair.MemberKind">
      <summary>
            Kind of member (<see cref="F:PostSharp.CodeModel.MemberKind.Field" />,
            <see cref="F:PostSharp.CodeModel.MemberKind.Parameter" /> or 
            <see cref="F:PostSharp.CodeModel.MemberKind.Property" />).
            </summary>
      <value>
            A <see cref="T:PostSharp.CodeModel.MemberKind" />.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.MemberValuePair.MemberName">
      <summary>
            Member name.
            </summary>
      <value>
            A non-empty string.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.MemberValuePair.Ordinal">
      <summary>
            Gets the ordinal of this instance in the parent collection.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MemberValuePair.Value">
      <summary>
            Member value.
            </summary>
      <value>
            A <see cref="T:PostSharp.CodeModel.SerializedValue" />.
            </value>
    </member>
    <member name="T:PostSharp.CodeModel.Collections.MemberValuePairCollection">
      <summary>
            Collection of member-value pairs (<see cref="T:PostSharp.CodeModel.MemberValuePair" />).
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.MemberValuePairCollection.#ctor(System.Int32)">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.Collections.MemberValuePairCollection" />
            and specifies the initial capacity.
            </summary>
      <param name="capacity">Initial capacity.</param>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.MemberValuePairCollection.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.Collections.MemberValuePairCollection" />
            with default initial capacity.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.MemberValuePairCollection.Clone">
      <summary>
            Deeply clones the current collection.
            </summary>
      <returns>A new <see cref="T:PostSharp.CodeModel.Collections.MemberValuePairCollection" /> containing
            clones of all members of the current collection.</returns>
    </member>
    <member name="P:PostSharp.CodeModel.Collections.MemberValuePairCollection.Item(System.String)">
      <summary>
            Gets a member given its name.
            </summary>
      <param name="name">Member name.</param>
      <returns>he <see cref="T:PostSharp.CodeModel.MemberValuePair" /> whose name is <paramref name="name" />,
            or <b>null</b> if it could not be found.</returns>
    </member>
    <member name="P:PostSharp.CodeModel.Collections.MemberValuePairCollection.Item(System.Int32)">
      <summary>
            Gets a member given its ordinal.
            </summary>
      <param name="ordinal">Member ordinal.</param>
      <returns>he <see cref="T:PostSharp.CodeModel.MemberValuePair" /> whose ordinal is <paramref name="ordinal" />,
            or <b>null</b> if it could not be found.</returns>
    </member>
    <member name="T:PostSharp.CodeModel.MethodBodyDeclaration">
      <summary>
            Represents the IL body of a method. 
            </summary>
      <remarks>
            Method bodies are owned by methods 
            (<see cref="T:PostSharp.CodeModel.MethodDefDeclaration" />).
            </remarks>
    </member>
    <member name="F:PostSharp.CodeModel.MethodBodyDeclaration.RecomputeMaxStack">
      <summary>
            Value of the <see cref="P:PostSharp.CodeModel.MethodBodyDeclaration.MaxStack" /> property
            that specifies that the current property should be computed.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.MethodBodyDeclaration.GetInstructionSequenceEnumerator">
      <summary>
            Gets an enumator for all the instruction sequences (<see cref="T:PostSharp.CodeModel.InstructionSequence" />)
            contained in the current method body.
            </summary>
      <returns>An enumerator of the sequences contained in the current method body.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.MethodBodyDeclaration.CreateInstructionSequence">
      <summary>
            Creates an <see cref="T:PostSharp.CodeModel.InstructionSequence" /> for the current method body.
            </summary>
      <returns>The new <see cref="T:PostSharp.CodeModel.InstructionSequence" />.</returns>
      <remarks>
            This method does not add the new <see cref="T:PostSharp.CodeModel.InstructionSequence" />
            to any block. This should be done in user code.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.MethodBodyDeclaration.CreateInstructionBlock">
      <summary>
            Creates an <see cref="T:PostSharp.CodeModel.InstructionBlock" /> for the current method body.
            </summary>
      <returns>The new <see cref="T:PostSharp.CodeModel.InstructionBlock" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.MethodBodyDeclaration.GetInstructionSequenceByToken(System.Int32)">
      <summary>
            Gets an <see cref="T:PostSharp.CodeModel.InstructionSequence" /> given its token.
            </summary>
      <param name="token">An <see cref="T:PostSharp.CodeModel.InstructionSequence" /> token.</param>
      <returns>The <see cref="T:PostSharp.CodeModel.InstructionSequence" /> whose token
            is <paramref name="token" />.</returns>
      <remarks>
            Many tokens may resolve to the same <see cref="T:PostSharp.CodeModel.InstructionSequence" />.
            This method may return an <see cref="T:PostSharp.CodeModel.InstructionSequence" /> whose token
            is different than <paramref name="token" />.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.MethodBodyDeclaration.GetInstructionBlockByToken(System.Int16)">
      <summary>
            Gets an <see cref="T:PostSharp.CodeModel.InstructionBlock" /> given its token.
            </summary>
      <param name="token">An <see cref="T:PostSharp.CodeModel.InstructionBlock" /> token.</param>
      <returns>The <see cref="T:PostSharp.CodeModel.InstructionBlock" /> whose token
            is <paramref name="token" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.MethodBodyDeclaration.EnsureWritableLocalVariables">
      <summary>
            Ensure that the collection of local variables are writable.
            </summary>
      <remarks>This method is called automatically when you try to add a new local
            variable. You should call it explicitely in the rare case where you want
            to remove a local variable or change its type.</remarks>
    </member>
    <member name="M:PostSharp.CodeModel.MethodBodyDeclaration.RemoveLocalVariable(System.Int32)">
      <summary>
            Removes a local variable.
            </summary>
      <param name="index">Index of the local variable.</param>
      <remarks>
            This method does not remove symbols (see <see cref="T:PostSharp.CodeModel.LocalVariableSymbol" />) associated
            to the current local variable. Be sure to remove all associated symbols before removing
            the current local variable.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.MethodBodyDeclaration.GetLocalVariable(System.Int32)">
      <summary>
            Gets a <see cref="T:PostSharp.CodeModel.LocalVariableDeclaration" /> given its index.
            </summary>
      <param name="index">The local variable index.</param>
      <returns>The <see cref="T:PostSharp.CodeModel.LocalVariableDeclaration" /> whose
            position is <paramref name="index" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.MethodBodyDeclaration.WriteILDefinition(PostSharp.ModuleWriter.ILWriter)">
      <summary>
            Writes the IL definition of the current instance.
            </summary>
      <param name="writer">An <see cref="T:PostSharp.ModuleWriter.ILWriter" />.</param>
    </member>
    <member name="M:PostSharp.CodeModel.MethodBodyDeclaration.ForEachInstruction(PostSharp.CodeModel.InstructionAction)">
      <summary>
            Calls a specified delegate for each instruction of the current method body.
            </summary>
      <param name="action">A delegate of type <see cref="T:PostSharp.CodeModel.InstructionAction" />
            that will be called for each instruction.</param>
      <remarks>
            This method offers an easy way to iterate the instructions
            of a method.
            </remarks>
      <example>
            MethodDefDeclaration.MethodBody.ForEachInstruction(
            	delegate(InstructionReader instructionReader)
            	{
            		// To something.
                }
            </example>
    </member>
    <member name="M:PostSharp.CodeModel.MethodBodyDeclaration.CreateInstructionReader">
      <summary>
            Gets an <see cref="T:PostSharp.CodeModel.InstructionReader" /> for the current method body, which will
            resolve local variable symbols.
            </summary>
      <returns>An <see cref="T:PostSharp.CodeModel.InstructionReader" /> assigned to the current 
            <see cref="T:PostSharp.CodeModel.MethodBodyDeclaration" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.MethodBodyDeclaration.CreateInstructionReader(System.Boolean)">
      <summary>
            Gets an <see cref="T:PostSharp.CodeModel.InstructionReader" /> for the current method body and specify
            whether it should resolve local variable symbols.
            </summary>
      <param name="resolveSymbols">Whether the <see cref="T:PostSharp.CodeModel.InstructionReader" /> should resolve
            local variable symbols.</param>
      <returns>An <see cref="T:PostSharp.CodeModel.InstructionReader" /> assigned to the current 
            <see cref="T:PostSharp.CodeModel.MethodBodyDeclaration" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.MethodBodyDeclaration.CreateOriginalInstructionReader">
      <summary>
            Gets an <see cref="T:PostSharp.CodeModel.InstructionReader" /> over the <i>original</i> and <i>unstructured</i>
            instruction stream.
            </summary>
      <returns>An <see cref="T:PostSharp.CodeModel.InstructionReader" /> that does not resolve lexical scopes.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.MethodBodyDeclaration.ToString" />
    <member name="M:PostSharp.CodeModel.MethodBodyDeclaration.DebugWriteIL">
      <summary>
            Write the current method body (as MSIL) to the console.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.MethodBodyDeclaration.Dispose" />
    <member name="P:PostSharp.CodeModel.MethodBodyDeclaration.InstructionSequenceCount">
      <summary>
            Gets the number of sequences in the current method body.
            </summary>
      <remarks>
            This property returns the size of the vector needed to store additional
            information about sequences, while using the sequence token as the array index.
            </remarks>
    </member>
    <member name="P:PostSharp.CodeModel.MethodBodyDeclaration.LocalVariableCount">
      <summary>
            Gets the number of local variables.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodBodyDeclaration.InitLocalVariables">
      <summary>
            Determines whether local variables should be initialized 
            by the runtime to their default value.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodBodyDeclaration.MaxStack">
      <summary>
            Gets or sets the maximal number of items that the runtime evaluation
            stack should contain.
            </summary>
      <value>
            Any positive integer, or <see cref="F:PostSharp.CodeModel.MethodBodyDeclaration.RecomputeMaxStack" /> if the
            property should be recomputed by the library.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.MethodBodyDeclaration.RootInstructionBlock">
      <summary>
            Gets or sets the root <see cref="T:PostSharp.CodeModel.InstructionBlock" />.
            </summary>
      <value>
            An <see cref="T:PostSharp.CodeModel.InstructionBlock" />, or <b>null</b> if no
            root block is specified (in the current case the method body is empty).
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.MethodBodyDeclaration.InstructionBlockCount">
      <summary>
            Gets the number of instruction blocks (<see cref="T:PostSharp.CodeModel.InstructionBlock" />)
            created for the current method body.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodBodyDeclaration.Method">
      <summary>
            Gets the <see cref="T:PostSharp.CodeModel.MethodDefDeclaration" /> to which the current 
            body belongs.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodBodyDeclaration.IsModified">
      <summary>
            Determines whether the current method body has been modified.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.InstructionAction">
      <summary>
            Represents an action that performs an action on the current instruction
            of a specified <see cref="T:PostSharp.CodeModel.InstructionReader" />.
            </summary>
      <param name="reader">An <see cref="T:PostSharp.CodeModel.InstructionReader" /> positioned at an instruction.</param>
    </member>
    <member name="T:PostSharp.CodeModel.MethodSpecDeclaration">
      <summary>
            Represents a method specification (<see cref="F:PostSharp.CodeModel.TokenType.MethodSpec" />), i.e. 
            the construction of a concrete generic method.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.MethodSpecDeclaration.GetTokenType">
      <summary>
            Gets the metadata token type of the current declaration.
            </summary>
      <returns>A <see cref="T:PostSharp.CodeModel.TokenType" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.MethodSpecDeclaration.WriteReflectionMethodName(System.Text.StringBuilder,PostSharp.CodeModel.ReflectionNameOptions)">
      <summary>
            Writes to a <see cref="T:System.Text.StringBuilder" /> the full method signature as it would
            be output by <see cref="N:System.Reflection" />. It tries more specifically to produce
            the same result as <b>MethodBase.ToString()</b>.
            </summary>
      <param name="stringBuilder">The <see cref="T:System.Text.StringBuilder" /> to which the signature
            should be written.</param>
      <param name="options">Options.</param>
    </member>
    <member name="M:PostSharp.CodeModel.MethodSpecDeclaration.Equals(PostSharp.CodeModel.IMethodSignature)" />
    <member name="M:PostSharp.CodeModel.MethodSpecDeclaration.Equals(PostSharp.CodeModel.IMethod)" />
    <member name="M:PostSharp.CodeModel.MethodSpecDeclaration.MatchesReference(PostSharp.CodeModel.IMethod)" />
    <member name="M:PostSharp.CodeModel.MethodSpecDeclaration.MatchesReference(PostSharp.CodeModel.IMethodSignature)">
      <summary>
            Determines whether the current method signature matches a given method signature reference.
            </summary>
      <param name="reference">The method signature reference.</param>
      <returns>
        <b>true</b> if the current method signature matches <paramref name="reference" />,
            otherwise <b>false</b>.</returns>
      <remarks>A method signature reference can use an incomplete assembly reference. Therefore, the matching
            is performed using <see cref="M:PostSharp.CodeModel.IAssembly.MatchesReference(PostSharp.CodeModel.IAssemblyName)" />.
            Matching an assembly reference is a looser requirement than matching an assembly name exactly;
            an assembly reference may set no requirement on the public key token or the version, for instance.</remarks>
    </member>
    <member name="M:PostSharp.CodeModel.MethodSpecDeclaration.ToString" />
    <member name="M:PostSharp.CodeModel.MethodSpecDeclaration.GetParameterType(System.Int32)">
      <summary>
            Gets the type of a parameter given its position.
            </summary>
      <param name="index">The parameter position.</param>
      <returns>The type (<see cref="T:PostSharp.CodeModel.TypeSignature" />) of the parameter.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.MethodSpecDeclaration.GetReflectionWrapper(System.Type[],System.Type[])">
      <summary>
            Gets a reflection <see cref="T:System.Reflection.MethodInfo" /> that wraps the current method.
            </summary>
      <param name="genericTypeArguments">Array of generic type arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <param name="genericMethodArguments">Array of generic method arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <returns>A <see cref="T:System.Reflection.MethodInfo" /> wrapping current method in the
            given generic context.</returns>
      <remarks>
            This method returns a <see cref="T:System.Reflection.MethodInfo" /> that is different from the system
            runtime method that is retrieved by <see cref="M:PostSharp.CodeModel.IMethod.GetSystemMethod(System.Type[],System.Type[],PostSharp.CodeModel.BindingOptions)" />. This allows
            a have a <b>System.Reflection</b> representation of the current method even
            when the declaring type it cannot be loaded in the Virtual Runtime Engine.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.MethodSpecDeclaration.GetSystemMethod(System.Type[],System.Type[],PostSharp.CodeModel.BindingOptions)">
      <summary>
            Gets the system runtime method corresponding to the current method.
            </summary>
      <param name="genericTypeArguments">Array of generic type arguments valid in the current context.</param>
      <param name="genericMethodArguments">Array of generic method arguments valid in the current context.</param>
      <param name="bindingOptions">Binding options.</param>
      <returns>The system runtime <see cref="T:System.Reflection.MethodBase" />, or <b>null</b> if
            the current method could not be bound.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.MethodSpecDeclaration.GetMethodDefinition" />
    <member name="M:PostSharp.CodeModel.MethodSpecDeclaration.GetMethodDefinition(PostSharp.CodeModel.BindingOptions)" />
    <member name="M:PostSharp.CodeModel.MethodSpecDeclaration.GetGenericContext(PostSharp.CodeModel.GenericContextOptions)">
      <summary>
            Gets the generic context inside the scope of the generic instance.
            </summary>
      <returns>A <see cref="T:PostSharp.CodeModel.GenericMap" /> mapping ordinals either
            to <see cref="T:PostSharp.CodeModel.GenericParameterDeclaration" /> (in case of
            generic definition), either of the type signature associated
            to this ordinal (in the case of generic instance).</returns>
    </member>
    <member name="M:PostSharp.CodeModel.MethodSpecDeclaration.ReferencesAnyGenericArgument">
      <summary>
            Determines whether generic arguments are used in the current signature.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.MethodSpecDeclaration.Translate(PostSharp.CodeModel.ModuleDeclaration)">
      <summary>
            Translates the current method signature so that it is meaningful in another
            module than the one to which it primarly belong.
            </summary>
      <param name="targetModule">Module into which the type signature should be
            translated.</param>
      <returns>A method signature meaningful in the <paramref name="targetModule" />
            module.</returns>
    </member>
    <member name="P:PostSharp.CodeModel.MethodSpecDeclaration.DeclaringType">
      <summary>
            Gets the declaring type.
            </summary>
      <value>
            The declaring type (<see cref="T:PostSharp.CodeModel.IType" />), or <b>null</b> if the 
            member is contained by the module.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.MethodSpecDeclaration.GenericArguments">
      <summary>
            Gets the collection of generic method arguments.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodSpecDeclaration.GenericMethod">
      <summary>
            Gets the generic method (with formal generic method arguments).
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodSpecDeclaration.CallingConvention">
      <summary>
            Gets the method calling convention.
            </summary>
      <value>
            The calling convention.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.MethodSpecDeclaration.ParameterCount">
      <summary>
            Gets the number of parameters.
            </summary>
      <value>
            The number of parameters.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.MethodSpecDeclaration.ReturnType">
      <summary>
            Gets the return type.
            </summary>
      <value>
            The return type.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.MethodSpecDeclaration.Name">
      <summary>
            Gets the method name.
            </summary>
      <value>
            The method name.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.MethodSpecDeclaration.Attributes">
      <summary>
            Gets the attributes of the method.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodSpecDeclaration.IsVirtual">
      <summary>
            Determines whether the method is virtual.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodSpecDeclaration.IsAbstract">
      <summary>
            Determines whether the method is abstract.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodSpecDeclaration.IsSealed">
      <summary>
            Determines whether the method is sealed.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodSpecDeclaration.Visibility">
      <summary>
            Gets the visibility of the current method.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodSpecDeclaration.IsNew">
      <summary>
            Determines whether the method takes a new slot.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodSpecDeclaration.IsGenericInstance">
      <summary>
            Determines whether the current instance is a generic instance, i.e. whether it has
            been constructed from a generic definition.
            </summary>
      <remarks>
            If the current property returns <b>true</b>, the semantics of <see cref="T:PostSharp.CodeModel.IGenericInstance" />
            are meaningfull for the current intance.
            </remarks>
    </member>
    <member name="T:PostSharp.CodeModel.Collections.MethodSpecDeclarationCollection">
      <summary>
            Collection of method specifications (<see cref="T:PostSharp.CodeModel.MethodSpecDeclaration" />).
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.MethodSpecDeclarationCollection.GetGenericInstance(System.Collections.Generic.IList{PostSharp.CodeModel.ITypeSignature})">
      <summary>
            Gets a generic instance of the generic method that owns this collection but does 
            not create the generic instance if it does not exist.
            </summary>
      <param name="genericArguments">Generic arguments.</param>
      <returns>A generic instance of the owner method constructed with <paramref name="genericArguments" />,
            or <b>null</b> if this generic instance does not exist.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.MethodSpecDeclarationCollection.GetGenericInstance(System.Collections.Generic.IList{PostSharp.CodeModel.ITypeSignature},System.Boolean)">
      <summary>
            Gets a generic instance of the generic method that owns this collection and specifies whether to
            create the generic instance if it does not exist.
            </summary>
      <param name="genericArguments">Generic arguments.</param>
      <param name="create">Whether the generic instance should be created if it does not exist.</param>
      <returns>A generic instance of the owner method constructed with <paramref name="genericArguments" />,
            or <b>null</b> if this generic instance does not exist and the <paramref name="create" /> parameter
            is <b>false</b>.</returns>
    </member>
    <member name="T:PostSharp.CodeModel.PInvokeMap">
      <summary>
            Maps a method declaration to an external unmanaged method.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.PInvokeMap.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.PInvokeMap" />.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.PInvokeMap.Module">
      <summary>
            Gets or sets the module reference containing the unmanaged method.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.PInvokeMap.MethodName">
      <summary>
            Gets or sets the name of the method.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.PInvokeMap.Attributes">
      <summary>
            Gets or sets the PInvoke attributes.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.PInvokeAttributes">
      <summary>
            P-Invoke attributes.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.PInvokeAttributes.None">
      <summary>
            Default.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.PInvokeAttributes.NoMangle">
      <summary>
            Parameter types will not be mangled into the method name.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.PInvokeAttributes.CharSetMask">
      <summary>
            Character set mask.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.PInvokeAttributes.CharSetNotSpec">
      <summary>
            Character set not specified.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.PInvokeAttributes.CharSetAnsi">
      <summary>
            Character set is ANSI.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.PInvokeAttributes.CharSetUnicode">
      <summary>
            Character set is Unicode.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.PInvokeAttributes.CharSetAuto">
      <summary>
            Character set choice is automatic.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.PInvokeAttributes.SupportsLastError">
      <summary>
            Supports Windows GetLastError().
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.PInvokeAttributes.BestFitDisabled">
      <summary>
            Best fit disabled.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.PInvokeAttributes.BestFitEnabled">
      <summary>
            Best fit enabled.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.PInvokeAttributes.ThrowOnUnmappableCharEnabled">
      <summary>
            Throws an exception when characters cannot be mapped to the
            target character set.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.PInvokeAttributes.CallConventionMask">
      <summary>
            Calling convention mask.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.PInvokeAttributes.CallConventionWinApi">
      <summary>
            Calling convention is <b>WINAPI</b>.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.PInvokeAttributes.CallConventionCdecl">
      <summary>
            Calling convention is <b>cdecl</b>.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.PInvokeAttributes.CallConventionStdCall">
      <summary>
            Calling convention is <b>stdcall</b>.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.PInvokeAttributes.CallConventionThisCall">
      <summary>
            Calling convention is <b>thiscall</b>.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.PInvokeAttributes.CallConventionFastCall">
      <summary>
            Calling convention is <b>fastcall</b>.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.StandaloneSignatureDeclaration">
      <summary>
            Represents a stand-alone signature (<see cref="F:PostSharp.CodeModel.TokenType.Signature" />). 
            </summary>
      <remarks>
        <para>
            Stand-alone signatures
            are owned by the module (<see cref="T:PostSharp.CodeModel.ModuleDeclaration" />).
            </para>
            Stand-alone signatures are used solely inside method body. This information is
            read internally by PostSharp, so user code should not need to manipulate
            stand-alone signatures.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.StandaloneSignatureDeclaration.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.StandaloneSignatureDeclaration" />.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.StandaloneSignatureDeclaration.GetTokenType" />
    <member name="M:PostSharp.CodeModel.StandaloneSignatureDeclaration.SetLocalVariables">
      <summary>
            Notify that the current <see cref="T:PostSharp.CodeModel.StandaloneSignatureDeclaration" /> shall
            contain local variables, and return the collection of local variables.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.StandaloneSignatureDeclaration.SetMethodSignature(PostSharp.CodeModel.MethodSignature)">
      <summary>
            Sets the current stand-alone signature to a method signature.
            </summary>
      <param name="value">A method signature.</param>
    </member>
    <member name="M:PostSharp.CodeModel.StandaloneSignatureDeclaration.SetTypeSignature(PostSharp.CodeModel.ITypeSignature,PostSharp.CodeModel.StandaloneSignatureKind)">
      <summary>
            Sets the current stand-alone signature to a type signature.
            </summary>
      <param name="value" />
      <param name="kind" />
    </member>
    <member name="P:PostSharp.CodeModel.StandaloneSignatureDeclaration.SignatureKind">
      <summary>
            Gets the kind of signature contained in the current instance.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.StandaloneSignatureDeclaration.LocalVariables">
      <summary>
            Gets the collection of local variables 
            </summary>
      <exception cref="T:System.InvalidOperationException">
            This instance contains a different kind of signature.
            </exception>
    </member>
    <member name="P:PostSharp.CodeModel.StandaloneSignatureDeclaration.MethodSignature">
      <summary>
            Gets the method signature.
            </summary>
      <exception cref="T:System.InvalidOperationException">
            This instance contains a different kind of signature.
            </exception>
    </member>
    <member name="P:PostSharp.CodeModel.StandaloneSignatureDeclaration.TypeSignature">
      <summary>
            Gets the type signature.
            </summary>
      <exception cref="T:System.InvalidOperationException">
            This instance contains a different kind of signature.
            </exception>
    </member>
    <member name="T:PostSharp.CodeModel.StandaloneSignatureKind">
      <summary>
            Enumerates the kind of stand-alone signatures (<see cref="T:PostSharp.CodeModel.StandaloneSignatureDeclaration" />).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.StandaloneSignatureKind.LocalVariables">
      <summary>
            Collection of local variables.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.StandaloneSignatureKind.MethodSignature">
      <summary>
            Method signature.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.StandaloneSignatureKind.FieldSignature">
      <summary>
            Field type signature.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.StandaloneSignatureKind.PropertySignature">
      <summary>
            Property type signature.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.Collections.StandaloneSignatureDeclarationCollection">
      <summary>
            Collection of <see cref="T:PostSharp.CodeModel.StandaloneSignatureDeclaration" />.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.AssemblyRefDeclaration">
      <summary>
            Represents a reference to an external assembly (<see cref="F:PostSharp.CodeModel.TokenType.AssemblyRef" />).
            </summary>
      <remarks>
            Assembly references are owned
            by the module  (<see cref="T:PostSharp.CodeModel.ModuleDeclaration" />) an are exposed by
            the <see cref="P:PostSharp.CodeModel.ModuleDeclaration.AssemblyRefs" /> collection.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyRefDeclaration.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.AssemblyRefDeclaration" />.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyRefDeclaration.GetTokenType">
      <summary>
            Gets the metadata token type of the current declaration.
            </summary>
      <returns>A <see cref="T:PostSharp.CodeModel.TokenType" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyRefDeclaration.Equals(PostSharp.CodeModel.IAssembly)" />
    <member name="M:PostSharp.CodeModel.AssemblyRefDeclaration.ToString" />
    <member name="M:PostSharp.CodeModel.AssemblyRefDeclaration.GetAssemblyEnvelope">
      <summary>
            Gets the <see cref="T:PostSharp.CodeModel.AssemblyEnvelope" /> corresponding to the current instance
            in the current domain.
            </summary>
      <returns>An <see cref="T:PostSharp.CodeModel.AssemblyEnvelope" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyRefDeclaration.MatchesReference(PostSharp.CodeModel.IAssemblyName)">
      <summary>
            Determines whether the current <see cref="T:PostSharp.CodeModel.AssemblyEnvelope" /> matches a given assembly reference.
            </summary>
      <param name="assemblyName">The assembly reference.</param>
      <returns>
        <b>true</b> if the current <see cref="T:PostSharp.CodeModel.AssemblyEnvelope" /> matches <paramref name="assemblyName" />,
            otherwise <b>false</b>.</returns>
      <remarks>Matching an assembly reference is a looser requirement than matching an assembly name exactly;
            an assembly reference may set no requirement on the public key token or the version, for instance.</remarks>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyRefDeclaration.FindType(System.String,PostSharp.CodeModel.BindingOptions)" />
    <member name="M:PostSharp.CodeModel.AssemblyRefDeclaration.GetSystemAssembly">
      <summary>
            Gets the reflection <see cref="T:System.Reflection.Assembly" /> corresponding 
            to the current instance.
            </summary>
      <returns>The <see cref="T:System.Reflection.Assembly" /> corresponding to this
            instance, or <b>null</b> if the assembly could not be found.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyRefDeclaration.GetReflectionWrapper" />
    <member name="M:PostSharp.CodeModel.AssemblyRefDeclaration.GetPublicKey">
      <summary>
            Gets the public key.
            </summary>
      <remarks>
            The <see cref="F:PostSharp.CodeModel.AssemblyRefAttributes.PublicKey" /> flag should 
            be cleared on the <see cref="P:PostSharp.CodeModel.AssemblyRefDeclaration.Attributes" /> property.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyRefDeclaration.SetPublicKey(System.Byte[])">
      <summary>
            Sets the public key.
            </summary>
      <param name="value">The public key, or <b>null</b> to remove
            the public key.</param>
      <remarks>
            The <see cref="F:PostSharp.CodeModel.AssemblyRefAttributes.PublicKey" /> flag should 
            be set on the <see cref="P:PostSharp.CodeModel.AssemblyRefDeclaration.Attributes" /> property.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyRefDeclaration.GetPublicKeyToken">
      <summary>
            Gets the public key token.
            </summary>
      <remarks>
            The <see cref="F:PostSharp.CodeModel.AssemblyRefAttributes.PublicKey" /> flag should 
            be cleared on the <see cref="P:PostSharp.CodeModel.AssemblyRefDeclaration.Attributes" /> property.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyRefDeclaration.SetPublicKeyToken(System.Byte[])">
      <summary>
            Sets the public key token.
            </summary>
      <param name="value">The public key token, or <b>null</b>
            to remote the public key token.</param>
      <remarks>
            The <see cref="F:PostSharp.CodeModel.AssemblyRefAttributes.PublicKey" /> flag should 
            be cleared on the <see cref="P:PostSharp.CodeModel.AssemblyRefDeclaration.Attributes" /> property.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyRefDeclaration.WriteILDefinition(PostSharp.ModuleWriter.ILWriter)">
      <summary>
            Writes the IL definition of the current instance.
            </summary>
      <param name="writer">An <see cref="T:PostSharp.ModuleWriter.ILWriter" />.</param>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyRefDeclaration.Remove">
      <summary>
            Remove the current declaration from its parent.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.AssemblyRefDeclaration.ClearCache" />
    <member name="P:PostSharp.CodeModel.AssemblyRefDeclaration.IsWeaklyReferenced">
      <summary>
            Determines whether the current declaration is weakly or strongly
            referenced in the current module.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.AssemblyRefDeclaration.Attributes">
      <summary>
            Gets or sets the assembly reference attributes.
            </summary>
      <value>
            A combination of <see cref="T:PostSharp.CodeModel.AssemblyRefAttributes" />.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.AssemblyRefDeclaration.Version">
      <summary>
            Gets the assembly version.
            </summary>
      <value>
            A <see cref="P:PostSharp.CodeModel.IAssemblyName.Version" />.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.AssemblyRefDeclaration.Culture">
      <summary>
            Gets the assembly culture name.
            </summary>
      <value>
            The standard assembly culture name, or <b>null</b> if the assembly
            is culture-neutral.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.AssemblyRefDeclaration.HashValue" />
    <member name="P:PostSharp.CodeModel.AssemblyRefDeclaration.HashAlgorithm" />
    <member name="P:PostSharp.CodeModel.AssemblyRefDeclaration.IsMscorlib">
      <summary>
            Determines whether the current assembly is <b>mscorlib</b>.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.AssemblyRefDeclaration.FullName">
      <summary>
            Gets the assembly full name.
            </summary>
      <value>
            The assembly full name including version number, culture name
            and public key token.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.AssemblyRefDeclaration.TypeRefs">
      <summary>
            Gets the collection of type references (<see cref="T:PostSharp.CodeModel.TypeRefDeclaration" />)
            whose resolution scope is the current declaration.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.AssemblyRefDeclaration.OverwrittenName">
      <summary>
            Name of the assembly as it will be <i>emitted</i> during compilation.
            </summary>
      <remarks>
        <para>Overwriting an assembly name allows to change the name of the <i>compiled</i>
            assembly without breaking references in the current domain (because changing
            the <see cref="P:PostSharp.CodeModel.NamedDeclaration.Name" /> would make it impossible to resolve assembly references).</para>
        <para>When the name is overwritten, the public key is automatically ignored
            during compilation.</para>
      </remarks>
      <value>A valid name, or <b>null</b> if the name is not overwritten.</value>
    </member>
    <member name="T:PostSharp.CodeModel.AssemblyRefAttributes">
      <summary>
            Options of assembly references (<see cref="T:PostSharp.CodeModel.AssemblyRefDeclaration" />).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.AssemblyRefAttributes.None">
      <summary>
            Default.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.AssemblyRefAttributes.PublicKey">
      <summary>
            The assembly reference holds the full (unhashed) public key.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.AssemblyRefAttributes.Retargetable">
      <summary>
            The implementation of the current assembly used at runtime is
            not expected to match the version seen at compile time.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.AssemblyRefAttributes.EnableJitCompileTracking">
      <summary>
            Reserved.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.AssemblyRefAttributes.DisableJitCompileOptimizer">
      <summary>
            Reserved.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.Collections.AssemblyRefDeclarationCollection">
      <summary>
            Collection of <see cref="T:PostSharp.CodeModel.AssemblyRefDeclaration" />.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.MemberRefDeclaration">
      <summary>
            Represents a reference to a field or method (<see cref="F:PostSharp.CodeModel.TokenType.MemberRef" />). This type
            is the base of <see cref="T:PostSharp.CodeModel.FieldRefDeclaration" /> and <see cref="T:PostSharp.CodeModel.MethodRefDeclaration" />.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.MemberRefDeclaration.GetTokenType" />
    <member name="P:PostSharp.CodeModel.MemberRefDeclaration.ResolutionScope">
      <summary>
            Gets scope in which the current reference should be resolved.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MemberRefDeclaration.DeclaringType">
      <summary>
            Gets the declaring <see cref="T:PostSharp.CodeModel.IType" />.
            </summary>
      <value>
            The declaring type (<see cref="T:PostSharp.CodeModel.TypeRefDeclaration" /> or 
            <see cref="T:PostSharp.CodeModel.TypeSpecDeclaration" />) or <b>null</b>
            if <see cref="P:PostSharp.CodeModel.MemberRefDeclaration.ResolutionScope" /> is not a type.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.MemberRefDeclaration.DeclaringAssembly">
      <summary>
            Gets the assembly in which the member is defined.
            </summary>
      <value>
            An <see cref="T:PostSharp.CodeModel.IAssembly" />.
            </value>
    </member>
    <member name="T:PostSharp.CodeModel.ModuleRefDeclaration">
      <summary>
            Represents a reference to another module in the same assembly (<see cref="F:PostSharp.CodeModel.TokenType.ModuleRef" />).
            </summary>
      <remarks>
            Module references are contained by modules (<see cref="T:PostSharp.CodeModel.ModuleDeclaration" />).
            </remarks>
    </member>
    <member name="T:PostSharp.CodeModel.IModule">
      <summary>
            Defines the functionalities that are common to all representations of a module
            (<see cref="T:PostSharp.CodeModel.ModuleDeclaration" />, <see cref="T:PostSharp.CodeModel.ModuleRefDeclaration" />).
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.IModule.Name">
      <summary>
            Gets the module name.
            </summary>
      <value>
            The module name.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.IModule.Assembly">
      <summary>
            Gets the assembly containing the module.
            </summary>
      <value>
            The assembly (<see cref="T:PostSharp.CodeModel.IAssembly" />) containing the module.
            </value>
    </member>
    <member name="M:PostSharp.CodeModel.ModuleRefDeclaration.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.ModuleRefDeclaration" />.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.ModuleRefDeclaration.GetTokenType">
      <summary>
            Gets the metadata token type of the current declaration.
            </summary>
      <returns>A <see cref="T:PostSharp.CodeModel.TokenType" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.ModuleRefDeclaration.WriteILDefinition(PostSharp.ModuleWriter.ILWriter)">
      <summary>
            Writes the IL definition of the current instance.
            </summary>
      <param name="writer">An <see cref="T:PostSharp.ModuleWriter.ILWriter" />.</param>
    </member>
    <member name="M:PostSharp.CodeModel.ModuleRefDeclaration.GetModuleDefinition">
      <summary>
            Gets the <see cref="T:PostSharp.CodeModel.ModuleDeclaration" /> corresponding to the current
            reference.
            </summary>
      <returns>The <see cref="T:PostSharp.CodeModel.ModuleDeclaration" /> corresponding to the current
            reference.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.ModuleRefDeclaration.FindType(System.String,PostSharp.CodeModel.BindingOptions)" />
    <member name="M:PostSharp.CodeModel.ModuleRefDeclaration.ClearCache" />
    <member name="P:PostSharp.CodeModel.ModuleRefDeclaration.Assembly">
      <summary>
            Gets the assembly containing the module.
            </summary>
      <value>
            The assembly (<see cref="T:PostSharp.CodeModel.IAssembly" />) containing the module.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.ModuleRefDeclaration.TypeRefs">
      <summary>
            Gets the collection of type references (<see cref="T:PostSharp.CodeModel.TypeRefDeclaration" />)
            declared in the referenced module.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.ModuleRefDeclaration.FieldRefs">
      <summary>
            Gets the collection of field references (<see cref="T:PostSharp.CodeModel.FieldRefDeclaration" />)
            declared in the referenced module.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.ModuleRefDeclaration.MethodRefs">
      <summary>
            Gets the collection of method references (<see cref="T:PostSharp.CodeModel.MethodRefDeclaration" />)
            declared in the referenced module.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.Collections.ModuleRefDeclarationCollection">
      <summary>
            Collection of module references (<see cref="T:PostSharp.CodeModel.ModuleRefDeclaration" />).
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.FieldRefDeclaration">
      <summary>
            Represents a reference to a field of a
            type defined in an external assembly (<see cref="F:PostSharp.CodeModel.TokenType.MemberRef" />). 
            </summary>
      <remarks>
            Field references are
            owned by type references (<see cref="T:PostSharp.CodeModel.TypeRefDeclaration" />) on the
            <see cref="P:PostSharp.CodeModel.TypeRefDeclaration.FieldRefs" /> property, or by type
            specifications (<see cref="T:PostSharp.CodeModel.TypeSpecDeclaration" />) on the
            <see cref="P:PostSharp.CodeModel.TypeSpecDeclaration.FieldRefs" /> property.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.FieldRefDeclaration.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.FieldRefDeclaration" />.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.FieldRefDeclaration.ToString" />
    <member name="M:PostSharp.CodeModel.FieldRefDeclaration.GetSystemField(System.Type[],System.Type[])">
      <summary>
            Gets the system runtime field corresponding to the current field.
            </summary>
      <param name="genericTypeArguments">Array of generic type arguments valid in the current context.</param>
      <param name="genericMethodArguments">Array of generic method arguments valid in the current context.</param>
      <returns>The system runtime <see cref="T:System.Reflection.FieldInfo" />, or <b>null</b> if
            the current field could not be bound.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.FieldRefDeclaration.GetReflectionWrapper(System.Type[],System.Type[])">
      <summary>
            Gets a reflection <see cref="T:System.Reflection.FieldInfo" /> that wraps the current field.
            </summary>
      <param name="genericTypeArguments">Array of generic type arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <param name="genericMethodArguments">Array of generic method arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <returns>A <see cref="T:System.Reflection.FieldInfo" /> wrapping current field in the
            given generic context.</returns>
      <remarks>
            This method returns a <see cref="T:System.Reflection.FieldInfo" /> that is different from the system
            runtime field that is retrieved by <see cref="M:PostSharp.CodeModel.IField.GetSystemField(System.Type[],System.Type[])" />. This allows
            a have a <b>System.Reflection</b> representation of the current field even
            when the declaring type it cannot be loaded in the Virtual Runtime Engine.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.FieldRefDeclaration.GetGenericContext(PostSharp.CodeModel.GenericContextOptions)">
      <summary>
            Gets the generic context of the declaring type, or 
            an empty context if the member is contained by the module.
            </summary>
      <returns />
    </member>
    <member name="M:PostSharp.CodeModel.FieldRefDeclaration.GetFieldDefinition" />
    <member name="M:PostSharp.CodeModel.FieldRefDeclaration.GetFieldDefinition(PostSharp.CodeModel.BindingOptions)" />
    <member name="M:PostSharp.CodeModel.FieldRefDeclaration.Translate(PostSharp.CodeModel.ModuleDeclaration)">
      <summary>
            Translates the current field so that it is meaningful in another
            module than the one to which it primarly belong.
            </summary>
      <param name="targetModule">Module into which the type signature should be
            translated.</param>
      <returns>A field meaningful in the <paramref name="targetModule" />
            module.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.FieldRefDeclaration.ClearCache" />
    <member name="P:PostSharp.CodeModel.FieldRefDeclaration.FieldType">
      <summary>
            Gets or sets the type of the referenced field.
            </summary>
      <value>
            A <see cref="T:PostSharp.CodeModel.TypeSignature" />.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.FieldRefDeclaration.Attributes">
      <summary>
            Gets the field attributes.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.FieldRefDeclaration.IsStatic">
      <summary>
            Determines whether the field is static.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.FieldRefDeclaration.IsReadOnly">
      <summary>
            Determines whether the field is read-only (i.e. init only).
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.FieldRefDeclaration.IsConst">
      <summary>
            Determines whether the field is constant (i.e. literal).
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.Collections.FieldRefDeclarationCollection">
      <summary>
            Collection of <see cref="T:PostSharp.CodeModel.FieldRefDeclaration" /> objects.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.FieldRefDeclarationCollection.GetField(System.String,PostSharp.CodeModel.ITypeSignature,PostSharp.CodeModel.BindingOptions)">
      <summary>
            Finds a field in the type given its name and type.
            </summary>
      <param name="name">Field name.</param>
      <param name="type">Field type.</param>
      <param name="bindingOptions">Determines the behavior in case the field is not
            found.</param>
      <returns>The field, or <b>null</b> if the method could not be found.</returns>
    </member>
    <member name="T:PostSharp.CodeModel.MethodRefDeclaration">
      <summary>
            Represents a method reference.
            </summary>
      <remarks>
             Method references are
            owned by <see cref="T:PostSharp.CodeModel.IMemberRefResolutionScope" />.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.MethodRefDeclaration.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.MethodRefDeclaration" />.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.MethodRefDeclaration.ToString" />
    <member name="M:PostSharp.CodeModel.MethodRefDeclaration.WriteReflectionMethodName(System.Text.StringBuilder,PostSharp.CodeModel.ReflectionNameOptions)">
      <summary>
            Writes to a <see cref="T:System.Text.StringBuilder" /> the full method signature as it would
            be output by <see cref="N:System.Reflection" />. It tries more specifically to produce
            the same result as <b>MethodBase.ToString()</b>.
            </summary>
      <param name="stringBuilder">The <see cref="T:System.Text.StringBuilder" /> to which the signature
            should be written.</param>
      <param name="options">Options.</param>
    </member>
    <member name="M:PostSharp.CodeModel.MethodRefDeclaration.GetReflectionWrapper(System.Type[],System.Type[])">
      <summary>
            Gets a reflection <see cref="T:System.Reflection.MethodInfo" /> that wraps the current method.
            </summary>
      <param name="genericTypeArguments">Array of generic type arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <param name="genericMethodArguments">Array of generic method arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <returns>A <see cref="T:System.Reflection.MethodInfo" /> wrapping current method in the
            given generic context.</returns>
      <remarks>
            This method returns a <see cref="T:System.Reflection.MethodInfo" /> that is different from the system
            runtime method that is retrieved by <see cref="M:PostSharp.CodeModel.IMethod.GetSystemMethod(System.Type[],System.Type[],PostSharp.CodeModel.BindingOptions)" />. This allows
            a have a <b>System.Reflection</b> representation of the current method even
            when the declaring type it cannot be loaded in the Virtual Runtime Engine.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.MethodRefDeclaration.GetSystemMethod(System.Type[],System.Type[],PostSharp.CodeModel.BindingOptions)">
      <summary>
            Gets the system runtime method corresponding to the current method.
            </summary>
      <param name="genericTypeArguments">Array of generic type arguments valid in the current context.</param>
      <param name="genericMethodArguments">Array of generic method arguments valid in the current context.</param>
      <param name="bindingOptions">Binding options.</param>
      <returns>The system runtime <see cref="T:System.Reflection.MethodBase" />, or <b>null</b> if
            the current method could not be bound.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.MethodRefDeclaration.FindGenericInstance(System.Collections.Generic.IList{PostSharp.CodeModel.ITypeSignature},PostSharp.CodeModel.BindingOptions)">
      <summary>
            Finds or construct a specific generic instance of the current generic method definition.
            </summary>
      <param name="genericArguments">Generic arguments.</param>
      <param name="bindingOptions">Binding options.</param>
      <returns>The generic instance, or <b>null</b> if it was not found and was not
            requested to be created.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.MethodRefDeclaration.Translate(PostSharp.CodeModel.ModuleDeclaration)">
      <summary>
            Translates the current method signature so that it is meaningful in another
            module than the one to which it primarly belong.
            </summary>
      <param name="targetModule">Module into which the type signature should be
            translated.</param>
      <returns>A method signature meaningful in the <paramref name="targetModule" />
            module.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.MethodRefDeclaration.Equals(PostSharp.CodeModel.IMethodSignature)" />
    <member name="M:PostSharp.CodeModel.MethodRefDeclaration.Equals(PostSharp.CodeModel.IMethod)" />
    <member name="M:PostSharp.CodeModel.MethodRefDeclaration.MatchesReference(PostSharp.CodeModel.IMethod)" />
    <member name="M:PostSharp.CodeModel.MethodRefDeclaration.MatchesReference(PostSharp.CodeModel.IMethodSignature)">
      <summary>
            Determines whether the current method signature matches a given method signature reference.
            </summary>
      <param name="reference">The method signature reference.</param>
      <returns>
        <b>true</b> if the current method signature matches <paramref name="reference" />,
            otherwise <b>false</b>.</returns>
      <remarks>A method signature reference can use an incomplete assembly reference. Therefore, the matching
            is performed using <see cref="M:PostSharp.CodeModel.IAssembly.MatchesReference(PostSharp.CodeModel.IAssemblyName)" />.
            Matching an assembly reference is a looser requirement than matching an assembly name exactly;
            an assembly reference may set no requirement on the public key token or the version, for instance.</remarks>
    </member>
    <member name="M:PostSharp.CodeModel.MethodRefDeclaration.GetMethodDefinition" />
    <member name="M:PostSharp.CodeModel.MethodRefDeclaration.GetMethodDefinition(PostSharp.CodeModel.BindingOptions)" />
    <member name="M:PostSharp.CodeModel.MethodRefDeclaration.GetGenericParameter(System.Int32)">
      <summary>
            Gets a generic (formal, unbound) parameter given its ordinal.
            </summary>
      <param name="ordinal">The generic parameter ordinal (position).</param>
      <returns>A <see cref="T:PostSharp.CodeModel.GenericParameterDeclaration" />, or <b>null</b>
            if the current generic parameter does not exist.</returns>
      <remarks>If the current instance is a defined in the current module
            (<see cref="T:PostSharp.CodeModel.MethodDefDeclaration" />, <see cref="T:PostSharp.CodeModel.TypeDefDeclaration" />),
            this method returns a <see cref="T:PostSharp.CodeModel.GenericParameterDeclaration" />.
            Otherwise, it returns a reference to a generic parameter, i.e.
            a <see cref="T:PostSharp.CodeModel.TypeSignatures.GenericParameterTypeSignature" />.</remarks>
    </member>
    <member name="M:PostSharp.CodeModel.MethodRefDeclaration.GetGenericContext(PostSharp.CodeModel.GenericContextOptions)">
      <summary>
            Gets the generic context inside the scope of the generic instance.
            </summary>
      <returns>A <see cref="T:PostSharp.CodeModel.GenericMap" /> mapping ordinals either
            to <see cref="T:PostSharp.CodeModel.GenericParameterDeclaration" /> (in case of
            generic definition), either of the type signature associated
            to this ordinal (in the case of generic instance).</returns>
    </member>
    <member name="M:PostSharp.CodeModel.MethodRefDeclaration.ClearCache" />
    <member name="P:PostSharp.CodeModel.MethodRefDeclaration.MethodSpecs">
      <summary>
            Gets the collection of method specifications (<see cref="T:PostSharp.CodeModel.MethodSpecDeclaration" />).
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodRefDeclaration.Signature">
      <summary>
            Gets or sets the method signature.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodRefDeclaration.IsGenericDefinition">
      <summary>
            Determines whether the current instance is a generic definition, i.e. whether it can
            be used to construct generic instances.
            </summary>
      <remarks>
            If the current property returns <b>true</b>, the semantics of <see cref="T:PostSharp.CodeModel.IGenericDefinition" />
            are meaningfull for the current intance.
            </remarks>
    </member>
    <member name="P:PostSharp.CodeModel.MethodRefDeclaration.Attributes">
      <summary>
            Gets the attributes of the method.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodRefDeclaration.Visibility">
      <summary>
            Gets the visibility of the current method.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodRefDeclaration.IsVirtual">
      <summary>
            Determines whether the method is virtual.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodRefDeclaration.IsAbstract">
      <summary>
            Determines whether the method is abstract.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodRefDeclaration.IsSealed">
      <summary>
            Determines whether the method is sealed.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodRefDeclaration.IsNew">
      <summary>
            Determines whether the method takes a new slot.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodRefDeclaration.GenericParameterCount">
      <summary>
            Gets the number of generic parameters or arguments (i.e. the <i>arity</i>).
            </summary>
      <summary>
            Gets the number of (formal, unbound) generic parameters.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.Collections.MethodRefDeclarationCollection">
      <summary>
            Collection of method references (<see cref="T:PostSharp.CodeModel.MethodRefDeclaration" />).
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.MethodRefDeclarationCollection.GetMethod(System.String,PostSharp.CodeModel.IMethodSignature,PostSharp.CodeModel.BindingOptions)">
      <summary>
            Finds a method in the type given its name and signature.
            </summary>
      <param name="name">Method name.</param>
      <param name="signature">Method signature.</param>
      <param name="bindingOptions">Determines the behavior in case the method is not
            found.</param>
      <returns>The method, or <b>null</b> if the method could not be found.</returns>
    </member>
    <member name="T:PostSharp.CodeModel.TypeRefDeclaration">
      <summary>
            Represents a type reference (<see cref="F:PostSharp.CodeModel.TokenType.TypeRef" />). 
            </summary>
      <remarks>
            Type references are
            owned by types implementing the <see cref="T:PostSharp.CodeModel.ITypeRefResolutionScope" />
            interface, i.e.
            <see cref="T:PostSharp.CodeModel.TypeRefDeclaration" /> (in case of nested types),
            <see cref="T:PostSharp.CodeModel.AssemblyRefDeclaration" />, <see cref="T:PostSharp.CodeModel.ModuleRefDeclaration" />
            and <see cref="T:PostSharp.CodeModel.ModuleDeclaration" /> (although the latest case should
            never occur).
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.TypeRefDeclaration.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.TypeRefDeclaration" />.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.TypeRefDeclaration.GetTokenType">
      <summary>
            Gets the metadata token type of the current declaration.
            </summary>
      <returns>A <see cref="T:PostSharp.CodeModel.TokenType" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeRefDeclaration.ToString" />
    <member name="M:PostSharp.CodeModel.TypeRefDeclaration.Equals(PostSharp.CodeModel.ITypeSignature)" />
    <member name="M:PostSharp.CodeModel.TypeRefDeclaration.MatchesReference(PostSharp.CodeModel.ITypeSignature)">
      <summary>
            Determines whether the current type signature matches a given type signature.
            </summary>
      <param name="reference">The type reference.</param>
      <returns>
        <b>true</b> if the current type signature matches <paramref name="reference" />,
            otherwise <b>false</b>.</returns>
      <remarks>A type reference can use an incomplete assembly reference. Therefore, the matching
            is performed using <see cref="M:PostSharp.CodeModel.IAssembly.MatchesReference(PostSharp.CodeModel.IAssemblyName)" />.
            Matching an assembly reference is a looser requirement than matching an assembly name exactly;
            an assembly reference may set no requirement on the public key token or the version, for instance.</remarks>
    </member>
    <member name="M:PostSharp.CodeModel.TypeRefDeclaration.IsAssignableTo(PostSharp.CodeModel.ITypeSignature,PostSharp.CodeModel.GenericMap)" />
    <member name="M:PostSharp.CodeModel.TypeRefDeclaration.IsAssignableTo(PostSharp.CodeModel.ITypeSignature)" />
    <member name="M:PostSharp.CodeModel.TypeRefDeclaration.GetTypeDefinition" />
    <member name="M:PostSharp.CodeModel.TypeRefDeclaration.GetCanonicalHashCode">
      <summary>
            Gets a hash code that is invariant under type signature equality
            (i.e. if two types are equal under <see cref="T:System.IEquatable`1" />, they have the
            same canonical has code).
            </summary>
      <returns>A hash code that is invariant under type signature equality.</returns>
      <remarks>This method is of course useful to build dictionaries. The <see cref="T:PostSharp.CodeModel.Binding.TypeComparer" /> class
            uses this method.</remarks>
    </member>
    <member name="M:PostSharp.CodeModel.TypeRefDeclaration.GetTypeDefinition(PostSharp.CodeModel.BindingOptions)" />
    <member name="M:PostSharp.CodeModel.TypeRefDeclaration.ContainsGenericArguments">
      <summary>
            Determines whether the type signature contains a generic argument.
            </summary>
      <returns>
        <b>true</b> if the type signature contains a generic argument, otherwise <b>false</b>.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeRefDeclaration.MapGenericArguments(PostSharp.CodeModel.GenericMap)">
      <summary>
            Resolves all generic arguments in the current type signature.
            </summary>
      <param name="genericMap">Generic context in which generic arguments have to be resolved.</param>
      <returns>A <see cref="T:PostSharp.CodeModel.IType" /> resolved against <paramref name="genericMap" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeRefDeclaration.WriteReflectionTypeName(System.Text.StringBuilder,PostSharp.CodeModel.ReflectionNameOptions)">
      <summary>
            Gets the full type name according the conventions of <see cref="N:System.Reflection" />
            (with the namespace and nesting type but without the assembly name).
            </summary>
      <returns>The full type name (with the namespace and nesting type but without the assembly name).</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeRefDeclaration.GetSystemType(System.Type[],System.Type[])">
      <summary>
            Gets the system, runtime <see cref="T:System.Type" /> corresponding to the current type.
            </summary>
      <param name="genericTypeArguments">Array of generic type arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <param name="genericMethodArguments">Array of generic method arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <returns>The system <see cref="T:System.Type" /> associated the current type in the
            given generic context.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeRefDeclaration.GetReflectionWrapper(System.Type[],System.Type[])">
      <summary>
            Gets a reflection <see cref="T:System.Type" /> that wraps the current type.
            </summary>
      <param name="genericTypeArguments">Array of generic type arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <param name="genericMethodArguments">Array of generic method arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <returns>A <see cref="T:System.Type" /> wrapping current type in the
            given generic context.</returns>
      <remarks>
            This method returns a <see cref="T:System.Type" /> that is different from the system
            runtime type that is retrieved by <see cref="M:PostSharp.CodeModel.ITypeSignature.GetSystemType(System.Type[],System.Type[])" />. This allows
            a have a <b>System.Reflection</b> representation of the current type even
            when it cannot be loaded in the Virtual Runtime Engine.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.TypeRefDeclaration.BelongsToClassification(PostSharp.CodeModel.TypeClassifications)">
      <summary>
            Determines whether the type signature belongs to a given classification,
            i.e. whether it fulfills a given predicate.
            </summary>
      <param name="typeClassification">The classification (or predicate) 
            (combination of bits are not allowed).</param>
      <returns>
        <see cref="F:PostSharp.NullableBool.True" /> if the predicate is true, 
            <see cref="F:PostSharp.NullableBool.False" /> if the predicate is false or
            <see cref="F:PostSharp.NullableBool.Null" /> if it cannot be determined. </returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeRefDeclaration.Translate(PostSharp.CodeModel.ModuleDeclaration)">
      <summary>
            Translates the current type signature so that it is meaningful in another
            module than the one to which it primarly belong.
            </summary>
      <param name="targetModule">Module into which the type signature should be
            translated.</param>
      <returns>A type signature meaningful in the <paramref name="targetModule" />
            module.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeRefDeclaration.GetGenericParameter(System.Int32)">
      <summary>
            Gets a generic (formal, unbound) parameter given its ordinal.
            </summary>
      <param name="ordinal">The generic parameter ordinal (position).</param>
      <returns>A <see cref="T:PostSharp.CodeModel.GenericParameterDeclaration" />, or <b>null</b>
            if the current generic parameter does not exist.</returns>
      <remarks>If the current instance is a defined in the current module
            (<see cref="T:PostSharp.CodeModel.MethodDefDeclaration" />, <see cref="T:PostSharp.CodeModel.TypeDefDeclaration" />),
            this method returns a <see cref="T:PostSharp.CodeModel.GenericParameterDeclaration" />.
            Otherwise, it returns a reference to a generic parameter, i.e.
            a <see cref="T:PostSharp.CodeModel.TypeSignatures.GenericParameterTypeSignature" />.</remarks>
    </member>
    <member name="M:PostSharp.CodeModel.TypeRefDeclaration.GetGenericContext(PostSharp.CodeModel.GenericContextOptions)">
      <summary>
            Gets the generic context inside the scope of the generic instance.
            </summary>
      <returns>A <see cref="T:PostSharp.CodeModel.GenericMap" /> mapping ordinals either
            to <see cref="T:PostSharp.CodeModel.GenericParameterDeclaration" /> (in case of
            generic definition), either of the type signature associated
            to this ordinal (in the case of generic instance).</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeRefDeclaration.ClearCache" />
    <member name="P:PostSharp.CodeModel.TypeRefDeclaration.ResolutionScope">
      <summary>
            Gets the scope in which the current <see cref="T:PostSharp.CodeModel.TypeRefDeclaration" />
            should be resolved.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeRefDeclaration.TypeRefs">
      <summary>
            Gets the collection of type references (<see cref="T:PostSharp.CodeModel.TypeRefDeclaration" />)
            whose resolution scope is the current declaration.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeRefDeclaration.FieldRefs">
      <summary>
            Gets the collection of fields (<see cref="T:PostSharp.CodeModel.FieldRefDeclaration" />) 
            defined on the current object.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeRefDeclaration.Attributes">
      <summary>
            Gets or sets the type attributes.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeRefDeclaration.IsSealed">
      <summary>
            Determines whether the type is sealed.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeRefDeclaration.IsInterface">
      <summary>
            Determines whether the type is an interface.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeRefDeclaration.IsAbstract">
      <summary>
            Determines whether the class is abstract.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeRefDeclaration.MethodRefs">
      <summary>
            Gets the collection of methods (<see cref="T:PostSharp.CodeModel.MethodRefDeclaration" />)
            defined on the current object.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeRefDeclaration.DeclaringAssembly">
      <summary>
            Gets the declaring assembly.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeRefDeclaration.DeclaringType">
      <summary>
            Gets the declaring type (i.e. the type in which the current type
            is nested), or <b>null</b> if the current type is not nested.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeRefDeclaration.IsGenericDefinition">
      <summary>
            Determines whether the current instance is a generic definition, i.e. whether it can
            be used to construct generic instances.
            </summary>
      <remarks>
            If the current property returns <b>true</b>, the semantics of <see cref="T:PostSharp.CodeModel.IGenericDefinition" />
            are meaningfull for the current intance.
            </remarks>
    </member>
    <member name="P:PostSharp.CodeModel.TypeRefDeclaration.GenericParameterCount">
      <summary>
            Gets the number of (formal, unbound) generic parameters.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeRefDeclaration.IsWeaklyReferenced">
      <summary>
            Determines whether the current declaration is weakly or strongly
            referenced in the current module.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeRefDeclaration.TypeClassifications">
      <summary>
            Classifications of the referred type. We use only <see cref="F:PostSharp.CodeModel.TypeClassifications.ValueType" />
            and <see cref="F:PostSharp.CodeModel.TypeClassifications.ReferenceType" />. In case of ambiguity, many conflicting
            bits may be set; in this case, the method <see cref="M:PostSharp.CodeModel.TypeRefDeclaration.BelongsToClassification(PostSharp.CodeModel.TypeClassifications)" /> will request
            the type definition for classifications, which has the expensive side effect to load the referrenced assembly.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.Collections.TypeRefDeclarationCollection">
      <summary>
            Collection of type references (<see cref="T:PostSharp.CodeModel.Collections.TypeRefDeclarationCollection" />).
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.GenericContextOptions">
      <summary>
            Options of the <see cref="M:PostSharp.CodeModel.IGeneric.GetGenericContext(PostSharp.CodeModel.GenericContextOptions)" /> method.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.GenericContextOptions.None">
      <summary>
            Default.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.GenericContextOptions.ResolveGenericParameterDefinitions">
      <summary>
            Force type and method references (<see cref="T:PostSharp.CodeModel.TypeRefDeclaration" /> and <see cref="T:PostSharp.CodeModel.MethodRefDeclaration" />) to
            return the generic context of their definition (<see cref="T:PostSharp.CodeModel.TypeDefDeclaration" /> and <see cref="T:PostSharp.CodeModel.MethodDefDeclaration" />), that
            is, to put in the generic context their real generic parameters (<see cref="T:PostSharp.CodeModel.GenericParameterDeclaration" />) instead of
            a placeholder (<see cref="T:PostSharp.CodeModel.TypeSignatures.GenericParameterTypeSignature" />). Note that it forces the references to be resolved.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.CallingConvention">
      <summary>
            Determines the calling convention of methods.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.CallingConvention.Default">
      <summary>
            Default.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.CallingConvention.UnmanagedCdecl">
      <summary>
            Unmanaged <b>cdecl</b>.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.CallingConvention.UnmanagedStdCall">
      <summary>
            Unmanaged <b>StdCall</b>.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.CallingConvention.UnmanagedThisCall">
      <summary>
            Unmanaged <b>ThisCall</b>.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.CallingConvention.UnmanagedFastCall">
      <summary>
            Unmanaged <b>FastCall</b>.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.CallingConvention.VarArg">
      <summary>
            Managed <b>VarArg</b>.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.CallingConvention.Field">
      <internal />
      <summary>
            The signature is a field signature.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.CallingConvention.LocalSig">
      <internal />
      <summary>
            The signature is a local variable signature.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.CallingConvention.Property">
      <internal />
      <summary>
            The signature is a property signature,
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.CallingConvention.GenericInstance">
      <internal />
      <summary>
             Generic method instantiation.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.CallingConvention.NativeVarArg">
      <summary>
            NativeVarArg (Used ONLY for 64bit vararg PInvoke calls).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.CallingConvention.Any">
      <internal />
      <summary>
            Indicates that any calling convention is acceptable.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.CallingConvention.CallingConventionMask">
      <summary>
            Bit mask for the calling convention.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.CallingConvention.HasThis">
      <summary>
            There is a <b>this</b> parameter.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.CallingConvention.ExplicitThis">
      <summary>
            The <b>this</b> parameter is explicitely in the signature.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.CallingConvention.Generic">
      <internal />
      <summary>
            Generic method signature with explicit number of type arguments.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.TokenType">
      <summary>
            Specifies the type of metadata token.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TokenType.Module">
      <summary>
            Module definition (<see cref="T:PostSharp.CodeModel.ModuleDeclaration" />).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TokenType.TypeRef">
      <summary>
            Type reference (<see cref="T:PostSharp.CodeModel.TypeRefDeclaration" />).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TokenType.TypeDef">
      <summary>
            Type definition (<see cref="T:PostSharp.CodeModel.TypeDefDeclaration" />).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TokenType.FieldDef">
      <summary>
            Field definition (<see cref="T:PostSharp.CodeModel.FieldDefDeclaration" />).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TokenType.MethodDef">
      <summary>
            Method definition (<see cref="T:PostSharp.CodeModel.MethodDefDeclaration" />).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TokenType.ParamDef">
      <summary>
            Parameter definition (<see cref="T:PostSharp.CodeModel.ParameterDeclaration" />).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TokenType.InterfaceImpl">
      <summary>
            Interface implementation (<see cref="P:PostSharp.CodeModel.MethodDefDeclaration.InterfaceImplementations" />).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TokenType.MemberRef">
      <summary>
            References to fields or methods (<see cref="T:PostSharp.CodeModel.FieldRefDeclaration" />,
            <see cref="T:PostSharp.CodeModel.MethodRefDeclaration" />).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TokenType.CustomAttribute">
      <summary>
            Custom attribute (<see cref="T:PostSharp.CodeModel.CustomAttributeDeclaration" />).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TokenType.Permission">
      <summary>
            Permission set (<see cref="T:PostSharp.CodeModel.PermissionSetDeclaration" />).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TokenType.Signature">
      <summary>
            Stand-alone signature (<see cref="T:PostSharp.CodeModel.StandaloneSignatureDeclaration" />).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TokenType.Event">
      <summary>
            Event definition (<see cref="T:PostSharp.CodeModel.EventDeclaration" />).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TokenType.Property">
      <summary>
            Property definition (<see cref="T:PostSharp.CodeModel.PropertyDeclaration" />).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TokenType.MethodSemantic">
      <summary>
            Method semantic (<see cref="T:PostSharp.CodeModel.MethodSemanticDeclaration" />).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TokenType.MethodImpl">
      <summary>
            Method implementation (<see cref="T:PostSharp.CodeModel.MethodImplementationDeclaration" />).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TokenType.ModuleRef">
      <summary>
            Module reference (<see cref="T:PostSharp.CodeModel.ModuleRefDeclaration" />).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TokenType.TypeSpec">
      <summary>
            Type specification (<see cref="T:PostSharp.CodeModel.TypeSpecDeclaration" />).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TokenType.Assembly">
      <summary>
            Assembly manifest (<see cref="T:PostSharp.CodeModel.AssemblyManifestDeclaration" />).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TokenType.AssemblyRef">
      <summary>
            Assembly reference (<see cref="T:PostSharp.CodeModel.AssemblyRefDeclaration" />).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TokenType.File">
      <summary>
            External file reference (<see cref="T:PostSharp.CodeModel.ManifestFileDeclaration" />).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TokenType.ExportedType">
      <notSupported />
    </member>
    <member name="F:PostSharp.CodeModel.TokenType.ManifestResource">
      <summary>
            Resource declaration or reference (<see cref="T:PostSharp.CodeModel.ManifestResourceDeclaration" />).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TokenType.GenericParam">
      <summary>
            Generic parameter (<see cref="T:PostSharp.CodeModel.GenericParameterDeclaration" />).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TokenType.GenericPar">
      <summary>
            Synonym for <see cref="F:PostSharp.CodeModel.TokenType.GenericParam" />).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TokenType.MethodSpec">
      <summary>
            Method specification (<see cref="T:PostSharp.CodeModel.MethodSpecDeclaration" />).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TokenType.GenericParamConstraint">
      <summary>
            Constraint on a generic parameter (<see cref="T:PostSharp.CodeModel.GenericParameterDeclaration" />.<see cref="P:PostSharp.CodeModel.GenericParameterDeclaration.Constraints" />.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TokenType.String">
      <summary>
            User string (<see cref="T:PostSharp.CodeModel.LiteralString" />).
            </summary>
      <remarks>
            The low bytes of string tokens represent the string RVA.
            </remarks>
    </member>
    <member name="F:PostSharp.CodeModel.TokenType.CustomString">
      <internal />
      <summary>
            Custom string (<see cref="T:PostSharp.CodeModel.CustomStringDeclaration" />).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TokenType.WeaklyReferencedDeclaration">
      <summary>
            Non-linked declaration (see <see cref="M:PostSharp.CodeModel.MetadataDeclarationTables.AddWeaklyReferencedDeclaration(PostSharp.CodeModel.MetadataDeclaration)" />.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.TokenType.TableCount">
      <summary>
            Number of token types that are represented as a table in <see cref="T:PostSharp.CodeModel.MetadataDeclarationTables" />.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.GenericParameterDeclaration">
      <summary>
            Represents a generic parameter (<see cref="F:PostSharp.CodeModel.TokenType.GenericParam" />). 
            </summary>
      <remarks>
            Generic parameters
            are owned by types (<see cref="T:PostSharp.CodeModel.TypeDefDeclaration" />) or 
            methods (<see cref="T:PostSharp.CodeModel.MethodDefDeclaration" />).
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.GenericParameterDeclaration.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.GenericParameterDeclaration" />.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.GenericParameterDeclaration.GetTokenType" />
    <member name="M:PostSharp.CodeModel.GenericParameterDeclaration.ToString" />
    <member name="M:PostSharp.CodeModel.GenericParameterDeclaration.GetReference">
      <summary>
            Gets the <see cref="T:PostSharp.CodeModel.TypeSignatures.GenericParameterTypeSignature" /> that references to the current
            instance.
            </summary>
      <returns>A <see cref="T:PostSharp.CodeModel.TypeSignatures.GenericParameterTypeSignature" /> with same ordinal and
            kind as the current instance.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.GenericParameterDeclaration.BelongsToClassification(PostSharp.CodeModel.TypeClassifications)">
      <summary>
            Determines whether the type signature belongs to a given classification,
            i.e. whether it fulfills a given predicate.
            </summary>
      <param name="typeClassification">The classification (or predicate) 
            (combination of bits are not allowed).</param>
      <returns>
        <see cref="F:PostSharp.NullableBool.True" /> if the predicate is true, 
            <see cref="F:PostSharp.NullableBool.False" /> if the predicate is false or
            <see cref="F:PostSharp.NullableBool.Null" /> if it cannot be determined. </returns>
    </member>
    <member name="M:PostSharp.CodeModel.GenericParameterDeclaration.MapGenericArguments(PostSharp.CodeModel.GenericMap)">
      <summary>
            Resolves all generic arguments in the current type signature.
            </summary>
      <param name="genericMap">Generic context in which generic arguments have to be resolved.</param>
      <returns>A <see cref="T:PostSharp.CodeModel.IType" /> resolved against <paramref name="genericMap" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.GenericParameterDeclaration.Equals(PostSharp.CodeModel.GenericParameterDeclaration,System.Boolean)">
      <summary>
            Compares the current <see cref="T:PostSharp.CodeModel.GenericParameterDeclaration" /> with an other.
            </summary>
      <param name="other">Another <see cref="T:PostSharp.CodeModel.GenericParameterDeclaration" />.</param>
      <param name="compareConstraints">
        <b>true</b> if constraints of generic parameters
            have to be compared also, otherwise <b>false</b>.</param>
      <returns>
        <b>true</b> if both generic parameters are equal, otherwise <b>false</b>.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.GenericParameterDeclaration.Equals(PostSharp.CodeModel.ITypeSignature)" />
    <member name="M:PostSharp.CodeModel.GenericParameterDeclaration.MatchesReference(PostSharp.CodeModel.ITypeSignature)">
      <summary>
            Determines whether the current type signature matches a given type signature.
            </summary>
      <param name="reference">The type reference.</param>
      <returns>
        <b>true</b> if the current type signature matches <paramref name="reference" />,
            otherwise <b>false</b>.</returns>
      <remarks>A type reference can use an incomplete assembly reference. Therefore, the matching
            is performed using <see cref="M:PostSharp.CodeModel.IAssembly.MatchesReference(PostSharp.CodeModel.IAssemblyName)" />.
            Matching an assembly reference is a looser requirement than matching an assembly name exactly;
            an assembly reference may set no requirement on the public key token or the version, for instance.</remarks>
    </member>
    <member name="M:PostSharp.CodeModel.GenericParameterDeclaration.IsAssignableTo(PostSharp.CodeModel.ITypeSignature,PostSharp.CodeModel.GenericMap)" />
    <member name="M:PostSharp.CodeModel.GenericParameterDeclaration.IsAssignableTo(PostSharp.CodeModel.ITypeSignature)" />
    <member name="M:PostSharp.CodeModel.GenericParameterDeclaration.GetCanonicalHashCode">
      <summary>
            Gets a hash code that is invariant under type signature equality
            (i.e. if two types are equal under <see cref="T:System.IEquatable`1" />, they have the
            same canonical has code).
            </summary>
      <returns>A hash code that is invariant under type signature equality.</returns>
      <remarks>This method is of course useful to build dictionaries. The <see cref="T:PostSharp.CodeModel.Binding.TypeComparer" /> class
            uses this method.</remarks>
    </member>
    <member name="M:PostSharp.CodeModel.GenericParameterDeclaration.GetValueSize(PostSharp.CodeModel.PlatformInfo)">
      <summary>
            Gets the size of the value type.
            </summary>
      <param name="platform">Information about the target platform.</param>
      <returns>The size of the value type in bytes, or -1 if the
            type is not a value type or has no fixed size.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.GenericParameterDeclaration.GetSystemType(System.Type[],System.Type[])">
      <summary>
            Gets the system, runtime <see cref="T:System.Type" /> corresponding to the current type.
            </summary>
      <param name="genericTypeArguments">Array of generic type arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <param name="genericMethodArguments">Array of generic method arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <returns>The system <see cref="T:System.Type" /> associated the current type in the
            given generic context.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.GenericParameterDeclaration.GetReflectionWrapper(System.Type[],System.Type[])">
      <summary>
            Gets a reflection <see cref="T:System.Type" /> that wraps the current type.
            </summary>
      <param name="genericTypeArguments">Array of generic type arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <param name="genericMethodArguments">Array of generic method arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <returns>A <see cref="T:System.Type" /> wrapping current type in the
            given generic context.</returns>
      <remarks>
            This method returns a <see cref="T:System.Type" /> that is different from the system
            runtime type that is retrieved by <see cref="M:PostSharp.CodeModel.ITypeSignature.GetSystemType(System.Type[],System.Type[])" />. This allows
            a have a <b>System.Reflection</b> representation of the current type even
            when it cannot be loaded in the Virtual Runtime Engine.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.GenericParameterDeclaration.Translate(PostSharp.CodeModel.ModuleDeclaration)">
      <summary>
            Translates the current type signature so that it is meaningful in another
            module than the one to which it primarly belong.
            </summary>
      <param name="targetModule">Module into which the type signature should be
            translated.</param>
      <returns>A type signature meaningful in the <paramref name="targetModule" />
            module.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.GenericParameterDeclaration.WriteReflectionTypeName(System.Text.StringBuilder,PostSharp.CodeModel.ReflectionNameOptions)">
      <summary>
            Gets the type name as used in <b>System.Reflection</b>.
            </summary>
      <returns>A <see cref="T:System.String" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.GenericParameterDeclaration.Clone(PostSharp.CodeModel.ModuleDeclaration,PostSharp.CodeModel.GenericMap)">
      <summary>
            Clones the current instance and makes the clone compatible within a given module.
            </summary>
      <param name="targetModule">Module in which the clone should be meaningfull.</param>
      <param name="genericMap">Generic map with which constraints are transformed.</param>
      <returns>A <see cref="T:PostSharp.CodeModel.GenericParameterDeclaration" /> meaningfull in <paramref name="targetModule" />.</returns>
      <remarks>This method does not clone the constraints.</remarks>
    </member>
    <member name="P:PostSharp.CodeModel.GenericParameterDeclaration.Kind">
      <summary>
            Gets the kind of generic parameters (<see cref="F:PostSharp.CodeModel.GenericParameterKind.Type" /> 
            or <see cref="F:PostSharp.CodeModel.GenericParameterKind.Method" />).
            </summary>
      <value>
            A <see cref="T:PostSharp.CodeModel.GenericParameterKind" />.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.GenericParameterDeclaration.Ordinal">
      <summary>
            Gets or sets the generic parameter ordinal.
            </summary>
      <value>
            The ordinal of the current generic parameter,
            i.e. its position in its parent collection.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.GenericParameterDeclaration.Attributes">
      <summary>
            Gets or sets the attributes of the generic parameter. 
            </summary>
      <value>
            A combination of <see cref="T:System.Reflection.GenericParameterAttributes" />.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.GenericParameterDeclaration.Constraints">
      <summary>
            Gets the list of type constraints applying on the type parameter. 
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.GenericParameterDeclaration.DeclaringGenericDefinition">
      <summary>
            Gets the <see cref="T:PostSharp.CodeModel.IGenericDefinition" /> that declares the current
            generic parameter.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.Collections.GenericParameterDeclarationCollection">
      <summary>
            Collection of generic parameters (<see cref="T:PostSharp.CodeModel.GenericParameterDeclaration" />).
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.GenericParameterDeclarationCollection.DoLazyLoading" />
    <member name="P:PostSharp.CodeModel.Collections.GenericParameterDeclarationCollection.IsLazyLoadingSupported" />
    <member name="T:PostSharp.CodeModel.MethodSignature">
      <summary>
            Represents a method signature, which specifies primarly a calling convention and 
            the type of parameters.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.MethodSignature.#ctor(PostSharp.CodeModel.ModuleDeclaration)">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.MethodSignature" />.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.MethodSignature.#ctor(PostSharp.CodeModel.IMethodSignature)">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.MethodSignature" /> from an existing <see cref="T:PostSharp.CodeModel.IMethodSignature" />.
            </summary>
      <param name="signature">The signature to copy.</param>
    </member>
    <member name="M:PostSharp.CodeModel.MethodSignature.#ctor(PostSharp.CodeModel.ModuleDeclaration,PostSharp.CodeModel.CallingConvention,PostSharp.CodeModel.ITypeSignature,System.Collections.Generic.ICollection{PostSharp.CodeModel.ITypeSignature},System.Int32)">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.MethodSignature" />.
            </summary>
      <param name="module">Module to which the new signature belongs.</param>
      <param name="callingConvention">Calling convention.</param>
      <param name="returnType">Return type.</param>
      <param name="parameterTypes">Parameter types (the content of the current collection
            is copied, i.e. the collection is not copied by reference).</param>
      <param name="genericParameterCount">Number of generic parameters (<i>arity</i>).</param>
    </member>
    <member name="M:PostSharp.CodeModel.MethodSignature.MatchesReference(PostSharp.CodeModel.IMethodSignature)">
      <summary>
            Determines whether the current method signature matches a given method signature reference.
            </summary>
      <param name="reference">The method signature reference.</param>
      <returns>
        <b>true</b> if the current method signature matches <paramref name="reference" />,
            otherwise <b>false</b>.</returns>
      <remarks>A method signature reference can use an incomplete assembly reference. Therefore, the matching
            is performed using <see cref="M:PostSharp.CodeModel.IAssembly.MatchesReference(PostSharp.CodeModel.IAssemblyName)" />.
            Matching an assembly reference is a looser requirement than matching an assembly name exactly;
            an assembly reference may set no requirement on the public key token or the version, for instance.</remarks>
    </member>
    <member name="M:PostSharp.CodeModel.MethodSignature.Visit(System.String,PostSharp.Collections.Visitor{PostSharp.CodeModel.ITypeSignature})">
      <summary>
            Requires a callback method (named <i>visitor</i>) to be called
            for each item of a given role in the current object, recursively.
            </summary>
      <param name="role">Role of items to be visited, or <b>null</b> if all items
            of type <typeparamref name="T" /> should be visited.</param>
      <param name="visitor">Delegate that should be called when an
            item in the given role is found.</param>
    </member>
    <member name="M:PostSharp.CodeModel.MethodSignature.Equals(PostSharp.CodeModel.IMethodSignature)" />
    <member name="M:PostSharp.CodeModel.MethodSignature.ToString" />
    <member name="M:PostSharp.CodeModel.MethodSignature.ReferencesAnyGenericArgument">
      <summary>
            Determines whether generic arguments are used in the current signature.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.MethodSignature.MapGenericArguments(PostSharp.CodeModel.GenericMap)">
      <summary>
            Resolves all generic arguments in the current method signature.
            </summary>
      <param name="genericMap">Generic context in which generic arguments have to be resolved.</param>
      <returns>A method signature resolved against <paramref name="genericMap" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.MethodSignature.Translate(PostSharp.CodeModel.ModuleDeclaration)">
      <summary>
            Translates the current method signature so that it is meaningful in another
            module than the one to which it primarly belong.
            </summary>
      <param name="targetModule">Module into which the type signature should be
            translated.</param>
      <returns>A method signature meaningful in the <paramref name="targetModule" />
            module.</returns>
    </member>
    <member name="P:PostSharp.CodeModel.MethodSignature.Module">
      <summary>
            Gets the declaring module.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodSignature.DeclaringAssembly">
      <summary>
            Gets the declaring assembly.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodSignature.GenericParameterCount">
      <summary>
            Gets or sets the arity, i.e. the number of generic method parameters.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodSignature.CallingConvention">
      <summary>
            Gets or sets the calling convention.
            </summary>
      <value>
            A <see cref="P:PostSharp.CodeModel.MethodSignature.CallingConvention" />.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.MethodSignature.ReturnType">
      <summary>
            Gets or sets the return type.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodSignature.ParameterTypes">
      <summary>
            Gets the collection of parameter types.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodSignature.VariableParameterTypes">
      <summary>
            Gets the collection of variable parameters types
            (i.e. the parameters sent as the list of unknown
            parameters of a <b>vararg</b> method.
            </summary>
      <exception cref="T:System.InvalidOperationException">
            	The calling convention is not <see cref="F:PostSharp.CodeModel.CallingConvention.VarArg" />.
            </exception>
    </member>
    <member name="T:PostSharp.CodeModel.OpCodeDictionary`1">
      <summary>
            Efficient implementation of a dictionary taking an <see cref="T:PostSharp.CodeModel.OpCodeNumber" />
            as the key type.
            </summary>
      <typeparam name="T">Value type.</typeparam>
    </member>
    <member name="M:PostSharp.CodeModel.OpCodeDictionary`1.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.OpCodeDictionary`1" />.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.OpCodeDictionary`1.GetValue(PostSharp.CodeModel.OpCodeNumber)">
      <summary>
            Gets a value associated with an <see cref="T:PostSharp.CodeModel.OpCodeNumber" />.
            </summary>
      <param name="opCode">An <see cref="T:PostSharp.CodeModel.OpCodeNumber" />.</param>
      <returns>The value associated to <paramref name="opCode" />, or the
            default value of <typeparamref name="T" /> if no value is associated
            with <paramref name="opCode" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.OpCodeDictionary`1.SetValue(PostSharp.CodeModel.OpCodeNumber,`0)">
      <summary>
            Sets a value associated with an <see cref="T:PostSharp.CodeModel.OpCodeNumber" />.
            </summary>
      <param name="opCode">An <see cref="T:PostSharp.CodeModel.OpCodeNumber" />.</param>
      <param name="value">The value associated with <paramref name="opCode" />.</param>
    </member>
    <member name="T:PostSharp.CodeModel.InstructionSequence">
      <summary>
            Represents a sequence of instructions without branches, i.e. the control flow
            necessarly begins at the beginning of the sequence and ends at the end 
            of the sequence.
            </summary>
      <remarks>
            By default, PostSharp only analyzes the normal control flow on the base of
            branching instructions, i.e. it ignores the control flow caused by exceptions.
            So it is possible that, in case of exception, the sequence is left from
            an textWriter point instead of from the last instruction.
            </remarks>
      <devDoc>
        <para>
            The bytes of an <see cref="T:PostSharp.CodeModel.InstructionSequence" /> can be represented in
            two ways:
            </para>
        <list type="bullet">
          <item>
            <term>Original</term>
            <description>When the instruction sequence is read from the PE file,
            		the instructions are stored in the original image of the PE file.
            		The <see cref="F:PostSharp.CodeModel.InstructionSequence.startOffset" /> and <see cref="F:PostSharp.CodeModel.InstructionSequence.endOffset" /> fields,
            		relative to the first instructon of the method body, indicate
            		the start and the end of the current sequence.</description>
          </item>
          <item>
            <term>Modified</term>
            <description>If the instruction sequence is modified or is created,
            		it is stored in the <see cref="F:PostSharp.CodeModel.InstructionSequence.modifiedInstructionBytes" /> array
            		of bytes.</description>
          </item>
        </list>
      </devDoc>
    </member>
    <member name="M:PostSharp.CodeModel.InstructionSequence.ToString" />
    <member name="M:PostSharp.CodeModel.InstructionSequence.SplitAfterReaderPosition(PostSharp.CodeModel.InstructionReader)">
      <summary>
            Splits the current sequence after the position of an <see cref="T:PostSharp.CodeModel.InstructionReader" />,
            and returns a new <see cref="T:PostSharp.CodeModel.InstructionSequence" /> containing the second
            part of the sequence.
            </summary>
      <param name="reader">An <see cref="T:PostSharp.CodeModel.InstructionReader" /> positioned 
            on the current <see cref="T:PostSharp.CodeModel.InstructionSequence" />.</param>
      <returns>The <see cref="T:PostSharp.CodeModel.InstructionSequence" /> containing the second part
            of the sequence, or <b>null</b> if <paramref name="reader" /> is at
            the end of the sequence.</returns>
      <exception cref="T:System.InvalidOperationException">The <see cref="T:PostSharp.CodeModel.InstructionReader" />
            is not positioned at the current <see cref="T:PostSharp.CodeModel.InstructionSequence" />.
            </exception>
    </member>
    <member name="M:PostSharp.CodeModel.InstructionSequence.SplitAroundReaderPosition(PostSharp.CodeModel.InstructionReader,PostSharp.CodeModel.InstructionSequence@,PostSharp.CodeModel.InstructionSequence@)">
      <summary>
            Splits the current <see cref="T:PostSharp.CodeModel.InstructionSequence" /> in maximally three sequences, one
            containing the instructions before the current instruction of a given <see cref="T:PostSharp.CodeModel.InstructionReader" />,
            one containing only the current
            instruction and one containing the instructions after the current instruction.
            </summary>
      <param name="reader">
        <see cref="T:PostSharp.CodeModel.InstructionReader" /> positioned in the current <see cref="T:PostSharp.CodeModel.InstructionSequence" />.</param>
      <param name="sequenceBefore">Returns a new sequence containing all instructions before the current one,
            or <b>null</b> if the current instruction is the first one.</param>
      <param name="sequenceAfter">Returns a new sequence containing all instructions after the current one,
            or <b>null</b> if the current instruction is the last one.</param>
      <remarks>
            After having called this method, the current sequence contains only the current instruction
            of <see cref="T:PostSharp.CodeModel.InstructionReader" />.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.InstructionSequence.Detach">
      <summary>
            Detaches the current <see cref="T:PostSharp.CodeModel.InstructionSequence" /> from its 
            parent <see cref="T:PostSharp.CodeModel.InstructionBlock" />.
            </summary>
      <remarks>
            This method does not detaches the <see cref="T:PostSharp.CodeModel.InstructionSequence" /> to the
            <see cref="T:PostSharp.CodeModel.MethodBodyDeclaration" /> to which it belongs. Note that the state
            of the instruction stream may be inconsistent after calling this method, because
            instructions may still reference the current <see cref="T:PostSharp.CodeModel.InstructionSequence" />
            as a branch target. In order to redirect branch targets, call the
            <see cref="M:PostSharp.CodeModel.InstructionSequence.Remove(PostSharp.CodeModel.InstructionSequence)" />  or <see cref="M:PostSharp.CodeModel.InstructionSequence.Redirect(PostSharp.CodeModel.InstructionSequence)" /> method.
            </remarks>
      <exception cref="T:System.InvalidOperationException">The instruction sequence
            is not attached.</exception>
    </member>
    <member name="M:PostSharp.CodeModel.InstructionSequence.Remove(PostSharp.CodeModel.InstructionSequence)">
      <summary>
            Removes the current <see cref="T:PostSharp.CodeModel.InstructionSequence" /> from 
            the <see cref="T:PostSharp.CodeModel.MethodBodyDeclaration" /> to which it belongs, and
            optionally redirects to another <see cref="T:PostSharp.CodeModel.InstructionSequence" />
            all branching targets to the current <see cref="T:PostSharp.CodeModel.InstructionSequence" /></summary>
      <param name="redirectInstructionSequence">
        <see cref="T:PostSharp.CodeModel.InstructionSequence" />
            to which branches to the current sequence should be redirected, or <b>null</b>
            if branching targets should not be redirected.
            </param>
      <remarks>
            This method has the effect of disposing the current <see cref="T:PostSharp.CodeModel.InstructionSequence" />.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.InstructionSequence.Remove">
      <summary>
            Removes the current <see cref="T:PostSharp.CodeModel.InstructionSequence" /> from 
            the <see cref="T:PostSharp.CodeModel.MethodBodyDeclaration" /> to which it belongs, but does not
            redirect branching targets.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.InstructionSequence.Redirect(PostSharp.CodeModel.InstructionSequence)">
      <summary>
            Redirects to another <see cref="T:PostSharp.CodeModel.InstructionSequence" /> all branch targets
            currently referencing the current <see cref="T:PostSharp.CodeModel.InstructionSequence" />.
            </summary>
      <param name="newSequence">The <see cref="T:PostSharp.CodeModel.InstructionSequence" /> that should
            become the new target.</param>
    </member>
    <member name="M:PostSharp.CodeModel.InstructionSequence.CheckInstructions">
      <summary>
            Checks whether the instruction stream can be read.
            </summary>
      <remarks>
            Should be used only in debugging scenarios. 
            Conditional to the DEBUG compilation symbol.
            </remarks>
    </member>
    <member name="P:PostSharp.CodeModel.InstructionSequence.MethodBody">
      <summary>
            Gets the <see cref="T:PostSharp.CodeModel.MethodBodyDeclaration" /> to which the current
            instance is related.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.InstructionSequence.NextSiblingSequence">
      <summary>
            Gets the next sibling <see cref="T:PostSharp.CodeModel.InstructionSequence" />.
            </summary>
      <value>
            An <see cref="T:PostSharp.CodeModel.InstructionSequence" /> having the same parent <see cref="T:PostSharp.CodeModel.InstructionBlock" />,
            or <b>null</b> if the current sequence is the last of its block.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.InstructionSequence.NextDeepSequence">
      <summary>
            Gets the next <see cref="T:PostSharp.CodeModel.InstructionSequence" /> in the current <see cref="T:PostSharp.CodeModel.InstructionBlock" />
            or in the next sibling <see cref="T:PostSharp.CodeModel.InstructionBlock" />.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.InstructionSequence.PreviousSiblingSequence">
      <summary>
            Gets the previous sibling <see cref="T:PostSharp.CodeModel.InstructionSequence" />.
            </summary>
      <value>
            An <see cref="T:PostSharp.CodeModel.InstructionSequence" /> having the same parent <see cref="T:PostSharp.CodeModel.InstructionBlock" />,
            or <b>null</b> if the current sequence is the first of its block.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.InstructionSequence.IsOriginal">
      <summary>
            Determines whether the current instruction sequence is original, i.e.
            whether it was unmodified from the original module.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.InstructionSequence.Comment">
      <summary>
            Gets or sets the comment on this instruction sequence.
            </summary>
      <remarks>
            This comment will be written in MSIL output. This is for
            code weaver debugging only.
            </remarks>
    </member>
    <member name="P:PostSharp.CodeModel.InstructionSequence.Token">
      <summary>
            Gets the instruction sequence token.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.InstructionSequence.ParentInstructionBlock">
      <summary>
            Gets the block to which the current sequences belongs.
            </summary>
      <value>
            An <see cref="T:PostSharp.CodeModel.InstructionBlock" />, or <b>null</b> if the current
            <see cref="T:PostSharp.CodeModel.InstructionSequence" /> is detached.
            </value>
    </member>
    <member name="T:PostSharp.CodeModel.InstructionPrefixes">
      <summary>
            Enumeration of IL prefixes.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.InstructionPrefixes.None">
      <summary>
            No prefix.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.InstructionPrefixes.Unaligned1">
      <summary>
            Indicates that a pointer instruction might be unaligned
            to the natural size of the following instruction operand.
            The runtime should assume that the pointer instruction
            is aligned at <b>byte</b> boundary.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.InstructionPrefixes.Unaligned2">
      <summary>
            Indicates that a pointer instruction might be unaligned
            to the natural size of the following instruction operand.
            The runtime should assume that the pointer instruction
            is aligned at <b>2 bytes</b> boundary.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.InstructionPrefixes.Unaligned4">
      <summary>
            Indicates that a pointer instruction might be unaligned
            to the natural size of the following instruction operand.
            The runtime should assume that the pointer instruction
            is aligned at <b>4 bytes</b> boundary.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.InstructionPrefixes.UnalignedMask">
      <summary>
            Masks isolating the unaligned prefixes.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.InstructionPrefixes.Volatile">
      <summary>
            Indicates that the content of the read location is volatile
            and cannot be cached for later access.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.InstructionPrefixes.Tail">
      <summary>
            Indicates that the method could be terminated after the
            next call instruction.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.InstructionPrefixes.Constrained">
      <summary>
            Indicates that the virtual call of the next instruction
            is constrained to a given type.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.InstructionPrefixes.ReadOnly">
      <summary>
            Tndicates that the subsequent array address operation performs no
            type check at runtime, and that it returns a controlled-mutability
            managed pointer
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.IntrinsicType">
      <summary>
            Enumeration of primitive types of the .NET runtime.
            This includes intrincic types.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.IntrinsicType.Void">
      <summary>
        <see cref="T:System.Void" />.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.IntrinsicType.Object">
      <summary>
        <see cref="T:System.Object" />.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.IntrinsicType.Boolean">
      <summary>
        <see cref="T:System.Boolean" />.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.IntrinsicType.Char">
      <summary>
        <see cref="T:System.Char" />.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.IntrinsicType.SByte">
      <summary>
        <see cref="T:System.SByte" />.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.IntrinsicType.Byte">
      <summary>
        <see cref="T:System.Byte" />.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.IntrinsicType.Int16">
      <summary>
        <see cref="T:System.Int16" />.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.IntrinsicType.UInt16">
      <summary>
        <see cref="T:System.UInt16" />.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.IntrinsicType.Int32">
      <summary>
        <see cref="T:System.Int32" />.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.IntrinsicType.UInt32">
      <summary>
        <see cref="T:System.UInt32" />.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.IntrinsicType.Int64">
      <summary>
        <see cref="T:System.Int64" />.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.IntrinsicType.UInt64">
      <summary>
        <see cref="T:System.UInt64" />.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.IntrinsicType.Single">
      <summary>
        <see cref="T:System.Single" />.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.IntrinsicType.Double">
      <summary>
        <see cref="T:System.Double" />.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.IntrinsicType.String">
      <summary>
        <see cref="T:System.String" />.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.IntrinsicType.IntPtr">
      <summary>
        <see cref="T:System.IntPtr" /> (not serializable).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.IntrinsicType.UIntPtr">
      <summary>
        <see cref="T:System.UIntPtr" />  (not serializable).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.IntrinsicType.NativeReal">
      <summary>
            Real number with platform-specific precision  (not serializable).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.IntrinsicType.TypedReference">
      <summary>
        <see cref="T:System.TypedReference" /> (not serializable).
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.IntrinsicType.Null">
      <summary>
            Null value. 
            </summary>
      <remarks>
            This is not a valid type of the CLR! This is only usefull
            for static analysis.
            </remarks>
    </member>
    <member name="F:PostSharp.CodeModel.IntrinsicType.Token">
      <summary>
            Metadata token. 
            </summary>
      <remarks>
            This is not a valid type of the CLR! This is only usefull
            for static analysis.
            </remarks>
    </member>
    <member name="T:PostSharp.CodeModel.OpCodeNumber">
      <summary>Enumeration of all opcode numbers.</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Nop">
      <summary>0x00	nop</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Break">
      <summary>0x01	break</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldarg_0">
      <summary>0x02	ldarg.0</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldarg_1">
      <summary>0x03	ldarg.1</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldarg_2">
      <summary>0x04	ldarg.2</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldarg_3">
      <summary>0x05	ldarg.3</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldloc_0">
      <summary>0x06	ldloc.0</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldloc_1">
      <summary>0x07	ldloc.1</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldloc_2">
      <summary>0x08	ldloc.2</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldloc_3">
      <summary>0x09	ldloc.3</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Stloc_0">
      <summary>0x0A	stloc.0</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Stloc_1">
      <summary>0x0B	stloc.1</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Stloc_2">
      <summary>0x0C	stloc.2</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Stloc_3">
      <summary>0x0D	stloc.3</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldarg_S">
      <summary>0x0E	ldarg.s</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldarga_S">
      <summary>0x0F	ldarga.s</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Starg_S">
      <summary>0x10	starg.s</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldloc_S">
      <summary>0x11	ldloc.s</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldloca_S">
      <summary>0x12	ldloca.s</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Stloc_S">
      <summary>0x13	stloc.s</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldnull">
      <summary>0x14	ldnull</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldc_I4_M1">
      <summary>0x15	ldc.i4.m1</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldc_I4_0">
      <summary>0x16	ldc.i4.0</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldc_I4_1">
      <summary>0x17	ldc.i4.1</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldc_I4_2">
      <summary>0x18	ldc.i4.2</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldc_I4_3">
      <summary>0x19	ldc.i4.3</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldc_I4_4">
      <summary>0x1A	ldc.i4.4</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldc_I4_5">
      <summary>0x1B	ldc.i4.5</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldc_I4_6">
      <summary>0x1C	ldc.i4.6</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldc_I4_7">
      <summary>0x1D	ldc.i4.7</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldc_I4_8">
      <summary>0x1E	ldc.i4.8</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldc_I4_S">
      <summary>0x1F	ldc.i4.s</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldc_I4">
      <summary>0x20	ldc.i4</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldc_I8">
      <summary>0x21	ldc.i8</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldc_R4">
      <summary>0x22	ldc.r4</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldc_R8">
      <summary>0x23	ldc.r8</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Dup">
      <summary>0x25	dup</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Pop">
      <summary>0x26	pop</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Jmp">
      <summary>0x27	jmp</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Call">
      <summary>0x28	call</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Calli">
      <summary>0x29	calli</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ret">
      <summary>0x2A	ret</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Br_S">
      <summary>0x2B	br.s</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Brfalse_S">
      <summary>0x2C	brfalse.s</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Brtrue_S">
      <summary>0x2D	brtrue.s</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Beq_S">
      <summary>0x2E	beq.s</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Bge_S">
      <summary>0x2F	bge.s</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Bgt_S">
      <summary>0x30	bgt.s</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ble_S">
      <summary>0x31	ble.s</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Blt_S">
      <summary>0x32	blt.s</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Bne_Un_S">
      <summary>0x33	bne.un.s</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Bge_Un_S">
      <summary>0x34	bge.un.s</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Bgt_Un_S">
      <summary>0x35	bgt.un.s</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ble_Un_S">
      <summary>0x36	ble.un.s</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Blt_Un_S">
      <summary>0x37	blt.un.s</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Br">
      <summary>0x38	br</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Brfalse">
      <summary>0x39	brfalse</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Brtrue">
      <summary>0x3A	brtrue</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Beq">
      <summary>0x3B	beq</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Bge">
      <summary>0x3C	bge</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Bgt">
      <summary>0x3D	bgt</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ble">
      <summary>0x3E	ble</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Blt">
      <summary>0x3F	blt</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Bne_Un">
      <summary>0x40	bne.un</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Bge_Un">
      <summary>0x41	bge.un</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Bgt_Un">
      <summary>0x42	bgt.un</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ble_Un">
      <summary>0x43	ble.un</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Blt_Un">
      <summary>0x44	blt.un</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Switch">
      <summary>0x45	switch</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldind_I1">
      <summary>0x46	ldind.i1</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldind_U1">
      <summary>0x47	ldind.u1</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldind_I2">
      <summary>0x48	ldind.i2</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldind_U2">
      <summary>0x49	ldind.u2</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldind_I4">
      <summary>0x4A	ldind.i4</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldind_U4">
      <summary>0x4B	ldind.u4</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldind_I8">
      <summary>0x4C	ldind.i8</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldind_I">
      <summary>0x4D	ldind.i</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldind_R4">
      <summary>0x4E	ldind.r4</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldind_R8">
      <summary>0x4F	ldind.r8</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldind_Ref">
      <summary>0x50	ldind.ref</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Stind_Ref">
      <summary>0x51	stind.ref</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Stind_I1">
      <summary>0x52	stind.i1</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Stind_I2">
      <summary>0x53	stind.i2</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Stind_I4">
      <summary>0x54	stind.i4</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Stind_I8">
      <summary>0x55	stind.i8</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Stind_R4">
      <summary>0x56	stind.r4</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Stind_R8">
      <summary>0x57	stind.r8</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Add">
      <summary>0x58	add</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Sub">
      <summary>0x59	sub</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Mul">
      <summary>0x5A	mul</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Div">
      <summary>0x5B	div</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Div_Un">
      <summary>0x5C	div.un</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Rem">
      <summary>0x5D	rem</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Rem_Un">
      <summary>0x5E	rem.un</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.And">
      <summary>0x5F	and</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Or">
      <summary>0x60	or</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Xor">
      <summary>0x61	xor</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Shl">
      <summary>0x62	shl</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Shr">
      <summary>0x63	shr</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Shr_Un">
      <summary>0x64	shr.un</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Neg">
      <summary>0x65	neg</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Not">
      <summary>0x66	not</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Conv_I1">
      <summary>0x67	conv.i1</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Conv_I2">
      <summary>0x68	conv.i2</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Conv_I4">
      <summary>0x69	conv.i4</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Conv_I8">
      <summary>0x6A	conv.i8</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Conv_R4">
      <summary>0x6B	conv.r4</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Conv_R8">
      <summary>0x6C	conv.r8</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Conv_U4">
      <summary>0x6D	conv.u4</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Conv_U8">
      <summary>0x6E	conv.u8</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Callvirt">
      <summary>0x6F	callvirt</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Cpobj">
      <summary>0x70	cpobj</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldobj">
      <summary>0x71	ldobj</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldstr">
      <summary>0x72	ldstr</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Newobj">
      <summary>0x73	newobj</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Castclass">
      <summary>0x74	castclass</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Isinst">
      <summary>0x75	isinst</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Conv_R_Un">
      <summary>0x76	conv.r.un</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Unbox">
      <summary>0x79	unbox</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Throw">
      <summary>0x7A	throw</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldfld">
      <summary>0x7B	ldfld</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldflda">
      <summary>0x7C	ldflda</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Stfld">
      <summary>0x7D	stfld</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldsfld">
      <summary>0x7E	ldsfld</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldsflda">
      <summary>0x7F	ldsflda</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Stsfld">
      <summary>0x80	stsfld</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Stobj">
      <summary>0x81	stobj</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Conv_Ovf_I1_Un">
      <summary>0x82	conv.ovf.i1.un</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Conv_Ovf_I2_Un">
      <summary>0x83	conv.ovf.i2.un</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Conv_Ovf_I4_Un">
      <summary>0x84	conv.ovf.i4.un</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Conv_Ovf_I8_Un">
      <summary>0x85	conv.ovf.i8.un</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Conv_Ovf_U1_Un">
      <summary>0x86	conv.ovf.u1.un</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Conv_Ovf_U2_Un">
      <summary>0x87	conv.ovf.u2.un</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Conv_Ovf_U4_Un">
      <summary>0x88	conv.ovf.u4.un</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Conv_Ovf_U8_Un">
      <summary>0x89	conv.ovf.u8.un</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Conv_Ovf_I_Un">
      <summary>0x8A	conv.ovf.i.un</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Conv_Ovf_U_Un">
      <summary>0x8B	conv.ovf.u.un</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Box">
      <summary>0x8C	box</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Newarr">
      <summary>0x8D	newarr</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldlen">
      <summary>0x8E	ldlen</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldelema">
      <summary>0x8F	ldelema</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldelem_I1">
      <summary>0x90	ldelem.i1</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldelem_U1">
      <summary>0x91	ldelem.u1</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldelem_I2">
      <summary>0x92	ldelem.i2</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldelem_U2">
      <summary>0x93	ldelem.u2</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldelem_I4">
      <summary>0x94	ldelem.i4</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldelem_U4">
      <summary>0x95	ldelem.u4</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldelem_I8">
      <summary>0x96	ldelem.i8</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldelem_I">
      <summary>0x97	ldelem.i</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldelem_R4">
      <summary>0x98	ldelem.r4</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldelem_R8">
      <summary>0x99	ldelem.r8</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldelem_Ref">
      <summary>0x9A	ldelem.ref</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Stelem_I">
      <summary>0x9B	stelem.i</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Stelem_I1">
      <summary>0x9C	stelem.i1</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Stelem_I2">
      <summary>0x9D	stelem.i2</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Stelem_I4">
      <summary>0x9E	stelem.i4</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Stelem_I8">
      <summary>0x9F	stelem.i8</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Stelem_R4">
      <summary>0xA0	stelem.r4</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Stelem_R8">
      <summary>0xA1	stelem.r8</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Stelem_Ref">
      <summary>0xA2	stelem.ref</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldelem">
      <summary>0xA3   ldelem</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Stelem">
      <summary>0xA4   stelem</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Unbox_Any">
      <summary>0xA5   unbox.any</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Conv_Ovf_I1">
      <summary>0xB3	conv.ovf.i1</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Conv_Ovf_U1">
      <summary>0xB4	conv.ovf.u1</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Conv_Ovf_I2">
      <summary>0xB5	conv.ovf.i2</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Conv_Ovf_U2">
      <summary>0xB6	conv.ovf.u2</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Conv_Ovf_I4">
      <summary>0xB7	conv.ovf.i4</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Conv_Ovf_U4">
      <summary>0xB8	conv.ovf.u4</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Conv_Ovf_I8">
      <summary>0xB9	conv.ovf.i8</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Conv_Ovf_U8">
      <summary>0xBA	conv.ovf.u8</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Refanyval">
      <summary>0xC2	refanyval</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ckfinite">
      <summary>0xC3	ckfinite</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Mkrefany">
      <summary>0xC6	mkrefany</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldtoken">
      <summary>0xD0	ldtoken</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Conv_U2">
      <summary>0xD1	conv.u2</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Conv_U1">
      <summary>0xD2	conv.u1</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Conv_I">
      <summary>0xD3	conv.i</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Conv_Ovf_I">
      <summary>0xD4	conv.ovf.i</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Conv_Ovf_U">
      <summary>0xD5	conv.ovf.u</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Add_Ovf">
      <summary>0xD6	add.ovf</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Add_Ovf_Un">
      <summary>0xD7	add.ovf.un</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Mul_Ovf">
      <summary>0xD8	mul.ovf</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Mul_Ovf_Un">
      <summary>0xD9	mul.ovf.un</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Sub_Ovf">
      <summary>0xDA	sub.ovf</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Sub_Ovf_Un">
      <summary>0xDB	sub.ovf.un</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Endfinally">
      <summary>0xDC	endfinally</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Leave">
      <summary>0xDD	leave</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Leave_S">
      <summary>0xDE	leave.s</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Stind_I">
      <summary>0xDF	stind.i</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Conv_U">
      <summary>0xE0	conv.u</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber._CountShort">
      <summary>
            Number of short opcodes.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Arglist">
      <summary>0xFE 0x00	arglist</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ceq">
      <summary>0xFE 0x01	ceq</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Cgt">
      <summary>0xFE 0x02	cgt</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Cgt_Un">
      <summary>0xFE 0x03	cgt.un</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Clt">
      <summary>0xFE 0x04	clt</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Clt_Un">
      <summary>0xFE 0x05	clt.un</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldftn">
      <summary>0xFE 0x06	ldftn</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldvirtftn">
      <summary>0xFE 0x07	ldvirtftn</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldarg">
      <summary>0xFE 0x09	ldarg</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldarga">
      <summary>0xFE 0x0A	ldarga</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Starg">
      <summary>0xFE 0x0B	starg</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldloc">
      <summary>0xFE 0x0C	ldloc</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Ldloca">
      <summary>0xFE 0x0D	ldloca</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Stloc">
      <summary>0xFE 0x0E	stloc</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Localloc">
      <summary>0xFE 0x0F	localloc</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Endfilter">
      <summary>0xFE 0x11	endfilter</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Unaligned">
      <summary>0xFE 0x12	unaligned.</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Volatile">
      <summary>0xFE 0x13	volatile.</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Tail">
      <summary>0xFE 0x14	tail.</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Initobj">
      <summary>0xFE 0x15	initobj</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Constrained">
      <summary>0xFE 0x16  constrained.</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Cpblk">
      <summary>0xFE 0x17	cpblk</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Initblk">
      <summary>0xFE 0x18	initblk</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Rethrow">
      <summary>0xFE 0x1A	rethrow</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Sizeof">
      <summary>0xFE 0x1C	sizeof</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Refanytype">
      <summary>0xFE 0x1D	refanytype</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber.Readonly">
      <summary>0xFE 0x1E readonly.</summary>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber._SequencePoint">
      <summary>
            Pseudo-instruction used internally by to denote a <see cref="T:PostSharp.CodeModel.SymbolSequencePoint" />.
            </summary>
      <remarks>
            The operand of this pseudo-instruction is an <b>int16</b>, which is the token
            of the symbol sequence point, i.e. its position in the array of the
            <see cref="T:PostSharp.CodeModel.MethodBodyDeclaration" />.
            </remarks>
    </member>
    <member name="F:PostSharp.CodeModel.OpCodeNumber._CountLarge">
      <summary>
            Number of large opcodes.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.ExceptionHandler">
      <summary>
            Represents an exception handler. 
            </summary>
      <remarks>
            An <see cref="T:PostSharp.CodeModel.ExceptionHandler" /> is
            contained in an <see cref="T:PostSharp.CodeModel.InstructionBlock" />, which is the protected 
            block (i.e. the <i>try</i> block).
            </remarks>
    </member>
    <member name="P:PostSharp.CodeModel.ExceptionHandler.Options">
      <summary>
            Gets or sets the kind of exception handling clause.
            </summary>
      <remarks>
            You have to set the properties <see cref="P:PostSharp.CodeModel.ExceptionHandler.CatchType" />,
            and <see cref="P:PostSharp.CodeModel.ExceptionHandler.FilterBlock" /> according to the kind
            of exception handler. This rule is not enforced programmatically.
            </remarks>
    </member>
    <member name="P:PostSharp.CodeModel.ExceptionHandler.Parent">
      <summary>
            Gets the parent try block.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.ExceptionHandler.FilterBlock">
      <summary>
            Gets the filter block.
            </summary>
      <value>
            An <see cref="T:PostSharp.CodeModel.InstructionBlock" />, or <b>null</b> if the handler kind
            is not <see cref="F:System.Reflection.ExceptionHandlingClauseOptions.Filter" />.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.ExceptionHandler.HandlerBlock">
      <summary>
            Gets the handler block.
            </summary>
      <value>
            An <see cref="T:PostSharp.CodeModel.InstructionBlock" />.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.ExceptionHandler.CatchType">
      <summary>
            Gets or sets the catch type.
            </summary>
      <value>
            A reference to an <see cref="T:PostSharp.CodeModel.IType" />, or <b>null</b>
            if the handler type is not <see cref="F:System.Reflection.ExceptionHandlingClauseOptions.Clause" />.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.ExceptionHandler.NextSiblingExceptionHandler">
      <summary>
            Gets the next exception handler of the parent block.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.ExceptionHandler.PreviousSiblingExceptionHandler">
      <summary>
            Gets the previous exception handler of the parent block.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.Collections.ExceptionHandlerCollection">
      <summary>
            Collection of exception handlers (<see cref="T:PostSharp.CodeModel.ExceptionHandler" />).
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.InstructionBlock">
      <summary>
            A single node of the hierarchical structure of a method body. 
            </summary>
      <remarks>
            A method body (<see cref="T:PostSharp.CodeModel.MethodBodyDeclaration" />)
            is represented as a tree of instruction blocks. Lexical scopes (definition
            of local variable symbols) and exception handlers are defined at
            <see cref="T:PostSharp.CodeModel.InstructionBlock" /> level. Instruction blocks may contain
            either children blocks, either instruction sequences (<see cref="T:PostSharp.CodeModel.InstructionSequence" />).
            Independently, every <see cref="T:PostSharp.CodeModel.InstructionBlock" /> can contain
            exception handlers and local variable symbols.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.InstructionBlock.ToString" />
    <member name="M:PostSharp.CodeModel.InstructionBlock.DebugOutput">
      <summary>
            Writes recursively the structure of this block and its children to the console.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.InstructionBlock.DebugOutput(System.CodeDom.Compiler.IndentedTextWriter)">
      <summary>
            Writes recursively the structure of this block and its children to a writer.
            </summary>
      <param name="writer">A writer.</param>
    </member>
    <member name="M:PostSharp.CodeModel.InstructionBlock.Detach">
      <summary>
            Detaches the current block from its parent.
            </summary>
      <exception cref="T:System.InvalidOperationException">The instruction block
            has neither parent <see cref="T:PostSharp.CodeModel.InstructionBlock" /> neither
            parent <see cref="T:PostSharp.CodeModel.MethodBodyDeclaration" />.</exception>
    </member>
    <member name="M:PostSharp.CodeModel.InstructionBlock.AddChildBlock(PostSharp.CodeModel.InstructionBlock,PostSharp.Collections.NodePosition,PostSharp.CodeModel.InstructionBlock)">
      <summary>
            Adds a child block.
            </summary>
      <param name="newBlock">Block to insert.</param>
      <param name="position">Relative position of the new block w.r.t. <paramref name="referenceBlock" />.</param>
      <param name="referenceBlock">Block after or before which <paramref name="newBlock" /> has to be inserted,
            or <b>null</b> if the new block has to be inserted at the first or the last.</param>
      <exception cref="T:System.ArgumentException">The <paramref name="newBlock" /> 
            instruction block is already attached.</exception>
      <exception cref="T:System.InvalidOperationException">The current block
            is detached or has no parent block.</exception>
    </member>
    <member name="M:PostSharp.CodeModel.InstructionBlock.GetChildrenEnumerator">
      <summary>
            Gets an enumerator to enumerate children blocks
            </summary>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerator`1" />.
            </returns>
      <remarks>
            For performance reason, it is better to enumerate the children blocks
            using the linked list formed by the <see cref="P:PostSharp.CodeModel.InstructionBlock.FirstChildBlock" /> and
            <see cref="P:PostSharp.CodeModel.InstructionBlock.NextSiblingBlock" /> properties.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.InstructionBlock.GetChildrenEnumerator(System.Boolean)">
      <summary>
            Gets an enumerator to enumerate children blocks and allow to enumerate
            them children of children recursively.
            </summary>
      <param name="deep">
        <b>true</b> if children have to be enumerated
            recursively, otherwise <b>false</b>.</param>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerator`1" />.
            </returns>
    </member>
    <member name="M:PostSharp.CodeModel.InstructionBlock.FindCommonAncestor(PostSharp.CodeModel.InstructionBlock,PostSharp.CodeModel.InstructionBlock)">
      <summary>
            Finds the deepest common ancestor of two blocks in the method body tree.
            </summary>
      <param name="first">An <see cref="T:PostSharp.CodeModel.InstructionBlock" />.</param>
      <param name="second">An <see cref="T:PostSharp.CodeModel.InstructionBlock" />.</param>
      <returns>An <see cref="T:PostSharp.CodeModel.InstructionBlock" />, or <b>null</b> if no common
            ancestor was found.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.InstructionBlock.Nest">
      <summary>
            Inserts a new <see cref="T:PostSharp.CodeModel.InstructionBlock" /> between the current block
            and its parent.
            </summary>
      <returns>The new <see cref="T:PostSharp.CodeModel.InstructionBlock" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.InstructionBlock.AddExceptionHandlerCatch(PostSharp.CodeModel.ITypeSignature,PostSharp.CodeModel.InstructionBlock,PostSharp.Collections.NodePosition,PostSharp.CodeModel.ExceptionHandler)">
      <summary>
            Constructs an <b>Catch</b><see cref="T:PostSharp.CodeModel.ExceptionHandler" /> and add it to the current block.
            </summary>
      <param name="position">Position of the new <see cref="T:PostSharp.CodeModel.ExceptionHandler" /> w.r.t.
            <paramref name="referenceHandler" />.</param>
      <param name="referenceHandler">Handler before or after which the new handler has to be
            inserted, or <b>null</b> if the new handler has to be the first or the last.</param>
      <param name="handlerBlock">Handler block.</param>
      <param name="catchType">Type caught.</param>
      <returns>The new <see cref="T:PostSharp.CodeModel.ExceptionHandler" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="handlerBlock" /> is null.
            </exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="catchType" /> is null.
            </exception>
      <exception cref="T:System.InvalidOperationException">
            	The current block is detached or is the root.
            </exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="handlerBlock" /> is attached.
            </exception>
    </member>
    <member name="M:PostSharp.CodeModel.InstructionBlock.AddExceptionHandlerFinally(PostSharp.CodeModel.InstructionBlock,PostSharp.Collections.NodePosition,PostSharp.CodeModel.ExceptionHandler)">
      <summary>
            Constructs a <b>Finally</b><see cref="T:PostSharp.CodeModel.ExceptionHandler" /> and add it to the current block.
            </summary>
      <param name="position">Position of the new <see cref="T:PostSharp.CodeModel.ExceptionHandler" /> w.r.t.
            <paramref name="referenceHandler" />.</param>
      <param name="referenceHandler">Handler before or after which the new handler has to be
            inserted, or <b>null</b> if the new handler has to be the first or the last.</param>
      <param name="handlerBlock">Handler block.</param>
      <returns>The new <see cref="T:PostSharp.CodeModel.ExceptionHandler" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="handlerBlock" /> is null.
            </exception>
      <exception cref="T:System.InvalidOperationException">
            	The current block is detached or is the root.
            </exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="handlerBlock" /> is attached.
            </exception>
    </member>
    <member name="M:PostSharp.CodeModel.InstructionBlock.AddExceptionHandlerFault(PostSharp.CodeModel.InstructionBlock,PostSharp.Collections.NodePosition,PostSharp.CodeModel.ExceptionHandler)">
      <summary>
            Constructs a <b>Fault</b><see cref="T:PostSharp.CodeModel.ExceptionHandler" /> and add it to the current block.
            </summary>
      <param name="position">Position of the new <see cref="T:PostSharp.CodeModel.ExceptionHandler" /> w.r.t.
            <paramref name="referenceHandler" />.</param>
      <param name="referenceHandler">Handler before or after which the new handler has to be
            inserted, or <b>null</b> if the new handler has to be the first or the last.</param>
      <param name="handlerBlock">Handler block.</param>
      <returns>The new <see cref="T:PostSharp.CodeModel.ExceptionHandler" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="handlerBlock" /> is null.
            </exception>
      <exception cref="T:System.InvalidOperationException">
            	The current block is detached or is the root.
            </exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="handlerBlock" /> is attached.
            </exception>
    </member>
    <member name="M:PostSharp.CodeModel.InstructionBlock.AddExceptionHandlerFilter(PostSharp.CodeModel.InstructionBlock,PostSharp.CodeModel.InstructionBlock,PostSharp.Collections.NodePosition,PostSharp.CodeModel.ExceptionHandler)">
      <summary>
            Constructs a <b>Filter</b><see cref="T:PostSharp.CodeModel.ExceptionHandler" /> and add it to the current block.
            </summary>
      <param name="handlerBlock">Handler block.</param>
      <param name="position">Position of the new <see cref="T:PostSharp.CodeModel.ExceptionHandler" /> w.r.t.
            <paramref name="referenceHandler" />.</param>
      <param name="referenceHandler">Handler before or after which the new handler has to be
            inserted, or <b>null</b> if the new handler has to be the first or the last.</param>
      <param name="filterBlock">Filter block.</param>
      <returns>The new <see cref="T:PostSharp.CodeModel.ExceptionHandler" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="handlerBlock" /> is null.
            </exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="filterBlock" /> is null.
            </exception>
      <exception cref="T:System.InvalidOperationException">
            	The current block is detached or is the root.
            </exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="handlerBlock" /> is attached.
            </exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="filterBlock" /> is attached.
            </exception>
    </member>
    <member name="M:PostSharp.CodeModel.InstructionBlock.GetLocalVariableSymbol(System.Int32)">
      <summary>
            Gets a <see cref="T:PostSharp.CodeModel.LocalVariableSymbol" /> given its position in the current block.
            </summary>
      <param name="index">Index of the required symbol in the collection of symbols
            of the current block. This is <i>not</i> the ordinal of the local variable
            to which it refers.</param>
      <returns>The <see cref="T:PostSharp.CodeModel.LocalVariableSymbol" /> at position <paramref name="index" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.InstructionBlock.DefineLocalVariable(PostSharp.CodeModel.ITypeSignature,System.String)">
      <summary>
            Creates a new local variable in the current block.
            </summary>
      <param name="type">Variable type.</param>
      <param name="name">Variable name, or <b>null</b> if the
            local variable is anonym. The variable name may contain the 
            placeholder <c>{0}</c>. It will be replaced by the local
            variable ordinal at runtime (useful to create unique names).</param>
      <returns>The <see cref="T:PostSharp.CodeModel.LocalVariableSymbol" /> referencing the new
            local variable.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.InstructionBlock.AddInstructionSequence(PostSharp.CodeModel.InstructionSequence,PostSharp.Collections.NodePosition,PostSharp.CodeModel.InstructionSequence)">
      <summary>
            Adds an <see cref="T:PostSharp.CodeModel.InstructionSequence" /> after a given sequence in the current the block.
            </summary>
      <param name="position">Position of the new <see cref="T:PostSharp.CodeModel.InstructionSequence" /> w.r.t.
            <paramref name="referenceSequence" />.</param>
      <param name="referenceSequence">Sequence before or after which <paramref name="newSequence" /> has to be
            inserted, or <b>null</b> if <paramref name="newSequence" />has to be the first or the last.</param>
      <param name="newSequence">A detached <see cref="T:PostSharp.CodeModel.InstructionSequence" />.</param>
    </member>
    <member name="M:PostSharp.CodeModel.InstructionBlock.MoveInstructionBlock(PostSharp.CodeModel.InstructionBlock,PostSharp.Collections.NodePosition,PostSharp.CodeModel.InstructionBlock)">
      <summary>
            Moves an <see cref="T:PostSharp.CodeModel.InstructionBlock" /> from another block into the current one.
            </summary>
      <param name="movedBlock">Block to be moved.</param>
      <param name="position">Relative position of the new block w.r.t. <paramref name="referenceBlock" />.</param>
      <param name="referenceBlock">Block after or before which <paramref name="movedBlock" /> has to be inserted,
            or <b>null</b> if the new block has to be inserted at the first or the last.</param>
    </member>
    <member name="M:PostSharp.CodeModel.InstructionBlock.MoveInstructionSequence(PostSharp.CodeModel.InstructionSequence,PostSharp.Collections.NodePosition,PostSharp.CodeModel.InstructionSequence)">
      <summary>
            Adds an <see cref="T:PostSharp.CodeModel.InstructionSequence" /> after a given sequence in the current the block.
            </summary>
      <param name="position">Position of the new <see cref="T:PostSharp.CodeModel.InstructionSequence" /> w.r.t.
            <paramref name="referenceSequence" />.</param>
      <param name="referenceSequence">Sequence before or after which <paramref name="newSequence" /> has to be
            inserted, or <b>null</b> if <paramref name="newSequence" />has to be the first or the last.</param>
      <param name="newSequence">A detached <see cref="T:PostSharp.CodeModel.InstructionSequence" />.</param>
    </member>
    <member name="M:PostSharp.CodeModel.InstructionBlock.FindFirstInstructionSequence">
      <summary>
            Finds the first <see cref="T:PostSharp.CodeModel.InstructionSequence" /> of the tree
            whose current <see cref="T:PostSharp.CodeModel.InstructionBlock" /> is the root.
            </summary>
      <returns>An <see cref="T:PostSharp.CodeModel.InstructionSequence" />, or <b>null</b>
            if the block do not contain any <see cref="T:PostSharp.CodeModel.InstructionSequence" />.
            </returns>
    </member>
    <member name="M:PostSharp.CodeModel.InstructionBlock.SplitBlockAfterSequence(PostSharp.CodeModel.InstructionSequence)">
      <summary>
            Splits the current <see cref="T:PostSharp.CodeModel.InstructionBlock" /> in two blocks after
            an <see cref="T:PostSharp.CodeModel.InstructionSequence" />.
            </summary>
      <param name="sequence">An <see cref="T:PostSharp.CodeModel.InstructionSequence" /> belonging
            to the current <see cref="T:PostSharp.CodeModel.InstructionBlock" />.</param>
      <returns>A new <see cref="T:PostSharp.CodeModel.InstructionBlock" /> containing the second
            part of the split block.</returns>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="sequence" /> argument is null.
            </exception>
      <exception cref="T:System.ArgumentException">
            The <paramref name="sequence" /> does not belong to the current 
            <see cref="T:PostSharp.CodeModel.InstructionBlock" />.
            </exception>
    </member>
    <member name="P:PostSharp.CodeModel.InstructionBlock.Token">
      <summary>
            Gets the instruction sequence token.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.InstructionBlock.ParentBlock">
      <summary>
            Gets the parent block.
            </summary>
      <value>
            The parent block, or <b>null</b> if (a) the current block is
            the root block, or (b) has simply no parent.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.InstructionBlock.Comment">
      <summary>
            Gets or sets the comment associated to the current block.
            </summary>
      <remarks>
            This comment is a purely informative string that will be rendered into the MSIL code.
            It should be used for diagnostics only.
            </remarks>
    </member>
    <member name="P:PostSharp.CodeModel.InstructionBlock.HasChildrenBlocks">
      <summary>
            Determines whether the current block has children blocks.
            </summary>
      <value>
        <b>true</b> if the current block has at least one children block, otherwise <b>false</b>.
            </value>
      <remarks>
            A block may have either children blocks either instruction sequences.
            </remarks>
    </member>
    <member name="P:PostSharp.CodeModel.InstructionBlock.HasExceptionHandlers">
      <summary>
            Determines whether the current block has exception handlers (<see cref="T:PostSharp.CodeModel.ExceptionHandler" />).
            </summary>
      <value>
        <b>true</b> if the current block has at least one exception handler, otherwise <b>false</b>.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.InstructionBlock.HasLocalVariableSymbols">
      <summary>
            Determines whether the current block has local variable symbols (<see cref="T:PostSharp.CodeModel.LocalVariableSymbol" />).
            </summary>
      <value>
        <b>true</b> if the current block has at least one local variable symbol, otherwise <b>false</b>.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.InstructionBlock.HasInstructionSequences">
      <summary>
            Determines whether the current block has instruction sequences (<see cref="T:PostSharp.CodeModel.InstructionSequence" />).
            </summary>
      <value>
        <b>true</b> if the current block has at least one instruction sequence, otherwise <b>false</b>.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.InstructionBlock.ParentExceptionHandler">
      <summary>
            Gets the parent exception handler.
            </summary>
      <value>
            An <see cref="T:PostSharp.CodeModel.ExceptionHandler" />, or <b>null</b> if the current block is not
            a direct child of an exception handler.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.InstructionBlock.IsExceptionHandler">
      <summary>
            Determines whether the current block is a direct child of an exception handler
            (i.e. is a handler or filter block).
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.InstructionBlock.MethodBody">
      <summary>
            Gets the method body containing the current instruction block.
            </summary>
      <value>
            The method body (<see cref="T:PostSharp.CodeModel.MethodBodyDeclaration" />) containing this
            block, or <b>null</b> if the current block is not attached to any
            method body.
            </value>
      <remarks>
            Consider caching the result of the current method since its implementation
            is recursive.
            </remarks>
    </member>
    <member name="P:PostSharp.CodeModel.InstructionBlock.NextSiblingBlock">
      <summary>
            Gets the next block whith the same parent as the current block.
            </summary>
      <value>
            The child of the parent of the current block that is just next to the
            current block, or <b>null</b> if the current node is detached or
            has no is the last child of its parent.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.InstructionBlock.NextDeepBlock">
      <summary>
            Gets the next block in the method body tree, eventually with a different parent block.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.InstructionBlock.PreviousSiblingBlock">
      <summary>
            Gets the previous block with the same parent as the current block.
            </summary>
      <value>
            The child of the parent of the current block that is just previous to the
            current block, or <b>null</b> if the current node is detached or
            has no is the first child of its parent.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.InstructionBlock.PreviousDeepBlock">
      <summary>
            Gets the previous block in the method body tree, eventually with a different parent block.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.InstructionBlock.FirstChildBlock">
      <summary>
            Gets the first child block.
            </summary>
      <value>
            The first child block, or <b>null</b> if the current block has no child.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.InstructionBlock.LastChildBlock">
      <summary>
            Gets the last child block.
            </summary>
      <value>
            The last child block, or <b>null</b> if the current block has no child.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.InstructionBlock.FirstExceptionHandler">
      <summary>
            Gets the first exception handler protecting the current block.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.InstructionBlock.LastExceptionHandler">
      <summary>
            Gets the last exception handler protecting the current block.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.InstructionBlock.LocalVariableSymbolCount">
      <summary>
            Gets the number of local variable symbols (<see cref="T:PostSharp.CodeModel.LocalVariableSymbol" />).
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.InstructionBlock.FirstInstructionSequence">
      <summary>
            Gets the number first <see cref="T:PostSharp.CodeModel.InstructionSequence" /> of the current block.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.InstructionBlock.LastInstructionSequence">
      <summary>
            Gets the number last <see cref="T:PostSharp.CodeModel.InstructionSequence" /> of the current block.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.Collections.InstructionBlockCollection">
      <summary>
            Linked list of instruction blocks (<see cref="T:PostSharp.CodeModel.InstructionBlock" />).
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.LocalVariableDeclaration">
      <summary>
            Represents a local variable. Local variables are owned by method bodies 
            (<see cref="T:PostSharp.CodeModel.MethodBodyDeclaration" />).
            </summary>
      <remarks>
            A <see cref="T:PostSharp.CodeModel.LocalVariableDeclaration" /> it referenced by ordinal; it has
            no name. Positions are assigned to a name in lexical scopes. Lexical
            scopes are implemented by the <see cref="T:PostSharp.CodeModel.InstructionBlock" /> type and
            assignment of names to a local variable are done by the <see cref="T:PostSharp.CodeModel.LocalVariableSymbol" />
            type.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.LocalVariableDeclaration.ToString" />
    <member name="M:PostSharp.CodeModel.LocalVariableDeclaration.Clone">
      <summary>
            Clones the current instance.
            </summary>
      <returns>A clone of the current instance (but unattached).</returns>
    </member>
    <member name="P:PostSharp.CodeModel.LocalVariableDeclaration.Ordinal">
      <summary>
            Gets the local variable ordinal.
            </summary>
      <value>
            A positive integer.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.LocalVariableDeclaration.Type">
      <summary>
            Gets or sets the local variable type.
            </summary>
      <value>
            Any <see cref="T:PostSharp.CodeModel.TypeSignature" />.
            </value>
      <exception cref="T:System.ArgumentNullException">Trying to
            set the property to <b>null</b>.</exception>
    </member>
    <member name="P:PostSharp.CodeModel.LocalVariableDeclaration.IsReadOnly">
      <summary>
            Determines whether the current variable is read-only.
            </summary>
      <remarks>
            A local variable may be read-only if it is owned by a 
            <see cref="T:PostSharp.CodeModel.StandaloneSignatureDeclaration" />. This constraint is defined
            by PostSharp because, in this case, the variable is shared by many method
            bodies.
            </remarks>
    </member>
    <member name="T:PostSharp.CodeModel.Collections.LocalVariableDeclarationCollection">
      <summary>
            Collection of local variables (<see cref="T:PostSharp.CodeModel.LocalVariableDeclaration" />).
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.Collections.LocalVariableDeclarationCollection.IsReadOnly">
      <summary>
            Determines whether the current collection of variables is read-only.
            </summary>
      <remarks>
            A collection of local variables may be read-only if it is owned by a 
            <see cref="T:PostSharp.CodeModel.StandaloneSignatureDeclaration" />. This constraint is defined
            by PostSharp because, in this case, the collection is shared by many method
            bodies.
            </remarks>
    </member>
    <member name="T:PostSharp.ModuleWriter.ILWriter">
      <summary>
            Provides low-level methods to writer text MSIL code.
            </summary>
    </member>
    <member name="F:PostSharp.ModuleWriter.ILWriter.BreakMargin">
      <summary>
            Default maximal size of a line above which the <see cref="M:PostSharp.ModuleWriter.ILWriter.WriteConditionalLineBreak" />
            method issues a line break.
            </summary>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.#ctor(System.IO.TextWriter)">
      <summary>
            Initializes a new <see cref="T:PostSharp.ModuleWriter.ILWriter" />.
            </summary>
      <param name="writer">&gt;The <see cref="P:PostSharp.ModuleWriter.ILWriter.TextWriter" /> where the IL code shall
            be written.</param>
      <remarks>The <see cref="P:PostSharp.ModuleWriter.ILWriter.TextWriter" /> is not disposed automatically when the
            new <see cref="T:PostSharp.ModuleWriter.ILWriter" /> instance is disposed. The second constructor overload
            offers this feature.</remarks>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.#ctor(System.IO.TextWriter,System.Boolean)">
      <summary>
            Initializes a new <see cref="T:PostSharp.ModuleWriter.ILWriter" /> and specifies whether the underlying
            <see cref="P:PostSharp.ModuleWriter.ILWriter.TextWriter" /> should be automatically disposed.
            </summary>
      <param name="writer">The <see cref="P:PostSharp.ModuleWriter.ILWriter.TextWriter" /> where the IL code shall
            be written.</param>
      <param name="disposeTextWriter">
        <b>true</b> if <paramref name="writer" />
            should be disposed when the new <see cref="T:PostSharp.ModuleWriter.ILWriter" /> is disposed, otherwise <b>false</b>.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.Dispose" />
    <member name="M:PostSharp.ModuleWriter.ILWriter.Flush">
      <summary>
            Flushes the inner <see cref="P:PostSharp.ModuleWriter.ILWriter.TextWriter" />.
            </summary>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteFileName(System.String)">
      <summary>
            Writes a file name.
            </summary>
      <param name="text">A string.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteDottedName(System.String)">
      <summary>
            Writes a dotted name.
            </summary>
      <param name="text">A string.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteSpace">
      <summary>
            Writes a space.
            </summary>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteIdentifier(System.String)">
      <summary>
            Writes an identifier.
            </summary>
      <param name="text">A string.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteCallConvention(PostSharp.CodeModel.CallingConvention)">
      <summary>
            Writes a <see cref="T:PostSharp.CodeModel.CallingConvention" />.
            </summary>
      <param name="callingConvention">A <see cref="T:PostSharp.CodeModel.CallingConvention" />.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteCallKind(PostSharp.CodeModel.CallingConvention)">
      <summary>
            Writes the call kind part of a <see cref="T:PostSharp.CodeModel.CallingConvention" />.
            </summary>
      <param name="callingKind">A <see cref="T:PostSharp.CodeModel.CallingConvention" />.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteBytes(System.Byte[])">
      <overloads>Writes an array of bytes.</overloads>
      <summary>
            Writes an array of bytes without issuing a line break before the first byte.
            </summary>
      <param name="bytes">An array of bytes.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteBytes(System.Byte[],System.Boolean)">
      <summary>
            Writes an array of bytes and specifies whether a line break should
            be issued before the first byte.
            </summary>
      <param name="bytes">An array of bytes.</param>
      <param name="breakBefore">Whether a line break should be issued before
            the first byte.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteInteger(System.SByte)">
      <overloads>Writes a <see cref="T:System.SByte" />.</overloads>
      <summary>
            Writes a signed byte in hexadecimal.
            </summary>
      <param name="value">A <see cref="T:System.SByte" />.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteInteger(System.SByte,PostSharp.ModuleWriter.IntegerFormat)">
      <summary>
            Writes a <see cref="T:System.SByte" /> and specifies whether the format is hexadecimal or decimal.
            </summary>
      <param name="value">A <see cref="T:System.SByte" />.</param>
      <param name="format">The format in which the value has to be written.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteInteger(System.Int16)">
      <overloads>Writes a <see cref="T:System.Int16" />.</overloads>
      <summary>
            Writes an <see cref="T:System.Int16" /> in hexadecimal.
            </summary>
      <param name="value">A <see cref="T:System.Int16" />.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteInteger(System.Int16,PostSharp.ModuleWriter.IntegerFormat)">
      <summary>
            Writes a <see cref="T:System.Int16" /> and specifies whether the format is hexadecimal or decimal.
            </summary>
      <param name="value">A <see cref="T:System.Int16" />.</param>
      <param name="format">The format in which the value has to be written.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteInteger(System.Int32)">
      <overloads>Writes a <see cref="T:System.Int32" />.</overloads>
      <summary>
            Writes an <see cref="T:System.Int32" /> in hexadecimal.
            </summary>
      <param name="value">A <see cref="T:System.Int32" />.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteInteger(System.Int32,PostSharp.ModuleWriter.IntegerFormat)">
      <summary>
            Writes a <see cref="T:System.Int32" /> and specifies whether the format is hexadecimal or decimal.
            </summary>
      <param name="value">A <see cref="T:System.Int32" />.</param>
      <param name="format">The format in which the value has to be written.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteInteger(System.Byte)">
      <overloads>Writes a <see cref="T:System.Byte" />.</overloads>
      <summary>
            Writes a <see cref="T:System.Byte" /> in hexadecimal.
            </summary>
      <param name="value">A <see cref="T:System.Byte" />.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteInteger(System.Byte,PostSharp.ModuleWriter.IntegerFormat)">
      <summary>
            Writes a <see cref="T:System.Byte" /> and specifies whether the format is hexadecimal or decimal.
            </summary>
      <param name="value">A <see cref="T:System.Byte" />.</param>
      <param name="format">The format in which the value has to be written.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteInteger(System.UInt16)">
      <overloads>Writes a <see cref="T:System.UInt16" />.</overloads>
      <summary>
            Writes a <see cref="T:System.UInt16" /> in hexadecimal.
            </summary>
      <param name="value">A <see cref="T:System.UInt16" />.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteInteger(System.UInt16,PostSharp.ModuleWriter.IntegerFormat)">
      <summary>
            Writes a <see cref="T:System.UInt16" /> and specifies whether the format is hexadecimal or decimal.
            </summary>
      <param name="value">A <see cref="T:System.UInt16" />.</param>
      <param name="format">The format in which the value has to be written.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteInteger(System.UInt32)">
      <overloads>Writes a <see cref="T:System.UInt32" />.</overloads>
      <summary>
            Writes a <see cref="T:System.UInt32" /> in hexadecimal.
            </summary>
      <param name="value">A <see cref="T:System.UInt32" />.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteInteger(System.UInt32,PostSharp.ModuleWriter.IntegerFormat)">
      <summary>
            Writes a <see cref="T:System.UInt32" /> and specifies whether the format is hexadecimal or decimal.
            </summary>
      <param name="value">A <see cref="T:System.UInt32" />.</param>
      <param name="format">The format in which the value has to be written.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteInteger(System.Int64)">
      <overloads>Writes a <see cref="T:System.Int64" />.</overloads>
      <summary>
            Writes a <see cref="T:System.Int64" /> in hexadecimal.
            </summary>
      <param name="value">A <see cref="T:System.Int64" />.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteInteger(System.Int64,PostSharp.ModuleWriter.IntegerFormat)">
      <summary>
            Writes a <see cref="T:System.Int64" /> and specifies whether the format is hexadecimal or decimal.
            </summary>
      <param name="value">A <see cref="T:System.Int64" />.</param>
      <param name="format">The format in which the value has to be written.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteInteger(System.UInt64)">
      <overloads>Writes a <see cref="T:System.UInt64" />.</overloads>
      <summary>
            Writes an <see cref="T:System.UInt64" /> in hexadecimal.
            </summary>
      <param name="value">A <see cref="T:System.UInt64" />.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteInteger(System.UInt64,PostSharp.ModuleWriter.IntegerFormat)">
      <summary>
            Writes a <see cref="T:System.UInt64" /> and specifies whether the format is hexadecimal or decimal.
            </summary>
      <param name="value">A <see cref="T:System.UInt64" />.</param>
      <param name="format">The format in which the value has to be written.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteSingle(System.Single)">
      <summary>
            Writes a <see cref="T:System.Single" />.
            </summary>
      <param name="value">A <see cref="T:System.Single" />.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteDouble(System.Double)">
      <summary>
            Writes a <see cref="T:System.Double" />.
            </summary>
      <param name="value">A <see cref="T:System.Double" />.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteQuotedString(System.String)">
      <summary>
            Writes a quoted string.
            </summary>
      <param name="text">A text.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteQuotedString(System.String,PostSharp.ModuleWriter.WriteStringOptions)">
      <summary>
            Writes a single quoted string (passed as a <see cref="T:System.String" />).
            </summary>
      <param name="text">A text.</param>
      <param name="options">Options.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteQuotedString(PostSharp.CodeModel.LiteralString,PostSharp.ModuleWriter.WriteStringOptions)">
      <summary>
            Writes a single quoted string (passed as a <see cref="T:PostSharp.CodeModel.LiteralString" />).
            </summary>
      <param name="text">A text.</param>
      <param name="options">Options.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteSymbol(System.String)">
      <overloads>Writes a symbol.</overloads>
      <summary>
            Writes a symbol given as a <see cref="T:System.String" />.
            </summary>
      <param name="text">The symbol.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteSymbol(System.Char)">
      <summary>
            Writes a symbol given as a <see cref="T:System.Char" /> and determines automatically
            the kind of symbol required by the symbol.
            </summary>
      <param name="character">The symbol.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteSymbol(System.Char,PostSharp.ModuleWriter.SymbolSpacingKind,PostSharp.ModuleWriter.SymbolSpacingKind)">
      <summary>
            Writes a symbol given as a <see cref="T:System.Char" /> and specifies the kind
            of spacing required before and after the symbol.
            </summary>
      <param name="character">The symbol.</param>
      <param name="spacingKindBefore">Kind of spacing required before the symbol.
            </param>
      <param name="spacingKindAfter">Kind of spacing required after the symbol.
            </param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteKeyword(System.String)">
      <summary>
            Writes a keyword.
            </summary>
      <param name="text">The keyword.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteInstruction(PostSharp.CodeModel.OpCodeNumber)">
      <summary>
            Writes an instruction opcode.
            </summary>
      <param name="opCode">The opcode</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteLineBreak">
      <summary>
            Writes an unconditional line break.
            </summary>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteConditionalLineBreak">
      <overloads>Writes a conditional line break.</overloads>
      <summary>
            Writes a conditional line break with the default margin.
            </summary>
      <returns>
        <b>true</b> if a line break was issued, otherwise <b>false</b>.</returns>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteConditionalLineBreak(System.Int32)">
      <summary>
            Writes a conditional line break and specifies the margin.
            </summary>
      <param name="breakMargin">Maximal size of a line above which a line break
            will be issued.</param>
      <returns>
        <b>true</b> if a line break was issued, otherwise <b>false</b>.</returns>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.BeginBlock">
      <summary>
            Begins a block.
            </summary>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteCommentLine(System.String)">
      <summary>
            Writes a comment line.
            </summary>
      <param name="comment">Comment text.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteComment(System.String)">
      <summary>
            Write a comment.
            </summary>
      <param name="comment">A comment.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.EndBlock">
      <summary>
            Ends a block and writes a line break after the closing bracket.
            </summary>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.EndBlock(System.Boolean)">
      <summary>
            Ends a block and specifies whether a line break should be issued
            after the closing bracket.
            </summary>
      <param name="writeLineBreak">Shether a line break should be issued
            after the closing bracket.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteLabelReference(System.Int32)">
      <overloads>Writes a label name.</overloads>
      <summary>
            Writes a label name with the default prefix.
            </summary>
      <param name="token">The label token.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteLabelReference(System.String,System.Int32)">
      <summary>
            Writes a label name and specifies the prefix.
            </summary>
      <param name="prefix">The label prefix.</param>
      <param name="token">The label token.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteLabelDefinition(System.String,System.Int32)">
      <summary>
            Writes a label definition.
            </summary>
      <param name="prefix">The label prefix.</param>
      <param name="token">The label token.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteRaw(System.String)">
      <overloads>Writes a raw string.</overloads>
      <summary>
            Writes a raw string represented as a <see cref="T:System.String" />.
            </summary>
      <param name="text">The text.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteRaw(System.Char[])">
      <summary>
            Writes a raw string represented as an array of characters.
            </summary>
      <param name="text">The text.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteRaw(System.Char[],System.Int32,System.Int32)">
      <summary>
            Writes a raw string represented as an array of characters.
            </summary>
      <param name="text">An array of characters.</param>
      <param name="index">Index of the first character to be written.</param>
      <param name="length">Number of characters to be written.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.WriteRaw(System.Char)">
      <summary>
            Writes a single raw character.
            </summary>
      <param name="character">A character.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.MarkAutoIndentLocation">
      <summary>
            Sets the value of the indent location of the the current horizontal.
            </summary>
      <returns>The current horizontal position.</returns>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.SetIndentLocation(System.Int32)">
      <summary>
            Sets the indent location to an explicit number of spaces.
            </summary>
      <param name="horizontalPosition">The horizontal position of indentation.</param>
    </member>
    <member name="M:PostSharp.ModuleWriter.ILWriter.ResetIndentLocation">
      <summary>
            Resets the indent location to the value computed from the current indent level.
            </summary>
    </member>
    <member name="P:PostSharp.ModuleWriter.ILWriter.TextWriter">
      <summary>
            Gets the underlying <see cref="P:PostSharp.ModuleWriter.ILWriter.TextWriter" />.
            </summary>
    </member>
    <member name="P:PostSharp.ModuleWriter.ILWriter.Options">
      <summary>
            Gets the options of the current <see cref="T:PostSharp.ModuleWriter.ILWriter" />.
            </summary>
    </member>
    <member name="P:PostSharp.ModuleWriter.ILWriter.Indent">
      <summary>
            Gets or sets the identation level.
            </summary>
    </member>
    <member name="P:PostSharp.ModuleWriter.ILWriter.CurrentHorizontalPosition">
      <summary>
            Gets the current horizontal position.
            </summary>
    </member>
    <member name="T:PostSharp.ModuleWriter.IntegerFormat">
      <summary>
            Determines how to format an integer.
            </summary>
    </member>
    <member name="F:PostSharp.ModuleWriter.IntegerFormat.Decimal">
      <summary>
            Decimal.
            </summary>
    </member>
    <member name="F:PostSharp.ModuleWriter.IntegerFormat.HexUpper">
      <summary>
            Hexadecimal, upper case.
            </summary>
    </member>
    <member name="F:PostSharp.ModuleWriter.IntegerFormat.HexLower">
      <summary>
            Hexadecimal, lower case.
            </summary>
    </member>
    <member name="T:PostSharp.ModuleWriter.SymbolSpacingKind">
      <summary>
            Enumerates the kind of spacing requirements of symbols.
            </summary>
    </member>
    <member name="F:PostSharp.ModuleWriter.SymbolSpacingKind.None">
      <summary>
            The symbol does not require any space.
            </summary>
    </member>
    <member name="F:PostSharp.ModuleWriter.SymbolSpacingKind.IfWord">
      <summary>
            The symbol requires a space only if the next or previous 
            symbol is a word.
            </summary>
    </member>
    <member name="F:PostSharp.ModuleWriter.SymbolSpacingKind.Required">
      <summary>
            The symbol does not require any symbol.
            </summary>
    </member>
    <member name="T:PostSharp.ModuleWriter.WriteStringOptions">
      <summary>
            Influences the behavior of <see cref="M:PostSharp.ModuleWriter.ILWriter.WriteQuotedString(System.String,PostSharp.ModuleWriter.WriteStringOptions)" />.
            </summary>
    </member>
    <member name="F:PostSharp.ModuleWriter.WriteStringOptions.None">
      <summary>
            Default.
            </summary>
    </member>
    <member name="F:PostSharp.ModuleWriter.WriteStringOptions.IgnoreByteArray">
      <summary>
            Never render the string as a byte array.
            </summary>
    </member>
    <member name="F:PostSharp.ModuleWriter.WriteStringOptions.IgnoreEscapeQuestionMark">
      <summary>
            Do not escape question marks.
            </summary>
    </member>
    <member name="F:PostSharp.ModuleWriter.WriteStringOptions.LineBreak">
      <summary>
            Separate the string in many lines if it is too large for one line.
            </summary>
    </member>
    <member name="F:PostSharp.ModuleWriter.WriteStringOptions.DoubleQuoted">
      <summary>
            Use double quotes instead of simple quotes.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.CustomAttributeDeclaration">
      <summary>
            Represents a custom attribute (<see cref="F:PostSharp.CodeModel.TokenType.CustomAttribute" />).
            </summary>
      <remarks>
        <para>Any <see cref="T:PostSharp.CodeModel.MetadataDeclaration" /> can
            have custom attributes. They are exposed on the 
            <see cref="P:PostSharp.CodeModel.MetadataDeclaration.CustomAttributes" /> property.
            </para>
        <para>
            If you change any member of an instance of <see cref="T:PostSharp.CodeModel.CustomAttributeDeclaration" />,
            you have to call the <see cref="M:PostSharp.CodeModel.CustomAttributeDeclaration.InvalidateSerialization" /> to force the
            custom attribute to be serialized again.
            </para>
      </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.CustomAttributeDeclaration.#ctor(PostSharp.CodeModel.IMethod)">
      <summary>
            Initializes a new instance of the <see cref="T:PostSharp.CodeModel.CustomAttributeDeclaration" /> type.
            </summary>
      <param name="constructor">Custom attribute constructor.</param>
      <remarks>
            The <paramref name="constructor" /> parameter should be set to a valid
            instance constructor. This rule is not enforced programmatically.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.CustomAttributeDeclaration.#ctor(PostSharp.CodeModel.IAnnotationValue)">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.CustomAttributeDeclaration" /> cloned from
            a <see cref="T:PostSharp.CodeModel.IAnnotationValue" />.
            </summary>
      <param name="source">Source <see cref="T:PostSharp.CodeModel.IAnnotationValue" /> from which
            the new instance has to be copied.</param>
    </member>
    <member name="M:PostSharp.CodeModel.CustomAttributeDeclaration.GetTokenType">
      <summary>
            Gets the metadata token type of the current declaration.
            </summary>
      <returns>A <see cref="T:PostSharp.CodeModel.TokenType" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.CustomAttributeDeclaration.ToString" />
    <member name="M:PostSharp.CodeModel.CustomAttributeDeclaration.InvalidateSerialization">
      <summary>
            Invalidates the original serialization. Indicates that
            the serialization should be computed again, if requested.
            </summary>
      <remarks>
            Use the current method if you change a value in the custom attribute.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.CustomAttributeDeclaration.ConstructRuntimeObject">
      <summary>
            Gets the runtime object 
            constructed from the current instance.
            </summary>
      <returns>An object constructed from <see cref="P:PostSharp.CodeModel.CustomAttributeDeclaration.Constructor" /> with all <see cref="P:PostSharp.CodeModel.CustomAttributeDeclaration.NamedArguments" />
            properly set.</returns>
      <exception cref="T:PostSharp.CodeModel.CustomAttributeConstructorException">The constructor or a property setter
            threw an exception.</exception>
    </member>
    <member name="M:PostSharp.CodeModel.CustomAttributeDeclaration.WriteILDefinition(PostSharp.ModuleWriter.ILWriter)">
      <summary>
            Writes the IL definition of the current instance.
            </summary>
      <param name="writer">An <see cref="T:PostSharp.ModuleWriter.ILWriter" />.</param>
    </member>
    <member name="M:PostSharp.CodeModel.CustomAttributeDeclaration.Remove">
      <summary>
            Remove the current declaration from its parent.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.CustomAttributeDeclaration.Translate(PostSharp.CodeModel.ModuleDeclaration)">
      <summary>
            Translates the custom attribute so that it can be used in another module.
            </summary>
      <param name="module">A module.</param>
      <returns>A <see cref="T:PostSharp.CodeModel.CustomAttributeDeclaration" /> equivalent to the current instance, but valid
            inside the other <paramref name="module" />.</returns>
    </member>
    <member name="P:PostSharp.CodeModel.CustomAttributeDeclaration.Parent">
      <summary>
            Gets the parent <see cref="T:PostSharp.CodeModel.MetadataDeclaration" />.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.CustomAttributeDeclaration.ConstructorArguments">
      <summary>
            Gets the set of constructor arguments.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.CustomAttributeDeclaration.NamedArguments">
      <summary>
            Gets the set of named arguments.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.CustomAttributeDeclaration.Constructor">
      <summary>
            Gets the custom attribute constructor.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.Collections.CustomAttributeDeclarationCollection">
      <summary>
            Collection of custom attributes (<see cref="T:PostSharp.CodeModel.CustomAttributeDeclaration" />).
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.CustomAttributeDeclarationCollection.GetByTypeEnumerator(PostSharp.CodeModel.IType)">
      <summary>
            Gets an enumerator of all custom attribute instances of a given type.
            </summary>
      <param name="type">Type of requested custom attributes.</param>
      <returns>An enumerator of all custom attribute instances of a given type.
            This method does not return custom attributes <i>derived</i> from
            <paramref name="type" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.CustomAttributeDeclarationCollection.GetOneByType(PostSharp.CodeModel.IType)">
      <summary>
            Gets one or zero custom attribute instance of a given type.
            </summary>
      <param name="type">Type of the requested custom attribute.</param>
      <returns>A <see cref="T:PostSharp.CodeModel.CustomAttributeDeclaration" /> of type <paramref name="type" />,
            or <b>null</b> if no such custom attribute was found.
            This method does not return custom attributes <i>derived</i> from
            <paramref name="type" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.CustomAttributeDeclarationCollection.Contains(PostSharp.CodeModel.IType)">
      <summary>
            Determines whether the current collection contains a custom
            attribute of a given type.
            </summary>
      <param name="type">Type of the seeked custom attribute.</param>
      <returns>
        <b>true</b> if the current collection contains at least
            one custom attribute of type <paramref name="type" />, otherwise
            <b>false</b>.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.CustomAttributeDeclarationCollection.ConstructRuntimeObjects(PostSharp.CodeModel.IType,System.Collections.IList)">
      <summary>
            Constructs runtime objects for some of all declarations contained in the current collection
            and store them in a collection.
            </summary>
      <param name="type">The type that built custom attributes should be of, or <b>null</b> if
            all custom attributes should be built.</param>
      <param name="objects">Collection into which custom attribute instances are added.</param>
      <exception cref="T:PostSharp.CodeModel.CustomAttributeConstructorException">The constructor or a property setter
            threw an exception.</exception>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.CustomAttributeDeclarationCollection.ConstructRuntimeObjects(PostSharp.CodeModel.IType)">
      <summary>
            Constructs runtime objects for some of all declarations contained in the current collection
            and return them as an array.
            </summary>
      <param name="type">The type that built custom attributes should be of, or <b>null</b> if
            all custom attributes should be built.</param>
      <exception cref="T:PostSharp.CodeModel.CustomAttributeConstructorException">The constructor or a property setter
            threw an exception.</exception>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.CustomAttributeDeclarationCollection.MoveContentTo(PostSharp.CodeModel.Collections.CustomAttributeDeclarationCollection)">
      <summary>
            Moved all the custom attributes from this collection to another.
            </summary>
      <param name="target">Collection where the custom attributes
            should be moved.</param>
    </member>
    <member name="T:PostSharp.CodeModel.EventDeclaration">
      <summary>
            Represents an event (<see cref="F:PostSharp.CodeModel.TokenType.Event" />).
            </summary>
      <remarks>
            Events are owned by types (<see cref="T:PostSharp.CodeModel.TypeDefDeclaration" />) and
            are exposed on the <see cref="P:PostSharp.CodeModel.TypeDefDeclaration.Events" /> property.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.EventDeclaration.GetTokenType">
      <summary>
            Gets the metadata token type of the current declaration.
            </summary>
      <returns>A <see cref="T:PostSharp.CodeModel.TokenType" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.EventDeclaration.GetSystemEvent(System.Type[],System.Type[])">
      <summary>
            Gets the system runtime event corresponding to the current event.
            </summary>
      <param name="genericTypeArguments">Array of generic type arguments valid in the current context.</param>
      <param name="genericMethodArguments">Array of generic method arguments valid in the current context.</param>
      <returns>The system runtime <see cref="T:System.Reflection.EventInfo" />, or <b>null</b> if
            the current event could not be bound.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.EventDeclaration.GetReflectionWrapper(System.Type[],System.Type[])">
      <summary>
            Gets a reflection <see cref="T:System.Reflection.EventInfo" /> that wraps the current event.
            </summary>
      <param name="genericTypeArguments">Array of generic type arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <param name="genericMethodArguments">Array of generic method arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <returns>A <see cref="T:System.Reflection.EventInfo" /> wrapping current event in the
            given generic context.</returns>
      <remarks>
            This method returns a <see cref="T:System.Reflection.EventInfo" /> that is different from the system
            runtime event that is retrieved by <see cref="M:PostSharp.CodeModel.EventDeclaration.GetSystemEvent(System.Type[],System.Type[])" />. This allows
            a have a <b>System.Reflection</b> representation of the current event even
            when the declaring type it cannot be loaded in the Virtual Runtime Engine.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.EventDeclaration.WriteILDefinition(PostSharp.ModuleWriter.ILWriter)">
      <summary>
            Writes the IL definition of the current instance.
            </summary>
      <param name="writer">An <see cref="T:PostSharp.ModuleWriter.ILWriter" />.</param>
    </member>
    <member name="M:PostSharp.CodeModel.EventDeclaration.Remove">
      <summary>
            Remove the current declaration from its parent.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.EventDeclaration.ClearCache" />
    <member name="P:PostSharp.CodeModel.EventDeclaration.Attributes">
      <summary>
            Gets or sets the event attributes.
            </summary>
      <value>
            A combination of <see cref="T:System.Reflection.EventAttributes" />.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.EventDeclaration.EventType">
      <summary>
            Gets or sets the type of the event handler.
            </summary>
      <value>
            A delegate type.
            </value>
    </member>
    <member name="T:PostSharp.CodeModel.Collections.EventDeclarationCollection">
      <summary>
            Collection of events.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.ParameterDeclaration">
      <summary>
            Represents a method parameter (<see cref="F:PostSharp.CodeModel.TokenType.ParamDef" />). 
            </summary>
      <remarks>
            Parameters are
            owned by methods (<see cref="T:PostSharp.CodeModel.MethodDefDeclaration" />).
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.ParameterDeclaration.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.ParameterDeclaration" />.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.ParameterDeclaration.#ctor(System.Int32,System.String,PostSharp.CodeModel.ITypeSignature)">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.ParameterDeclaration" /> and sets some of its properties.
            </summary>
      <param name="ordinal">Position of the parameter in the signature.</param>
      <param name="name">Parameter name.</param>
      <param name="parameterType">Parameter type.</param>
    </member>
    <member name="M:PostSharp.CodeModel.ParameterDeclaration.GetTokenType" />
    <member name="M:PostSharp.CodeModel.ParameterDeclaration.ToString" />
    <member name="M:PostSharp.CodeModel.ParameterDeclaration.GetSystemParameter(System.Type[],System.Type[])">
      <summary>
            Gets the system runtime parameter corresponding to the current parameter.
            </summary>
      <param name="genericTypeArguments">Array of generic type arguments valid in the current context.</param>
      <param name="genericMethodArguments">Array of generic method arguments valid in the current context.</param>
      <returns>The system runtime <see cref="T:System.Reflection.ParameterInfo" />, or <b>null</b> if
            the current parameter could not be bound.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.ParameterDeclaration.GetReflectionWrapper(System.Type[],System.Type[])">
      <summary>
            Gets a reflection <see cref="T:System.Reflection.ParameterInfo" /> that wraps the current parameter.
            </summary>
      <param name="genericTypeArguments">Array of generic type arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <param name="genericMethodArguments">Array of generic method arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <returns>A <see cref="T:System.Reflection.ParameterInfo" /> wrapping current parameter in the
            given generic context.</returns>
      <remarks>
            This method returns a <see cref="T:System.Reflection.ParameterInfo" /> that is different from the system
            runtime parameter that is retrieved by <see cref="M:PostSharp.CodeModel.ParameterDeclaration.GetSystemParameter(System.Type[],System.Type[])" />. This allows
            a have a <b>System.Reflection</b> representation of the current parameter even
            when the declaring type it cannot be loaded in the Virtual Runtime Engine.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.ParameterDeclaration.WriteILDefinition(PostSharp.ModuleWriter.ILWriter)">
      <summary>
            Writes the IL definition of the current instance.
            </summary>
      <param name="writer">An <see cref="T:PostSharp.ModuleWriter.ILWriter" />.</param>
    </member>
    <member name="M:PostSharp.CodeModel.ParameterDeclaration.Clone(PostSharp.CodeModel.ModuleDeclaration)">
      <summary>
            Returns a copy of the current parameter and allows to translate it
            to a different module as the module of the current parameter.
            </summary>
      <returns>A copy of the current parameter, detached from its parent method,
            translated to <paramref name="targetModule" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.ParameterDeclaration.Clone">
      <summary>
            Returns a copy of the current parameter, targeted to the same module
            as the current parameter.
            </summary>
      <returns>A copy of the current parameter, detached from its parent method,
            but related to the same module as the current parameter.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.ParameterDeclaration.CreateReturnParameter(PostSharp.CodeModel.ITypeSignature)">
      <summary>
            Creates a new instance of <see cref="T:PostSharp.CodeModel.ParameterDeclaration" /> representing a return parameter.
            </summary>
      <param name="returnType">Return type.</param>
      <returns>A new instance of <see cref="T:PostSharp.CodeModel.ParameterDeclaration" /> whose parameter type is <paramref name="returnType" />,
            representing a return parameter.</returns>
    </member>
    <member name="P:PostSharp.CodeModel.ParameterDeclaration.Name">
      <summary>
            Gets or sets the parameter name.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.ParameterDeclaration.ParameterType">
      <summary>
            Gets or sets the parameter type.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.ParameterDeclaration.Parent">
      <summary>
            Gets the parent <see cref="T:PostSharp.CodeModel.MethodDefDeclaration" />.
            </summary>
      <remarks>
            This is a synonym to <see cref="P:PostSharp.CodeModel.ParameterDeclaration.DeclaringMethod" />.
            </remarks>
    </member>
    <member name="P:PostSharp.CodeModel.ParameterDeclaration.DeclaringMethod">
      <summary>
            Gets the parent <see cref="T:PostSharp.CodeModel.MethodDefDeclaration" />.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.ParameterDeclaration.Attributes">
      <summary>
            Gets or sets the parameters attributes.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.ParameterDeclaration.DefaultValue">
      <summary>
            Gets or sets the default value.
            </summary>
      <remarks>
            A <see cref="T:PostSharp.CodeModel.SerializedValue" />, or <b>null</b> if the parameter
            has no default value.
            </remarks>
    </member>
    <member name="P:PostSharp.CodeModel.ParameterDeclaration.MarshalType">
      <summary>
            Gets or sets the parameter marshal type.
            </summary>
      <value>
            A <see cref="P:PostSharp.CodeModel.ParameterDeclaration.MarshalType" />, or <b>null</b> if the parameter has
            default marshalling.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.ParameterDeclaration.Ordinal">
      <summary>
            Gets or sets the parameter ordinal, i.e. its position
            in the list of parameters of the parent method.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.Collections.ParameterDeclarationCollection">
      <summary>
            Collection of parameters (<see cref="T:PostSharp.CodeModel.ParameterDeclaration" />).
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.ParameterDeclarationCollection.DoLazyLoading" />
    <member name="P:PostSharp.CodeModel.Collections.ParameterDeclarationCollection.IsLazyLoadingSupported" />
    <member name="T:PostSharp.CodeModel.PropertyDeclaration">
      <summary>
            Represents a property (<see cref="F:PostSharp.CodeModel.TokenType.Property" />).
            </summary>
      <remarks>
            Properties are owned by types (<see cref="T:PostSharp.CodeModel.TypeDefDeclaration" />).
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.PropertyDeclaration.GetTokenType">
      <summary>
            Gets the metadata token type of the current declaration.
            </summary>
      <returns>A <see cref="T:PostSharp.CodeModel.TokenType" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.PropertyDeclaration.GetSystemProperty(System.Type[],System.Type[])">
      <summary>
            Gets the system runtime property corresponding to the current property.
            </summary>
      <param name="genericTypeArguments">Array of generic type arguments valid in the current context.</param>
      <param name="genericMethodArguments">Array of generic method arguments valid in the current context.</param>
      <returns>The system runtime <see cref="T:System.Reflection.PropertyInfo" />, or <b>null</b> if
            the current property could not be bound.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.PropertyDeclaration.GetReflectionWrapper(System.Type[],System.Type[])">
      <summary>
            Gets a reflection <see cref="T:System.Reflection.PropertyInfo" /> that wraps the current property.
            </summary>
      <param name="genericTypeArguments">Array of generic type arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <param name="genericMethodArguments">Array of generic method arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <returns>A <see cref="T:System.Reflection.PropertyInfo" /> wrapping current property in the
            given generic context.</returns>
      <remarks>
            This method returns a <see cref="T:System.Reflection.PropertyInfo" /> that is different from the system
            runtime property that is retrieved by <see cref="M:PostSharp.CodeModel.PropertyDeclaration.GetSystemProperty(System.Type[],System.Type[])" />. This allows
            a have a <b>System.Reflection</b> representation of the current property even
            when the declaring type it cannot be loaded in the Virtual Runtime Engine.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.PropertyDeclaration.WriteILDefinition(PostSharp.ModuleWriter.ILWriter)">
      <summary>
            Writes the IL definition of the current instance.
            </summary>
      <param name="writer">An <see cref="T:PostSharp.ModuleWriter.ILWriter" />.</param>
    </member>
    <member name="M:PostSharp.CodeModel.PropertyDeclaration.Remove">
      <summary>
            Remove the current declaration from its parent.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.PropertyDeclaration.ClearCache" />
    <member name="P:PostSharp.CodeModel.PropertyDeclaration.Parent">
      <summary>
            Gets the parent <see cref="T:PostSharp.CodeModel.TypeDefDeclaration" />.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.PropertyDeclaration.Parameters">
      <summary>
            Gets the collection of parameter types.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.PropertyDeclaration.CallingConvention">
      <summary>
            Gets or sets the calling convention.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.PropertyDeclaration.PropertyType">
      <summary>
            Gets or sets the type of the property value.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.PropertyDeclaration.Attributes">
      <summary>
            Gets or sets the property attributes.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.PropertyDeclaration.DefaultValue">
      <summary>
            Gets or sets the default value.
            </summary>
      <value>
            A <see cref="T:PostSharp.CodeModel.SerializedValue" />, or <b>null</b> if the property
            has no default value.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.PropertyDeclaration.CanRead">
      <summary>
            Determines whether the current property can be read (i.e. has a <b>get</b> accessor).
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.PropertyDeclaration.Getter">
      <summary>
            Gets the getter accessor, or <b>null</b> if the current property has no getter.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.PropertyDeclaration.CanWrite">
      <summary>
            Determines whether the current property can be written (i.e. has a <b>set</b> accessor).
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.PropertyDeclaration.Setter">
      <summary>
            Gets the getter accessor, or <b>null</b> if the current property has no getter.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.Collections.PropertyDeclarationCollection">
      <summary>
            Collection of properties (<see cref="T:PostSharp.CodeModel.PropertyDeclaration" />).
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.PropertyDeclarationCollection.GetProperty(System.String,PostSharp.CodeModel.IMethodSignature)">
      <summary>
            Gets a property given its name and the signature of its get accessor.
            </summary>
      <param name="name">Property name.</param>
      <param name="getterSignature">Signature of the get accessor.</param>
      <returns>The property named <paramref name="name" /> whose get accessor has the signature
            <paramref name="getterSignature" />, or <b>null</b> if there no such a property.</returns>
    </member>
    <member name="T:PostSharp.CodeModel.PermissionSetDeclaration">
      <summary>
            Represents a permission set (<see cref="F:PostSharp.CodeModel.TokenType.Permission" />). 
            </summary>
      <remarks>
        <para>
            Permissions sets are
            owned by types implementing <see cref="T:PostSharp.CodeModel.ISecurable" />, i.e.
            types (<see cref="T:PostSharp.CodeModel.TypeDefDeclaration" />) and methods (<see cref="T:PostSharp.CodeModel.MethodDefDeclaration" />).
            </para>
        <para>
            A permission set can be represented in the PE image either as a serialized custom
            attributes (in such case the <see cref="P:PostSharp.CodeModel.PermissionSetDeclaration.Attributes" /> property is set),
            either as XML (in such case the <see cref="P:PostSharp.CodeModel.PermissionSetDeclaration.Xml" /> property is set).
            </para>
      </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.PermissionSetDeclaration.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.PermissionSetDeclaration" />.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.PermissionSetDeclaration.GetTokenType" />
    <member name="M:PostSharp.CodeModel.PermissionSetDeclaration.WriteILDefinition(PostSharp.ModuleWriter.ILWriter)">
      <summary>
            Writes the IL definition of the current instance.
            </summary>
      <param name="writer">An <see cref="T:PostSharp.ModuleWriter.ILWriter" />.</param>
    </member>
    <member name="P:PostSharp.CodeModel.PermissionSetDeclaration.SecurityAction">
      <summary>
            Gets or sets the <see cref="P:PostSharp.CodeModel.PermissionSetDeclaration.SecurityAction" /> of the current permission set.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.PermissionSetDeclaration.Attributes">
      <summary>
            Gets the collection of permission attributes (<see cref="T:PostSharp.CodeModel.PermissionDeclaration" />).
            </summary>
      <remarks>
            This collection is not relevant if the <see cref="P:PostSharp.CodeModel.PermissionSetDeclaration.Xml" />
            property is not null.
            </remarks>
    </member>
    <member name="P:PostSharp.CodeModel.PermissionSetDeclaration.Xml">
      <summary>
            Gets the XML representation.
            </summary>
      <value>
            A <see cref="T:System.String" /> containing the XML representation, or <b>null</b> if the
            permission set is binarily serialized, in which case individual attributes
            are available on the <see cref="P:PostSharp.CodeModel.PermissionSetDeclaration.Attributes" /> property.
            </value>
    </member>
    <member name="T:PostSharp.CodeModel.Collections.PermissionSetDeclarationCollection">
      <summary>
            Collection of permission sets (<see cref="T:PostSharp.CodeModel.PermissionSetDeclaration" />).
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.ModuleDeclaration">
      <summary>
            Represents a module (<see cref="F:PostSharp.CodeModel.TokenType.Module" />).
            </summary>
      <remarks>
        <para>
             Since PostSharp is module-centric, a module contains all other declarations.
            </para>
      </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.ModuleDeclaration.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.ModuleDeclaration" />.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.ModuleDeclaration.GetTokenType">
      <summary>
            Gets the metadata token type of the current declaration.
            </summary>
      <returns>A <see cref="T:PostSharp.CodeModel.TokenType" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.ModuleDeclaration.GetDeclarationEnumerator(PostSharp.CodeModel.TokenType)">
      <summary>
            Gets an enumeration of declarations of a given type.
            </summary>
      <param name="tokenType">Types of declaration to be retrieved.</param>
      <returns>An enumerator of all declarations of type <see cref="T:PostSharp.CodeModel.TokenType" /> present
            in the current module.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.ModuleDeclaration.WriteILDefinition(PostSharp.ModuleWriter.ILWriter)">
      <summary>
            Writes the IL definition of the current instance.
            </summary>
      <param name="writer">An <see cref="T:PostSharp.ModuleWriter.ILWriter" />.</param>
    </member>
    <member name="M:PostSharp.CodeModel.ModuleDeclaration.GetSystemModule">
      <summary>
            Gets the runtime module corresponding to the current instance.
            </summary>
      <returns>A <see cref="T:System.Reflection.Module" />, or <b>null</b> if the current instance does not correspond
            to any runtime module.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.ModuleDeclaration.FindMscorlib">
      <summary>
            Finds the <b>mscorlib</b> assembly referred to by the current module.
            </summary>
      <returns>An <see cref="T:PostSharp.CodeModel.AssemblyRefDeclaration" />, or the current <see cref="T:PostSharp.CodeModel.AssemblyEnvelope" />
            if the current module is <b>mscorlib</b>.
            </returns>
    </member>
    <member name="M:PostSharp.CodeModel.ModuleDeclaration.FindAssembly(System.Reflection.Assembly,PostSharp.CodeModel.BindingOptions)">
      <overloads>Finds an assembly in the current module.</overloads>
      <summary>
            Finds in the current module an assembly corresponding to a given runtime assembly.
            </summary>
      <param name="reflectionAssembly">A runtime <see cref="P:PostSharp.CodeModel.ModuleDeclaration.Assembly" />.</param>
      <param name="bindingOptions">Determines the behavior of the binding
            in case that <paramref name="reflectionAssembly" /> could not be found in the current module.</param>
      <returns>The <see cref="T:PostSharp.CodeModel.IAssembly" /> corresponding to <paramref name="reflectionAssembly" />,
            or <b>null</b> if no assembly was found.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.ModuleDeclaration.FindAssembly(PostSharp.CodeModel.IAssemblyName,PostSharp.CodeModel.BindingOptions)">
      <summary>
            Finds in the current module an assembly corresponding to a given <see cref="T:System.Reflection.AssemblyName" />.
            </summary>
      <param name="assemblyName">An <see cref="T:System.Reflection.AssemblyName" />.</param>
      <param name="bindingOptions">Determines the behavior of the binding
            in case that <paramref name="assemblyName" /> could not be found in the current module.</param>
      <returns>The <see cref="T:PostSharp.CodeModel.IAssembly" /> corresponding to <paramref name="assemblyName" />,
            or <b>null</b> if no assembly was found.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.ModuleDeclaration.FindType(System.String,PostSharp.CodeModel.BindingOptions)">
      <overloads>Finds a type in the current module.</overloads>
      <summary>
            Finds in the current module a type given its full name.
            </summary>
      <param name="fullTypeName">The full type name, including the assembly name.</param>
      <param name="bindingOptions">Determines the behavior of the binder in case
            that the assembly and/or type could not be found in the current module.</param>
      <returns>The requested type.</returns>
      <exception cref="T:PostSharp.CodeModel.BindingException">The type could not be found.</exception>
    </member>
    <member name="M:PostSharp.CodeModel.ModuleDeclaration.FindField(System.Reflection.FieldInfo,PostSharp.CodeModel.BindingOptions)">
      <summary>
            Finds in the current module a field given its runtime representation (<see cref="T:System.Reflection.FieldInfo" />).
            </summary>
      <param name="reflectionField">The runtime field representation.</param>
      <param name="bindingOptions">Binding options.</param>
      <returns>The requested field, or <b>null</b> if the requested field
            could not be found.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.ModuleDeclaration.FindMethod(System.String,System.String,System.Predicate{PostSharp.CodeModel.MethodDefDeclaration})">
      <summary>
            Finds a method given the name of its declaring type, the method name, and a predicate.
            </summary>
      <param name="typeName">Name of the declaring type.</param>
      <param name="methodName">Method name.</param>
      <param name="predicate">Predicate evaluated for each method overload. It can be true only once.</param>
      <returns>The method.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.ModuleDeclaration.FindMethod(PostSharp.CodeModel.ITypeSignature,System.String)">
      <summary>
            Finds a method in the current module given its declaring type and the method name.
            </summary>
      <param name="type">Type declaring the method.</param>
      <param name="methodName">Method name.</param>
      <returns>The method.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.ModuleDeclaration.FindMethod(PostSharp.CodeModel.ITypeSignature,System.String,System.Int32)">
      <summary>
            Finds a method in the current module given its declaring type, its name, and its
            number of parameters.
            </summary>
      <param name="type">Type declaring the method.</param>
      <param name="methodName">Method name.</param>
      <param name="parameterCount">Number of parameters of the method.</param>
      <returns>The method.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.ModuleDeclaration.FindMethod(PostSharp.CodeModel.ITypeSignature,System.String,System.Predicate{PostSharp.CodeModel.MethodDefDeclaration})">
      <summary>
            Finds a method in the current module given its declaring type, its name,
            and a predicate.
            </summary>
      <param name="type">Type declaring the method.</param>
      <param name="methodName">Method name.</param>
      <param name="predicate">Predicate determining of the method is the right one.</param>
      <returns>The method.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.ModuleDeclaration.FindMethod(PostSharp.CodeModel.TypeDefDeclaration,System.String,System.Predicate{PostSharp.CodeModel.MethodDefDeclaration})">
      <summary>
            Finds a method in the current module given its declaring type, its name,
            and a predicate.
            </summary>
      <param name="typeDef">Type declaring the method.</param>
      <param name="methodName">Method name.</param>
      <param name="predicate">Predicate determining of the method is the right one.</param>
      <returns>The method.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.ModuleDeclaration.FindMethod(System.String,System.String)">
      <summary>
            Finds a method in a type given its name.
            </summary>
      <param name="typeName">Name of the type declaring the method.</param>
      <param name="methodName">Method name (should be unique in that type).</param>
      <returns>The method.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.ModuleDeclaration.FindMethod(System.String,System.String,System.Int32)">
      <summary>
            Finds a method in a type given its name and number of parameters.
            </summary>
      <param name="typeName">Name of the type declaring the method.</param>
      <param name="methodName">Method name.</param>
      <param name="parameterCount">Number of parameters of the method
            (there should be a single method named <paramref name="methodName" /> with that
            number of parameters).</param>
      <returns>The method.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.ModuleDeclaration.FindMethod(System.String,System.String,System.String[])">
      <summary>
            Finds a method in a type given its name and the name of the parameter types.
            </summary>
      <param name="typeName">Name of the type declaring the method.</param>
      <param name="methodName">Method name.</param>
      <param name="parameterTypeNames">Name of the parameter types.</param>
      <returns>The method.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.ModuleDeclaration.FindMethod(System.Reflection.MethodBase,PostSharp.CodeModel.BindingOptions)">
      <summary>
            Finds in the current module a method given its runtime representation (<see cref="T:System.Reflection.MethodBase" />).
            </summary>
      <param name="reflectionMethod">The method runtime representation.</param>
      <param name="bindingOptions">Determines the behavior of the binder in case
            that the method could not be found in the current module.</param>
      <returns>The requested method, or <b>null</b> if the requested method
            could not be found.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.ModuleDeclaration.FindType(System.Type,PostSharp.CodeModel.BindingOptions)">
      <summary>
            Finds in the current module a type given its runtime representation.
            </summary>
      <param name="reflectionType">The type reflection representation.</param>
      <param name="bindingOptions">Determines the behavior of the binder in case
            that the type could not be found in the current module.</param>
      <returns>The requested type, or <b>null</b> if the requested type
            could not be found.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.ModuleDeclaration.GetFrameworkVariant" />
    <member name="M:PostSharp.CodeModel.ModuleDeclaration.GetAssemblyNameForFrameworkVariant(System.String)">
      <summary>
            Adds a suffix (<b>.CF</b> or <b>.SL</b>) to an assembly name according to the
            framework to which the current module is linked.
            </summary>
      <param name="assemblyName">Assembly name.</param>
      <returns>The assembly properly suffixed.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.ModuleDeclaration.GetTypeForFrameworkVariant(System.Type)">
      <summary>
            Gets an internal representation for a given type, but for the framework variant
            to which the current module is linked, with default binding options.
            </summary>
      <param name="type">Type.</param>
      <returns>The internal type corresponding to <paramref name="type" />
            for the framework variant to which the current module is linked.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.ModuleDeclaration.GetTypeForFrameworkVariant(System.Type,PostSharp.CodeModel.BindingOptions)">
      <summary>
            Gets an internal representation for a given type, but for the framework variant
            to which the current module is linked, and specifies binding options.
            </summary>
      <param name="type">Type.</param>
      <param name="bindingOptions">Binding options.</param>
      <returns>The internal type corresponding to <paramref name="type" />
            for the framework variant to which the current module is linked.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.ModuleDeclaration.ClearAllTags(System.Guid)">
      <summary>
            Removes, from all elements of this module (<see cref="T:PostSharp.CodeModel.MetadataDeclaration" /> only),
            all tags of a given <see cref="T:System.Guid" />.
            </summary>
      <param name="guid">Tag identification.</param>
    </member>
    <member name="M:PostSharp.CodeModel.ModuleDeclaration.GetMethodSignature(System.Reflection.MethodBase,PostSharp.CodeModel.BindingOptions)">
      <summary>
            Gets a <see cref="T:PostSharp.CodeModel.MethodSignature" /> for a <see cref="T:System.Reflection.MethodBase" />.
            </summary>
      <param name="method">A method.</param>
      <param name="bindingOptions">Binding options.</param>
      <returns>The <see cref="T:PostSharp.CodeModel.MethodSignature" /> corresponding to <paramref name="method" />
            in the current module.</returns>
    </member>
    <member name="P:PostSharp.CodeModel.ModuleDeclaration.Cache">
      <summary>
            Caches a set of frequently used declarations.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.ModuleDeclaration.Subsystem">
      <summary>
            Gets or sets the kind of PE file (library, console executable, graphic executable).
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.ModuleDeclaration.ImageAttributes">
      <summary>
            Gets the attributes of the PE image.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.ModuleDeclaration.FileName">
      <summary>
            Gets the name of the file containing the module.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.ModuleDeclaration.ImageBase">
      <summary>
            Gets or sets the ImageBase value in the NT Optional header.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.ModuleDeclaration.FileAlignment">
      <summary>
            Gets or sets the FileAlignment value in the NT Optional header.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.ModuleDeclaration.StackReserve">
      <summary>
            Gets or sets the SizeOfStackReserve value in the NT Optional header.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.ModuleDeclaration.MetadataVersionString">
      <summary>
            Gets or sets the VersionString field of the metadata header. 
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.ModuleDeclaration.MetadataMinorVersion">
      <summary>
            Gets or sets the MinorVersion field of the metadata header. 
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.ModuleDeclaration.MetadataMajorVersion">
      <summary>
            Gets or sets the MajorVersion field of the metadata header. 
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.ModuleDeclaration.RuntimeMajorVersion">
      <summary>
            Gets or sets the RuntimeMajorVersion field of the CLI header.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.ModuleDeclaration.RuntimeMinorVersion">
      <summary>
            Gets or sets the RuntimeMinorVersion field of the CLI header.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.ModuleDeclaration.TypeSpecs">
      <summary>
            Gets the collection of type specifications (<see cref="T:PostSharp.CodeModel.TypeSpecDeclaration" />).
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.ModuleDeclaration.EntryPoint">
      <summary>
            Gets or sets the entry point of the current module.
            </summary>
      <value>
            A reference to a <see cref="T:PostSharp.CodeModel.MethodDefDeclaration" />, or <b>null</b>
            if the module has no entry point.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.ModuleDeclaration.Types">
      <summary>
            Gets the collection of types (<see cref="T:PostSharp.CodeModel.TypeDefDeclaration" />).
            </summary>
      <remarks>
            Note that this collection does not contain <i>nested</i> types.
            Nested types are nested in their parent type.
            </remarks>
    </member>
    <member name="P:PostSharp.CodeModel.ModuleDeclaration.TypeRefs">
      <summary>
            Gets the collection of type references (<see cref="T:PostSharp.CodeModel.TypeRefDeclaration" />)
            whose resolution scope is the current module.
            </summary>
      <remarks>
            A correct CLI module will <i>not</i> define type references whose
            resolution scope is a module. It will use directly a
            <see cref="F:PostSharp.CodeModel.TokenType.TypeDef" /> token instead of a
            <see cref="F:PostSharp.CodeModel.TokenType.TypeRef" /> token.
            </remarks>
    </member>
    <member name="P:PostSharp.CodeModel.ModuleDeclaration.ModuleRefs">
      <summary>
            Gets the collection of module references (<see cref="T:PostSharp.CodeModel.ModuleRefDeclaration" />).
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.ModuleDeclaration.AssemblyRefs">
      <summary>
            Gets the collection of assembly references (<see cref="T:PostSharp.CodeModel.AssemblyRefDeclaration" />).
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.ModuleDeclaration.Datas">
      <summary>
            Gets the collection of raw data declarations (<see cref="T:PostSharp.CodeModel.DataSectionDeclaration" />).
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.ModuleDeclaration.StandaloneSignatures">
      <summary>
            Gets the collection of standalone signatures (<see cref="T:PostSharp.CodeModel.Collections.StandaloneSignatureDeclarationCollection" />).
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.ModuleDeclaration.Assembly">
      <summary>
            Gets the assembly containing the module.
            </summary>
      <value>
            The assembly (<see cref="T:PostSharp.CodeModel.IAssembly" />) containing the module.
            </value>
    </member>
    <member name="P:PostSharp.CodeModel.ModuleDeclaration.AssemblyManifest">
      <summary>
            Gets or sets the assembly manifest contained in the current module.
            </summary>
      <remarks>
            An <see cref="T:PostSharp.CodeModel.AssemblyManifestDeclaration" />, or <b>null</b> if this
            module does not contain any assembly manifest.
            </remarks>
    </member>
    <member name="P:PostSharp.CodeModel.ModuleDeclaration.ModuleGuid">
      <summary>
            Gets or sets the GUID of the current module.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.ModuleDeclaration.IsMscorlib">
      <summary>
            Determines whether the current module is <b>mscorlib</b>.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.ModuleDeclaration.UnmanagedResources">
      <summary>
            Gets the collection of unmanaged resources.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.ModuleDeclaration.HasDebugInfo">
      <summary>
            Determines whether the current module has debugging information.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.Collections.ModuleDeclarationCollection">
      <summary>
            Collection of modules (<see cref="T:PostSharp.CodeModel.ModuleDeclaration" />).
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.MethodSemanticDeclaration">
      <summary>
            Represents a method semantic (<see cref="F:PostSharp.CodeModel.TokenType.MethodSemantic" />), i.e. the association of a method and a role in 
            a collection (<see cref="T:PostSharp.CodeModel.PropertyDeclaration" /> or <see cref="T:PostSharp.CodeModel.EventDeclaration" />).
            </summary>
      <remarks>
            Method semantics
            are owned by <see cref="T:PostSharp.CodeModel.MethodGroupDeclaration" /> (<see cref="T:PostSharp.CodeModel.PropertyDeclaration" />
            or <see cref="T:PostSharp.CodeModel.EventDeclaration" />).
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.MethodSemanticDeclaration.#ctor">
      <summary>
            Initializes a new empty <see cref="T:PostSharp.CodeModel.MethodSemanticDeclaration" />.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.MethodSemanticDeclaration.#ctor(PostSharp.CodeModel.MethodSemantics,PostSharp.CodeModel.MethodDefDeclaration)">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.MethodSemanticDeclaration" /> and sets its content.
            </summary>
      <param name="semantic">Semantic.</param>
      <param name="method">Method implementing the semantic.</param>
    </member>
    <member name="M:PostSharp.CodeModel.MethodSemanticDeclaration.GetTokenType">
      <summary>
            Gets the metadata token type of the current declaration.
            </summary>
      <returns>A <see cref="T:PostSharp.CodeModel.TokenType" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.MethodSemanticDeclaration.Remove">
      <summary>
            Remove the current declaration from its parent.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodSemanticDeclaration.Method">
      <summary>
            Gets or sets the method linked to the semantic.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodSemanticDeclaration.Semantic">
      <summary>
            Gets or sets the semantic of the method in the containing collection.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.MethodSemanticDeclaration.Parent">
      <summary>
            Gets the parent <see cref="T:PostSharp.CodeModel.MethodGroupDeclaration" />.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.MethodSemanticDeclaration.BySemanticComparer">
      <summary>
            Implementation of <see cref="T:System.Collections.Generic.IComparer`1" /> comparing instances
            by their <see cref="P:PostSharp.CodeModel.MethodSemanticDeclaration.Semantic" /> property.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.MethodSemanticDeclaration.BySemanticComparer.GetInstance">
      <summary>
            Gets an instance of <see cref="T:PostSharp.CodeModel.MethodSemanticDeclaration.BySemanticComparer" />.
            </summary>
      <returns />
    </member>
    <member name="M:PostSharp.CodeModel.MethodSemanticDeclaration.BySemanticComparer.Compare(PostSharp.CodeModel.MethodSemanticDeclaration,PostSharp.CodeModel.MethodSemanticDeclaration)" />
    <member name="T:PostSharp.CodeModel.Collections.MethodSemanticDeclarationCollection">
      <summary>
            Collection of method semantics (<see cref="T:PostSharp.CodeModel.MethodSemanticDeclaration" />).
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.MethodSemanticDeclarationCollection.GetBySemantic(PostSharp.CodeModel.MethodSemantics)">
      <summary>
            Gets the <see cref="T:PostSharp.CodeModel.MethodSemanticDeclaration" /> given its semantic (<see cref="T:PostSharp.CodeModel.MethodSemantics" />).
            </summary>
      <param name="semantic">Method semantic.</param>
      <returns>The <see cref="T:PostSharp.CodeModel.MethodSemanticDeclaration" /> whose semantic equals
            <paramref name="semantic" />, or <b>null</b> if the current collection does not
            contain a method with this semantic.</returns>
      <remarks>
            If the collection contains more than one method with this semantic, the current
            method returns any arbitrary of them.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.MethodSemanticDeclarationCollection.Contains(PostSharp.CodeModel.MethodSemantics)">
      <summary>
            Determines whether the current collection contains a method with given semantic.
            </summary>
      <param name="semantic">Method semantic.</param>
      <returns>
        <b>true</b> if the current collection contains at least one method
            with given semantic, otherwise <b>false</b>.</returns>
    </member>
    <member name="T:PostSharp.CodeModel.MethodSemantics">
      <summary>
            Enumerates the method semantics.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.MethodSemantics.None">
      <summary>
            No semantic.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.MethodSemantics.Setter">
      <summary>
            Setter for property.
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.MethodSemantics.Getter">
      <summary>
            Getter for property
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.MethodSemantics.Other">
      <summary>
            Other method for property or event 
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.MethodSemantics.AddOn">
      <summary>
            AddOn method for event
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.MethodSemantics.RemoveOn">
      <summary>
            	RemoveOn method for event 
            </summary>
    </member>
    <member name="F:PostSharp.CodeModel.MethodSemantics.Fire">
      <summary>
            Fire method for event
            </summary>
    </member>
    <member name="T:PostSharp.PlatformAbstraction.Platform">
      <summary>
            Abstraction of the platform (.NET, Mono) on which PostSharp currently run.
            </summary>
      <remarks>
            This class is not to be confused with <see cref="T:PostSharp.PlatformAbstraction.TargetPlatformAdapter" />, which
            is an abstraction of the platform to which PostSharp should compile. It is theoretically
            possible to build transformed assemblies for a different platform than the current one
            (for instance .NET 1.1 on .NET 2.0), although this feature is not used and not
            supported.
            </remarks>
      <seealso cref="T:PostSharp.PlatformAbstraction.DotNet.DotNet20Platform" />
      <seealso cref="T:PostSharp.PlatformAbstraction.Mono.Mono20Platform" />
    </member>
    <member name="F:PostSharp.PlatformAbstraction.Platform.Current">
      <summary>
            Gets the current <see cref="T:PostSharp.PlatformAbstraction.Platform" />.
            </summary>
    </member>
    <member name="M:PostSharp.PlatformAbstraction.Platform.NormalizeCilIdentifier(System.String)">
      <summary>
            Normalizes a CIL identifier so that it is accepted by ILASM without quoting.
            </summary>
      <param name="name">The identifier name.</param>
      <returns>The normalized identifier name.</returns>
    </member>
    <member name="M:PostSharp.PlatformAbstraction.Platform.CreateAppDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet)">
      <summary>
            Creates an <see cref="T:System.AppDomain" />.
            </summary>
      <param name="name">Name.</param>
      <param name="evidence">Evidence.</param>
      <param name="setup">Setup information.</param>
      <param name="permissions">Permission.</param>
      <returns>A new <see cref="T:System.AppDomain" />.</returns>
    </member>
    <member name="M:PostSharp.PlatformAbstraction.Platform.FindAssemblyInCache(PostSharp.CodeModel.IAssemblyName)">
      <summary>
            Finds an assembly in GAC.
            </summary>
      <param name="assemblyName">Assembly name.</param>
      <returns>The full path of the assembly in GAC (i.e., on file system), or <b>null</b> if the
            assembly was not found.</returns>
    </member>
    <member name="P:PostSharp.PlatformAbstraction.Platform.IntrinsicOfOppositeSignAssignable">
      <summary>
            Determines whether intrinsics of opposite sign (for instance <see cref="T:System.Int32" />
            and <see cref="T:System.UInt32" />) are assignable.
            </summary>
    </member>
    <member name="P:PostSharp.PlatformAbstraction.Platform.Identity">
      <summary>
            Gets the <see cref="T:PostSharp.PlatformAbstraction.PlatformIdentity" /> for the current platform.
            </summary>
    </member>
    <member name="P:PostSharp.PlatformAbstraction.Platform.DefaultTargetPlatformName">
      <summary>
            Gets the default <see cref="T:PostSharp.PlatformAbstraction.TargetPlatformAdapter" /></summary>
      <value>
            The name of the default <see cref="T:PostSharp.PlatformAbstraction.TargetPlatformAdapter" />
            in <b>PostSharp-Platform.config</b>.
            </value>
    </member>
    <member name="P:PostSharp.PlatformAbstraction.Platform.ReadModuleStrategy">
      <summary>
            Gets the strategy used to read a module (from disk or from memory).
            </summary>
    </member>
    <member name="T:PostSharp.PlatformAbstraction.DotNet.DotNet20TargetPlatformAdapter">
      <summary>
            Implements a <see cref="T:PostSharp.PlatformAbstraction.TargetPlatformAdapter" /> specifically for the .NET Framework 2.0.
            </summary>
    </member>
    <member name="T:PostSharp.PlatformAbstraction.TargetPlatformAdapter">
      <summary>
            Provides platform-specific functionalities to compile for
            a specific target platform.
            </summary>
      <remarks>
            Additionally to implementing all abstract methods, derived class
            should also implement a constructor taking a <see cref="T:System.Collections.Specialized.NameValueCollection" />
            as its only parameter.
            </remarks>
    </member>
    <member name="M:PostSharp.PlatformAbstraction.TargetPlatformAdapter.GetDefaultMsilEncoding">
      <summary>
            Gets the default <see cref="T:System.Text.Encoding" /> for MSIL text files.
            </summary>
      <returns>An <see cref="T:System.Text.Encoding" />.</returns>
    </member>
    <member name="M:PostSharp.PlatformAbstraction.TargetPlatformAdapter.GetILWriterCompatibility">
      <summary>
            Gets compatibility flags for the IL generation process.
            </summary>
      <returns>A combination of <see cref="T:PostSharp.ModuleWriter.ILWriterCompatibility" /> flags.</returns>
    </member>
    <member name="M:PostSharp.PlatformAbstraction.TargetPlatformAdapter.Assemble(PostSharp.CodeModel.ModuleDeclaration,PostSharp.Extensibility.AssembleOptions)">
      <summary>
            Assembles text IL code to a binary module.
            </summary>
      <param name="module">The module to assemble (module properties, like target
            architecture, have to be read here).</param>
      <param name="options">Options</param>
    </member>
    <member name="M:PostSharp.PlatformAbstraction.TargetPlatformAdapter.Verify(System.String)">
      <summary>
            Executes the PEVERIFY utility against a file.
            </summary>
      <param name="file">The path of the file to be verified.</param>
      <remarks>
            The implementation should write a warning (not an error) if the PEVERIFY utility is not installed.
            </remarks>
    </member>
    <member name="M:PostSharp.PlatformAbstraction.DotNet.DotNet20TargetPlatformAdapter.#ctor(System.Collections.Specialized.NameValueCollection)">
      <summary>
            Initializes a new <see cref="T:PostSharp.PlatformAbstraction.DotNet.DotNet20TargetPlatformAdapter" />.
            </summary>
      <param name="parameters">Collection of configured parameters.</param>
    </member>
    <member name="M:PostSharp.PlatformAbstraction.DotNet.DotNet20TargetPlatformAdapter.GetBootstrapper">
      <summary>
            Gets the name of the .NET bootstrapper.
            </summary>
      <returns>The name of the .NET bootstrapper (a valid command line).</returns>
      <remarks>
            No bootstrapper is necessary on the Microsoft implementation of .NET,
            but Mono requires a bootstrapper.
            </remarks>
    </member>
    <member name="M:PostSharp.PlatformAbstraction.DotNet.DotNet20TargetPlatformAdapter.Assemble(PostSharp.CodeModel.ModuleDeclaration,PostSharp.Extensibility.AssembleOptions)" />
    <member name="M:PostSharp.PlatformAbstraction.DotNet.DotNet20TargetPlatformAdapter.Verify(System.String)" />
    <member name="M:PostSharp.PlatformAbstraction.DotNet.DotNet20TargetPlatformAdapter.GetDefaultMsilEncoding" />
    <member name="M:PostSharp.PlatformAbstraction.DotNet.DotNet20TargetPlatformAdapter.GetILWriterCompatibility" />
    <member name="T:PostSharp.PlatformAbstraction.Mono.Mono20TargetPlatformAdapter">
      <summary>
            Implementation of <see cref="T:PostSharp.PlatformAbstraction.TargetPlatformAdapter" /> for Mono 2.0.
            </summary>
    </member>
    <member name="M:PostSharp.PlatformAbstraction.Mono.Mono20TargetPlatformAdapter.#ctor(System.Collections.Specialized.NameValueCollection)">
      <summary>
            Initializes a new instance of <see cref="T:PostSharp.PlatformAbstraction.Mono.Mono20TargetPlatformAdapter" />.
            </summary>
      <param name="parameters">Collection of parameters.</param>
    </member>
    <member name="M:PostSharp.PlatformAbstraction.Mono.Mono20TargetPlatformAdapter.GetILWriterCompatibility" />
    <member name="M:PostSharp.PlatformAbstraction.Mono.Mono20TargetPlatformAdapter.Assemble(PostSharp.CodeModel.ModuleDeclaration,PostSharp.Extensibility.AssembleOptions)" />
    <member name="M:PostSharp.PlatformAbstraction.Mono.Mono20TargetPlatformAdapter.Verify(System.String)" />
    <member name="M:PostSharp.PlatformAbstraction.Mono.Mono20TargetPlatformAdapter.GetDefaultMsilEncoding" />
    <member name="T:PostSharp.PlatformAbstraction.PlatformIdentity">
      <summary>
            Simple identity of a <see cref="T:PostSharp.PlatformAbstraction.Platform" />.
            </summary>
    </member>
    <member name="F:PostSharp.PlatformAbstraction.PlatformIdentity.Microsoft">
      <summary>
            Microsoft implementation.
            </summary>
    </member>
    <member name="F:PostSharp.PlatformAbstraction.PlatformIdentity.Mono">
      <summary>
            Mono.
            </summary>
    </member>
    <member name="T:PostSharp.ModuleReader.ReadModuleStrategy">
      <summary>
            Determines how a module should be loaded.
            </summary>
    </member>
    <member name="F:PostSharp.ModuleReader.ReadModuleStrategy.FromMemoryImage">
      <summary>
            The module should be loaded from its mapped image in memory,
            after it has been loaded into the CLR.
            </summary>
    </member>
    <member name="F:PostSharp.ModuleReader.ReadModuleStrategy.FromDisk">
      <summary>
            The module should be loaded directly from disk, without
            loading it into the CLR.
            </summary>
    </member>
    <member name="T:PostSharp.CodeModel.TypeSpecDeclaration">
      <summary>
            Represents a type specification (<see cref="F:PostSharp.CodeModel.TokenType.TypeSpec" />).
            </summary>
      <remarks>
            Type specifications are owned by <see cref="T:PostSharp.CodeModel.ModuleDeclaration" />.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSpecDeclaration.#ctor">
      <summary>
            Initializes a new <see cref="T:PostSharp.CodeModel.TypeSpecDeclaration" />.
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSpecDeclaration.GetTokenType">
      <summary>
            Gets the metadata token type of the current declaration.
            </summary>
      <returns>A <see cref="T:PostSharp.CodeModel.TokenType" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSpecDeclaration.ToString" />
    <member name="M:PostSharp.CodeModel.TypeSpecDeclaration.BelongsToClassification(PostSharp.CodeModel.TypeClassifications)">
      <summary>
            Determines whether the type signature belongs to a given classification,
            i.e. whether it fulfills a given predicate.
            </summary>
      <param name="typeClassification">The classification (or predicate) 
            (combination of bits are not allowed).</param>
      <returns>
        <see cref="F:PostSharp.NullableBool.True" /> if the predicate is true, 
            <see cref="F:PostSharp.NullableBool.False" /> if the predicate is false or
            <see cref="F:PostSharp.NullableBool.Null" /> if it cannot be determined. </returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSpecDeclaration.ContainsGenericArguments">
      <summary>
            Determines whether the type signature contains a generic argument.
            </summary>
      <returns>
        <b>true</b> if the type signature contains a generic argument, otherwise <b>false</b>.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSpecDeclaration.MapGenericArguments(PostSharp.CodeModel.GenericMap)">
      <summary>
            Resolves all generic arguments in the current type signature.
            </summary>
      <param name="genericMap">Generic context in which generic arguments have to be resolved.</param>
      <returns>A <see cref="T:PostSharp.CodeModel.IType" /> resolved against <paramref name="genericMap" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSpecDeclaration.GetValueSize(PostSharp.CodeModel.PlatformInfo)">
      <summary>
            Gets the size of the value type.
            </summary>
      <param name="platform">Information about the target platform.</param>
      <returns>The size of the value type in bytes, or -1 if the
            type is not a value type or has no fixed size.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSpecDeclaration.GetSystemType(System.Type[],System.Type[])">
      <summary>
            Gets the system, runtime <see cref="T:System.Type" /> corresponding to the current type.
            </summary>
      <param name="genericTypeArguments">Array of generic type arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <param name="genericMethodArguments">Array of generic method arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <returns>The system <see cref="T:System.Type" /> associated the current type in the
            given generic context.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSpecDeclaration.GetReflectionWrapper(System.Type[],System.Type[])">
      <summary>
            Gets a reflection <see cref="T:System.Type" /> that wraps the current type.
            </summary>
      <param name="genericTypeArguments">Array of generic type arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <param name="genericMethodArguments">Array of generic method arguments in the
            current context, or <b>null</b> if there is no generic type arguments in
            the current context.</param>
      <returns>A <see cref="T:System.Type" /> wrapping current type in the
            given generic context.</returns>
      <remarks>
            This method returns a <see cref="T:System.Type" /> that is different from the system
            runtime type that is retrieved by <see cref="M:PostSharp.CodeModel.ITypeSignature.GetSystemType(System.Type[],System.Type[])" />. This allows
            a have a <b>System.Reflection</b> representation of the current type even
            when it cannot be loaded in the Virtual Runtime Engine.
            </remarks>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSpecDeclaration.GetGenericArgument(System.Int32)">
      <summary>
            Gets a generic (concrete, bound) argument given its ordinal.
            </summary>
      <param name="ordinal">The generic argument ordinal (position).</param>
      <returns>An <see cref="T:PostSharp.CodeModel.IType" />, or <b>null</b>
            if the current generic orginal does not exist.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSpecDeclaration.GetGenericContext(PostSharp.CodeModel.GenericContextOptions)">
      <summary>
            Gets the generic context inside the scope of the generic instance.
            </summary>
      <returns>A <see cref="T:PostSharp.CodeModel.GenericMap" /> mapping ordinals either
            to <see cref="T:PostSharp.CodeModel.GenericParameterDeclaration" /> (in case of
            generic definition), either of the type signature associated
            to this ordinal (in the case of generic instance).</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSpecDeclaration.IsAssignableTo(PostSharp.CodeModel.ITypeSignature,PostSharp.CodeModel.GenericMap)" />
    <member name="M:PostSharp.CodeModel.TypeSpecDeclaration.IsAssignableTo(PostSharp.CodeModel.ITypeSignature)" />
    <member name="M:PostSharp.CodeModel.TypeSpecDeclaration.GetCanonicalHashCode">
      <summary>
            Gets a hash code that is invariant under type signature equality
            (i.e. if two types are equal under <see cref="T:System.IEquatable`1" />, they have the
            same canonical has code).
            </summary>
      <returns>A hash code that is invariant under type signature equality.</returns>
      <remarks>This method is of course useful to build dictionaries. The <see cref="T:PostSharp.CodeModel.Binding.TypeComparer" /> class
            uses this method.</remarks>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSpecDeclaration.Translate(PostSharp.CodeModel.ModuleDeclaration)">
      <summary>
            Translates the current type signature so that it is meaningful in another
            module than the one to which it primarly belong.
            </summary>
      <param name="targetModule">Module into which the type signature should be
            translated.</param>
      <returns>A type signature meaningful in the <paramref name="targetModule" />
            module.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSpecDeclaration.WriteReflectionTypeName(System.Text.StringBuilder,PostSharp.CodeModel.ReflectionNameOptions)">
      <summary>
            Gets the type name as used in <b>System.Reflection</b>.
            </summary>
      <returns>A <see cref="T:System.String" />.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSpecDeclaration.GetTypeDefinition" />
    <member name="M:PostSharp.CodeModel.TypeSpecDeclaration.GetTypeDefinition(PostSharp.CodeModel.BindingOptions)" />
    <member name="M:PostSharp.CodeModel.TypeSpecDeclaration.Unwrap(PostSharp.CodeModel.ITypeSignature)">
      <summary>
            Conditionally unwraps the <see cref="T:PostSharp.CodeModel.ITypeSignature" /> contained in a <see cref="T:PostSharp.CodeModel.TypeSpecDeclaration" />.
            </summary>
      <param name="signature">A signature (eventually a <see cref="T:PostSharp.CodeModel.TypeSpecDeclaration" />).</param>
      <returns>If <paramref name="signature" /> is a <see cref="T:PostSharp.CodeModel.TypeSpecDeclaration" />, the current
            method returns the signature contained in the <see cref="T:PostSharp.CodeModel.TypeSpecDeclaration" />. Otherwise,
            <paramref name="signature" /> is returned.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSpecDeclaration.Visit(System.String,PostSharp.Collections.Visitor{PostSharp.CodeModel.ITypeSignature})">
      <summary>
            Requires a callback method (named <i>visitor</i>) to be called
            for each item of a given role in the current object, recursively.
            </summary>
      <param name="role">Role of items to be visited, or <b>null</b> if all items
            of type <typeparamref name="T" /> should be visited.</param>
      <param name="visitor">Delegate that should be called when an
            item in the given role is found.</param>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSpecDeclaration.Equals(PostSharp.CodeModel.ITypeSignature)" />
    <member name="M:PostSharp.CodeModel.TypeSpecDeclaration.MatchesReference(PostSharp.CodeModel.ITypeSignature)">
      <summary>
            Determines whether the current type signature matches a given type signature.
            </summary>
      <param name="reference">The type reference.</param>
      <returns>
        <b>true</b> if the current type signature matches <paramref name="reference" />,
            otherwise <b>false</b>.</returns>
      <remarks>A type reference can use an incomplete assembly reference. Therefore, the matching
            is performed using <see cref="M:PostSharp.CodeModel.IAssembly.MatchesReference(PostSharp.CodeModel.IAssemblyName)" />.
            Matching an assembly reference is a looser requirement than matching an assembly name exactly;
            an assembly reference may set no requirement on the public key token or the version, for instance.</remarks>
    </member>
    <member name="M:PostSharp.CodeModel.TypeSpecDeclaration.GetSiblings">
      <summary>
            Gets all instances of <see cref="T:PostSharp.CodeModel.TypeSpecDeclaration" /> that have the same signature.
            </summary>
      <returns>The set of all instances of <see cref="T:PostSharp.CodeModel.TypeSpecDeclaration" /> 
            that have the same signature.</returns>
      <remarks>
            Compilers are supposed to generate a unique <see cref="T:PostSharp.CodeModel.TypeSpecDeclaration" /> for
            each signature. However, this rule is not always respected.
            </remarks>
    </member>
    <member name="P:PostSharp.CodeModel.TypeSpecDeclaration.FieldRefs">
      <summary>
            Gets the collection of fields (<see cref="T:PostSharp.CodeModel.FieldRefDeclaration" />) 
            defined on the current object.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeSpecDeclaration.Attributes">
      <summary>
            Gets or sets the type attributes.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeSpecDeclaration.IsSealed">
      <summary>
            Determines whether the type is sealed.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeSpecDeclaration.IsInterface">
      <summary>
            Determines whether the type is an interface.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeSpecDeclaration.IsAbstract">
      <summary>
            Determines whether the class is abstract.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeSpecDeclaration.MethodRefs">
      <summary>
            Gets the collection of methods (<see cref="T:PostSharp.CodeModel.MethodRefDeclaration" />)
            defined on the current object.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeSpecDeclaration.Signature">
      <summary>
            Gets or sets the type signature specifying the current type specification.
            </summary>
    </member>
    <member name="P:PostSharp.CodeModel.TypeSpecDeclaration.IsGenericInstance">
      <summary>
            Determines whether the current instance is a generic instance, i.e. whether it has
            been constructed from a generic definition.
            </summary>
      <remarks>
            If the current property returns <b>true</b>, the semantics of <see cref="T:PostSharp.CodeModel.IGenericInstance" />
            are meaningfull for the current intance.
            </remarks>
    </member>
    <member name="T:PostSharp.CodeModel.Collections.TypeSpecDeclarationCollection">
      <summary>
            Collection of type specifications (<see cref="T:PostSharp.CodeModel.Collections.TypeSpecDeclarationCollection" />).
            </summary>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.TypeSpecDeclarationCollection.GetBySignature(PostSharp.CodeModel.ITypeSignature)">
      <summary>
            Gets the type specification corresponding to a given <see cref="T:PostSharp.CodeModel.IType" />
            but does not create it if it is not found.
            </summary>
      <param name="signature">A <see cref="T:PostSharp.CodeModel.IType" />.</param>
      <returns>The <see cref="T:PostSharp.CodeModel.TypeSpecDeclaration" /> corresponding to
            <paramref name="signature" />, or <b>null</b> if no type specification
            in the collection corresponds to the current signature.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.TypeSpecDeclarationCollection.GetBySignature(PostSharp.CodeModel.ITypeSignature,System.Boolean)">
      <summary>
            Gets the type specification corresponding to a given <see cref="T:PostSharp.CodeModel.IType" />
            and specifies whether to create it if it is not found.
            </summary>
      <param name="signature">A <see cref="T:PostSharp.CodeModel.IType" />.</param>
      <param name="create">Whether the <see cref="T:PostSharp.CodeModel.TypeSpecDeclaration" /> should be created if not found.</param>
      <returns>The <see cref="T:PostSharp.CodeModel.TypeSpecDeclaration" /> corresponding to
            <paramref name="signature" />, or <b>null</b> if no type specification
            in the collection corresponds to the current signature and the <paramref name="create" /> parameter is <b>false</b>.</returns>
    </member>
    <member name="M:PostSharp.CodeModel.Collections.TypeSpecDeclarationCollection.GetSiblingsBySignature(PostSharp.CodeModel.ITypeSignature)">
      <summary>
            Gets all type specifications corresponding to a given <see cref="T:PostSharp.CodeModel.IType" />.
            </summary>
      <param name="signature">A <see cref="T:PostSharp.CodeModel.IType" />.</param>
      <returns>The set of <see cref="T:PostSharp.CodeModel.TypeSpecDeclaration" /> instances corresponding to
            <paramref name="signature" />, or an empty collection if no type specification
            in the collection corresponds to <paramref name="signature" />.</returns>
    </member>
    <member name="T:PostSharp.ModuleWriter.ILWriterOptions">
      <summary>
            Options influencing the process of writing the code model to an IL source file.
            </summary>
      <remarks>
            This class contains additionally some information about the current context
            of the IL source file.
            </remarks>
    </member>
    <member name="P:PostSharp.ModuleWriter.ILWriterOptions.Compatibility">
      <summary>
            Gets or sets the compatibility of the output. Currently not used consistently.
            </summary>
    </member>
    <member name="P:PostSharp.ModuleWriter.ILWriterOptions.TraceEnabled">
      <summary>
            Determines whether tracing of output is enabled.
            </summary>
    </member>
    <member name="P:PostSharp.ModuleWriter.ILWriterOptions.VerboseCustomAttributes">
      <summary>
            Determines whether custom attributes should inconditionally
            be rendered in the "verbose" form (i.e. in deserialized form).
            </summary>
    </member>
    <member name="P:PostSharp.ModuleWriter.ILWriterOptions.ReleaseBodyAfterWrite">
      <summary>
            Determines whether the method body should be released (that is, deleted from memory)
            after having been written to MSIL. Default is <b>true</b>.
            </summary>
    </member>
    <member name="T:PostSharp.ModuleWriter.ILWriterCompatibility">
      <summary>
            Compatibility options for the generation of the IL source file.
            </summary>
    </member>
    <member name="F:PostSharp.ModuleWriter.ILWriterCompatibility.Default">
      <summary>
            Default behavior.
            </summary>
    </member>
    <member name="F:PostSharp.ModuleWriter.ILWriterCompatibility.ForceWriteTypePacking">
      <summary>
            Writes type packing options even if the type packing is default.
            </summary>
    </member>
    <member name="F:PostSharp.ModuleWriter.ILWriterCompatibility.Bugs">
      <summary>
            Mask of all compatibility flags that are actually bugs.
            </summary>
    </member>
    <member name="F:PostSharp.ModuleWriter.ILWriterCompatibility.EmitTypeList">
      <summary>
            Emit a forward declaration type list at the beginning of the MSIL file.
            </summary>
    </member>
    <member name="F:PostSharp.ModuleWriter.ILWriterCompatibility.EmitMethodSemanticsBySemanticOrder">
      <summary>
            Emit method semantics (inside properties and events) by semantic order
            (see <see cref="T:PostSharp.CodeModel.MethodSemanticDeclaration.BySemanticComparer" /> instead
            of by original order.
            </summary>
    </member>
    <member name="F:PostSharp.ModuleWriter.ILWriterCompatibility.IgnoreEscapeQuestionMark">
      <summary>
            Does not escape the question mark in quoted strings.
            </summary>
    </member>
    <member name="F:PostSharp.ModuleWriter.ILWriterCompatibility.LowerCaseFloat">
      <summary>
            Write floating numbers with a lower case 'e' sign.
            </summary>
    </member>
    <member name="F:PostSharp.ModuleWriter.ILWriterCompatibility.AllDigitsFloat">
      <summary>
            Write all digits in floating numbers.
            </summary>
    </member>
    <member name="F:PostSharp.ModuleWriter.ILWriterCompatibility.IgnoreCilQualifierInDataSection">
      <summary>
            Ignore the 'cil' qualifier in data sections (<see cref="T:PostSharp.CodeModel.DataSectionDeclaration" />).
            </summary>
    </member>
    <member name="F:PostSharp.ModuleWriter.ILWriterCompatibility.ForceBreakBeforeBlobs">
      <summary>
            Force line breaks before binary blocks.
            </summary>
    </member>
    <member name="F:PostSharp.ModuleWriter.ILWriterCompatibility.EmitForwardDeclarations">
      <summary>
            Emit a forward declaration list of all methods at the beginning of the MSIL file.
            </summary>
    </member>
    <member name="F:PostSharp.ModuleWriter.ILWriterCompatibility.IgnoreMscorlibHeader">
      <summary>
            Ignore the <c>.mscorlib</c> header directive.
            </summary>
    </member>
    <member name="F:PostSharp.ModuleWriter.ILWriterCompatibility.ForbidVerboseCustomAttribute">
      <summary>
            Do not write verbose custom attributes. Serialize them instead.
            </summary>
    </member>
    <member name="F:PostSharp.ModuleWriter.ILWriterCompatibility.Ms">
      <summary>
            All options necessary for compatibility with Microsoft ILASM.
            </summary>
    </member>
    <member name="F:PostSharp.ModuleWriter.ILWriterCompatibility.MsRoundtrip">
      <summary>
            All options necessary for a roundtrip test using Microsoft ILASM/ILDASM.
            </summary>
    </member>
    <member name="F:PostSharp.ModuleWriter.ILWriterCompatibility.Mono">
      <summary>
            All options necessary for compatibility with Mono ILASM.
            </summary>
    </member>
    <member name="F:PostSharp.ModuleWriter.ILWriterCompatibility.MonoRoundtrip">
      <summary>
            All options necessary for a roundtrip test using Mono ILASM/ILDASM.
            </summary>
    </member>
    <member name="T:PostSharp.Trace">
      <summary>
            Provides tracing functionality. An instance of the <see cref="T:PostSharp.Trace" /> type
            implements a trace sink.
            </summary>
    </member>
    <member name="M:PostSharp.Trace.Initialize">
      <summary>
            Forces initialization of the tracing facility.
            </summary>
    </member>
    <member name="M:PostSharp.Trace.#ctor(System.String)">
      <summary>
            Initialize a new <see cref="T:PostSharp.Trace" /> sink.
            </summary>
      <param name="category">Category of messages.</param>
    </member>
    <member name="M:PostSharp.Trace.Write(System.String,System.Object[])">
      <summary>
            Writes a message to the current sink with many formatting parameters.
            </summary>
      <param name="format">Message formatting string.</param>
      <param name="parameters">Formatting parameters.</param>
    </member>
    <member name="M:PostSharp.Trace.Write(System.String,System.Object)">
      <summary>
            Writes a message to the current sink with a single formatting parameter.
            </summary>
      <param name="format">Message formatting string.</param>
      <param name="arg0">The first formatting parameter.</param>
    </member>
    <member name="M:PostSharp.Trace.Write(System.String,System.Object,System.Object)">
      <summary>
            Writes a message to the current sink with two formatting parameters.
            </summary>
      <param name="format">Message formatting string.</param>
      <param name="arg0">The first formatting parameter.</param>
      <param name="arg1">The second formatting parameter.</param>
    </member>
    <member name="M:PostSharp.Trace.Write(System.String,System.Object,System.Object,System.Object)">
      <summary>
            Writes a message to the current sink with three formatting parameters.
            </summary>
      <param name="format">Message formatting string.</param>
      <param name="arg0">The first formatting parameter.</param>
      <param name="arg1">The second formatting parameter.</param>
      <param name="arg2">The thirs formatting parameter.</param>
    </member>
    <member name="M:PostSharp.Trace.Write(System.String)">
      <summary>
            Writes a message to the current sink without formatting parameter.
            </summary>
      <param name="message">Message.</param>
    </member>
    <member name="M:PostSharp.Trace.WriteLine(System.String,System.Object[])">
      <summary>
            Writes a message to the current sink with many formatting parameters, and issues a line break.
            </summary>
      <param name="format">Message formatting string.</param>
      <param name="parameters">Formatting parameters.</param>
    </member>
    <member name="M:PostSharp.Trace.WriteLine(System.String,System.Object)">
      <summary>
            Writes a message to the current sink with a single formatting parameter, 
            and issues a line break.
            </summary>
      <param name="format">Message formatting string.</param>
      <param name="arg0">The first formatting parameter.</param>
    </member>
    <member name="M:PostSharp.Trace.WriteLine(System.String,System.Object,System.Object)">
      <summary>
            Writes a message to the current sink with two formatting parameters, 
            and issues a line break.
            </summary>
      <param name="format">Message formatting string.</param>
      <param name="arg0">The first formatting parameter.</param>
      <param name="arg1">The second formatting parameter.</param>
    </member>
    <member name="M:PostSharp.Trace.WriteLine(System.String,System.Object,System.Object,System.Object)">
      <summary>
            Writes a message to the current sink with three formatting parameters, 
            and issues a line break.
            </summary>
      <param name="format">Message formatting string.</param>
      <param name="arg0">The first formatting parameter.</param>
      <param name="arg1">The second formatting parameter.</param>
      <param name="arg2">The thirs formatting parameter.</param>
    </member>
    <member name="M:PostSharp.Trace.WriteLine(System.String)">
      <summary>
            Writes a message to the current sink without parameter, 
            and issues a line break.
            </summary>
      <param name="format">Message formatting string.</param>
    </member>
    <member name="P:PostSharp.Trace.IsGloballyEnabled">
      <summary>
            Determines whether tracing is globally enabled.
            </summary>
    </member>
    <member name="P:PostSharp.Trace.Enabled">
      <summary>
            Determines whether the current trace sink is enabled.
            </summary>
    </member>
    <member name="T:PostSharp.UnreachableException">
      <summary>
            Formal exception thrown after calling a method that always results in an exception,
            so that static analyzers do not complain.
            </summary>
    </member>
    <member name="M:PostSharp.UnreachableException.#ctor">
      <summary>
            Initializes an <see cref="T:PostSharp.UnreachableException" /> with default message.
            </summary>
    </member>
    <member name="M:PostSharp.UnreachableException.#ctor(System.String)">
      <summary>
            Initializes an <see cref="T:PostSharp.UnreachableException" /> with a given message.
            </summary>
      <param name="message">Exception message.</param>
    </member>
    <member name="M:PostSharp.UnreachableException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes an <see cref="T:PostSharp.UnreachableException" /> with a given message and inner <see cref="T:System.Exception" />.
            </summary>
      <param name="message">Exception message.</param>
      <param name="inner">Inner exception.</param>
    </member>
    <member name="M:PostSharp.UnreachableException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Deserialization constructor.
            </summary>
      <param name="info">Serialization info.</param>
      <param name="context">Streaming context.</param>
    </member>
    <member name="T:PostSharp.Utilities.Function`1">
      <summary>
            Represents a parameterless function.
            </summary>
      <typeparam name="T">Type of the function result.</typeparam>
      <returns />
    </member>
  </members>
</doc>